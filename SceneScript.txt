field0	field1	field2	field3	field4	
4	"Global Functions - Scene"	"--
-- Scene Functions
--
Scene.__meta.__index = function(table, key)
	if Scene[key] == nil and type(key) == \"string\" and string.sub(key,1,4) == \"Wait\" then
		-- try and generate a Wait wrapper function for this function
		local baseFuncName = string.sub(key,5)
		local baseFunc = Scene[baseFuncName]
		if baseFunc then
			-- the function exists, generate a wrapper
			local waitWrapperFunc = function(self, ...)
				return self:Wait(baseFunc(self, ...))
			end
			Scene[key] = waitWrapperFunc
		end
	end
	
	return Scene[key]
end

function Scene:WaitCondition(conditionFunc, freq, maxTime)
	local elapsed = 0;
	if not freq or freq == 0 then
		-- Poll every frame. Reuse the same sync object to avoid allocations
		local timer = self:Timer(0)
		while conditionFunc() ~= true or (maxTime and maxTime < elapsed) do
			elapsed = elapsed + .01;
			timer:Reset()
			self:Wait(timer)
		end
	else
		-- Poll at a certain frequency
		while conditionFunc() ~= true or (maxTime and maxTime < elapsed) do
			elapsed = elapsed + freq;
			self:WaitTimer(freq)
		end
	end
end

function Scene:WaitEvent(freq, keepEvent)
	local waitCondition = function()
		local event = self:PeekEvent()
		if event then
			return true
		else
			return false
		end
	end
	
	self:WaitCondition(waitCondition, freq)
	local event = self:PeekEvent()
	assert(event ~= nil)
	if (keepEvent ~= true) then
		self:PopEvent()
	end
	return event
end

--
-- CreateActorAndWaitForLoad
--  create a single actor and wait for it to be fully renderable
--
function Scene:CreateActorAndWaitForLoad(createData, fadeInTime)
	local actorList = self:CreateActorsAndWaitForLoad({createData}, fadeTime)
	return actorList[1]
end

--
-- CreateActorsAndWaitForLoad
--   create a set of actors and wait for all of them to be renderable
--
function Scene:CreateActorsAndWaitForLoad(createDataList, fadeInTime)
	local actorList = {}
	for index, createData in pairs(createDataList) do
		local actor = self:SpawnActor(createData)
		actorList[index] = actor
	end

	self:WaitForActorsToLoad(actorList, fadeInTime)
	return actorList
end

--
-- WaitForActorsToLoad
--   hide all a list of actors and fade them in when all ready
--
function Scene:WaitForActorsToLoad(actorList, fadeInTime)
	if not fadeInTime then
		fadeInTime = 0.5
	end

	for index, actor in pairs(actorList) do
		actor:SetInteractible(false)
		actor:SetHidden(true)
		actor:Fade(0, 0)
	end

	local waitCondition = function()
		-- all actors must be renderable
		for index, actor in pairs(actorList) do
			if not actor:IsReadyToDisplay() then
				return false
			end
		end
		return true
	end
	self:WaitCondition(waitCondition)

	-- fade in the actors
	for index, actor in pairs(actorList) do
		actor:SetHidden(false)
		actor:Fade(1, fadeInTime)
	end

	-- wait until faded in
	if fadeInTime > 0 then
		self:WaitTimer(fadeInTime)
	end

	-- make everything interactible again
	for index, actor in pairs(actorList) do
		actor:SetInteractible(true)
	end
end"	0	0
5	"zzOld - PetBattle - Main"	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	if (battleScene.GetUIObservingPlayer) then
		observingPlayerIndex = battleScene:GetUIObservingPlayer()
		if (observingPlayerIndex > 0) then
			isObserved = true
		end
	end
else
	-- no battle scene implies a manually created test battle
	isObserved = true
	observingPlayerIndex = 1
end

--------------------------------------------------------------------------------
-- see if we\'re using test teams
if (battleScene and battleScene:UseTestPlayerData() == true) or (not initialBattleState) then
	initialBattleState = InitTestTeams()
end

--------------------------------------------------------------------------------
-- build ability and abilityTurn map
petAbilities = { }
petAbilityTurns = { }
for j,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
	for i,abilityTurn in pairs(ability.turns) do
		petAbilityTurns[abilityTurn.ID] = abilityTurn
	end
end

--------------------------------------------------------------------------------
-- spawn teams
if (isObserved == true) then
	-- backwards compatibility
	initialBattleState.players[observingPlayerIndex].teamFacing = 0
	initialBattleState.players[3-observingPlayerIndex].teamFacing = 180
else
	initialBattleState.players[1].teamFacing = 0
	initialBattleState.players[2].teamFacing = 180
end

teams = { initialBattleState.players[1], initialBattleState.players[2] }
InitTeam(teams[1])
InitTeam(teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		SetCamera(3)
	end

	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local effect = nil
	if (battleScene:IsTestBattle() == true) then
		effect = GenerateTestBattleEvent()
		if (not effect) then
			scene:WaitTimer(0)
		end
	else
		-- poll for round effects
		local waitForEffects = function()
			return battleScene:HasPendingEffects()
		end
		scene:WaitCondition(waitForEffects)
		effect = battleScene:GetPendingEffect()
	end

	inBattle, winnerID = ProcessEffect(effect)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if winnerTeam.activePet ~= petIndex and pet.currentHealth > 0 then
			-- move backline up to celebrate
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	SetCamera(4);
end

scene:WaitTimer(0.75)
battleScene:SignalBattleComplete()
"	0	0
6	"zzOld - PetBattle - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(4)
			pet.actor:Fade(GetAlpha(pet), 2)
			scene:WaitTimer(2)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function GetAlpha(pet)
	
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end

end
"	0	0
7	"Darren\'s Test Scene Script 1"	"print(\"START: Darren\'s Test Script 2!!\")

--scene:SetRelativeCoords(false)

--local pathData = scene:LoadPath(3045)

local fireCreatureID = 60157
local fireCreateData = ActorCreateData:Default()
fireCreateData.creatureID = fireCreatureID
fireCreateData.groundSnap = false
fireCreateData.interactible = false

--local fireActors = scene:SpawnActorsAtPoints(fireCreateData, 3036)

-- create a guy to follow a path
nazgrimCreatureID = 60149
local nazgrimCreateData = ActorCreateData:Default()
local testModel = \"world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"
--nazgrimCreateData.model = testModel
nazgrimCreateData.creatureID = nazgrimCreatureID
--nazgrimCreateData.transform = Transform:New(Vector:New(2273.87, 974.358, 482.445), 7.86258)
nazgrimCreateData.transform = Transform:New(Vector:New(0, 10, 0), 7.86258)
nazgrim = scene:SpawnActivePlayerCloneActor(nazgrimCreateData, true)

--nazgrim:FollowPath(3045, 20)


local cameraBunnyCreate = ActorCreateData:Default()
local stalkerModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
cameraBunnyCreate.name = \"cameraBunny\"
cameraBunnyCreate.model = stalkerModel
cameraBunnyCreate.interactible = false
cameraBunny = scene:SpawnActor(cameraBunnyCreate)

scene:WaitTimer(4)

nazgrim:BroadcastText(BroadcastType.Say, 63387)

--scene:SetGameCameraTarget(nazgrim, 5, 30)

--[[
local voHandle = nazgrim:PlaySoundKit(25898, true)
nazgrim:WaitSoundKitComplete(voHandle)
scene:WaitTimer(0.5)

local soundHandle = nazgrim:PlaySoundKit(25504, false)
scene:WaitTimer(10)
soundHandle:Stop()
]]

local reasonIndex = 0
while true do
	scene:WaitTimer(5)
	reasonIndex = reasonIndex + 1
	if (reasonIndex > MissReasons.Reflected) then
		reasonIndex = 1
	end

	--nazgrim:AddWorldText(nil, MissReasons.Physical, false, false)
	nazgrim:AddWorldText(nil, reasonIndex, false, false)
--	nazgrim:PlaySoundKit(13169, true)
end

print(\"-- END: Darren\'s Test Script 1 --\")
"	0	0
8	"Darren\'s Test Scene Script 2"	"print(\"DazTest2\")

actorCreateData = ActorCreateData:New(53828, Transform:New(Vector:New( 5, 5, 3), -90), 0.5)
--actorCreateData.groundSnap = true
actor = scene:SpawnActor(actorCreateData)

actorCreateData.transform = Transform:New(Vector:New( -10, -10, 3))
actor2 = scene:SpawnActor(actorCreateData)

scene:WaitTimer(1)
scene:SetCamera(416, 0, actor, actor2)
--blah22

scene:WaitTimer(2)
actor:PlayLoopingFullBodyAnim(Animations.Hover)
actor:SetSnapToGround(false)
actor:WaitMoveToRel(Vector:New(0,0,5), 1)
actor:WaitMoveToRel(Vector:New(5,0,0), 2)
actor:WaitMoveToRel(Vector:New(0,0,-3), 3)
actor:SetHoverHeight(2)
actor:SetSnapToGround(true)
actor:WaitMoveToRel(Vector:New(5,0,0), 2)
scene:SetCamera(0, 2.5, nil, nil)

scene:WaitTimer(10)

print(\"-- END: Darren\'s Test Script 2 --\")


"	0	0
9	"Global Functions - Actor"	"--
-- Actor Functions
--
function Actor:WaitCondition(...)
	local scene = self:GetScene()
	if scene then
		scene:WaitCondition(...)
	end
end

function Actor:WaitCastingComplete(checkAnims, spellID)
	local waitCondition = function()
		return ((not self:IsCasting()) and ((not checkAnims) or (checkAnims ~= true) or
		(
			((not spellID) or (not self:HasSpellEffect(spellID))) and
			(not self:IsPlayingSpellPreCastAnim()) and
			(not self:IsPlayingSpellCastAnim()) and
			(not self:IsPlayingCombatAction())
		)))
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitCastSpell(...)
	self:CastSpell(...)
	self:WaitCastingComplete()
end

function Actor:WaitMissilesReleased(spellVisualInstanceID)
	local waitCondition = function()
		return not self:HasPendingMissiles(spellVisualInstanceID)
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitMissilesImpacted(spellVisualInstanceID)
	local waitCondition = function()
		return not self:HasPendingOrInFlightMissiles(spellVisualInstanceID)
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitReadyToDisplay()
	local waitCondition = function()
		return not self:IsReadyToDisplay()
	end
	self:WaitCondition(waitCondition)
end

--
-- ActorCreateData Functions
--
function ActorCreateData:Default()
	local c =
	{
		creatureID = 0,
		creatureDisplayID = 0,
		model = \"\",
		scale = 1.0,
		name = \"\",
		transform = Transform:New(),
		hoverHeight = 0.0,
		groundSnap = true,
		interactible = true,
		floatingTooltip = true,
	}
	setmetatable(c, self.__meta)
	return c
end

function ActorCreateData:New(_id, _trans, _scale)
	local c = ActorCreateData:Default()

	c.creatureID = _id or c.creatureID
	c.scale = _scale or c.scale
	c.transform = _trans

	return c
end

function ActorCreateData:NewDisplay(_creatureID, _displayId, _trans, _scale)
	local c = ActorCreateData:Default()

	c.creatureID = _creatureID or c.creatureID
	c.creatureDisplayID = _displayID or c.creatureDisplayID
	c.scale = _scale or c.scale
	c.transform = _trans

	return c
end

function ActorCreateData:NewModel(_name, _modelFile, _trans, _scale)
	local c = ActorCreateData:Default()

	c.model = _modelFile
	c.scale = _scale or c.scale
	c.name = _name
	c.transform = _trans

	return c
end
"	0	0
10	"Global Functions - Math"	"--
-- Vector Functions
--
function Vector:New(_x, _y, _z)
	local v = { x = _x or 0, y = _y or 0, z = _z or 0 }
	setmetatable(v, self.__meta)
	return v
end

function Vector:ToString()
	return string.format(\"(%.3f, %.3f, %.3f)\", self.x, self.y, self.z)
end

Vector.Concat = function(a, b)
	local stringA = a
	if type(stringA) ~= \"string\" then
		stringA = a:ToString()
	end

	local stringB = b
	if type(stringB) ~= \"string\" then
		stringB = b:ToString()
	end

	return (stringA .. stringB)
end

Vector.Add = function(a, b)
	return Vector:New(a.x + b.x, a.y + b.y, a.z + b.z)
end

Vector.Sub = function(a, b)
	return Vector:New(a.x - b.x, a.y - b.y, a.z - b.z)
end

Vector.Mul = function(a, b)
	if type(a) == \"number\" then
		return Vector:New(a * b.x, a * b.y, a * b.z)
	else
		return Vector:New(a.x * b, a.y * b, a.z * b)
	end
end

Vector.Div = function(a, b)
	if type(b) == \"number\" then
		return Vector.Mul(a, 1.0 / b)
	end
end

Vector.Neg = function(a)
	return Vector:New(-a.x, -a.y, -a.z)
end

Vector.Magnitude = function(v)
	return math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
end

Vector.Normalize = function(v)
	local magnitude = v:Magnitude();

  	return Vector:New(
			v.x/magnitude, 
			v.y/magnitude, 
			v.z/magnitude);
end

Vector.CrossProduct = function ( a, b ) 
	local normalA, normalB = a:Normalize(), b:Normalize();

	return Vector:New( 
		((normalA.y * normalB.z) - (normalA.z * normalB.y)),
		((normalA.z * normalB.x) - (normalA.x * normalB.z)),
		((normalA.x * normalB.y) - (normalA.y * normalB.x)) 
		)
end

Vector.Dist = function ( a, b ) 
	return math.pow (math.pow( a.x-b.x, 2 ) + 
					 math.pow( a.y-b.y, 2 ) +  
					 math.pow( a.z-b.z, 2 ) , 0.5 );
end

Vector.UnitVectorFromAtoB = function ( a, b ) 
	local dist = a:Dist( b );

	return Vector:New( 
			(a.x-b.x) / dist,
			(a.y-b.y) / dist,
			(a.z-b.z) / dist);
end 

-- add funnctions to the metatable
Vector.__meta.__tostring = Vector.ToString
Vector.__meta.__add = Vector.Add
Vector.__meta.__sub = Vector.Sub
Vector.__meta.__mul = Vector.Mul
Vector.__meta.__div = Vector.Div
Vector.__meta.__unm = Vector.Neg
Vector.__meta.__len = Vector.Magnitude
Vector.__meta.__concat = Vector.Concat

--
-- Transform Functions
--
function Transform:New(v, _yaw, _pitch, _roll)
	local t =
	{
		position = v or Vector:New(),
		yaw = _yaw or 0,
		pitch = _pitch or 0,
		roll = _roll or 0
	}
	setmetatable(t, self.__meta)
	return t
end
"	0	0
11	"Darren\'s Test Scene Script 3"	"print(\"-- START: Darren\'s Test Script 3 --\")
print(\"Ahoy Thar dsfasdfafsds\")
print(\"-- END: Darren\'s Test Script 3 --\")
"	0	0
12	"Darren\'s Test Scene Script 5"	"print(\"-- START: Darren\'s Test Scene Script 5\")

-- if you have an actor somewhere in the global scope, follow it
if RunFollower then
	RunFollower(actor)
end

print(\"-- END: Darren\'s Test Scene Script 5\")
"	0	0
13	"Darren\'s Movement and Facing Test"	"print(\"-- START: Darren\'s Movement and Facing Test --\")

-- worldport 0, -13191.1, 259.751, 21.8579, 88.5582
points =
{
	Vector:New(-13191.5, 261.017, 21.857),
	Vector:New(-13200.5, 274.399, 21.857),
	Vector:New(-13214.2, 265.146, 21.857),
	Vector:New(-13204.1, 250.901, 21.857),
}

scene:SetRelativeCoords(false)

pointIndex = 1

actorCreateData = ActorCreateData:New(55242, Transform:New(points[pointIndex], 100), 1.0)
actor = scene:SpawnActor(actorCreateData)

scene:WaitTimer(5)

-- cut to initial camera
scene:SetCamera(302, 0.0, nil, nil)

speed = 6.0
count = 1
while true do
	local thisPoint = points[pointIndex]
	pointIndex = (pointIndex % #points) + 1
	local nextPoint = points[pointIndex]
	local lookPoint = points[(pointIndex % #points) + 1] -- look another point ahead for the head

	local offsetX = nextPoint.x - thisPoint.x
	local offsetY = nextPoint.y - thisPoint.y
	local dist = math.sqrt(offsetX*offsetX + offsetY*offsetY)

	if count == 4 then
		scene:SetCamera(0, 1, nil, nil)
	elseif count < 4 then

		if pointIndex == 1 then
			scene:SetCamera(302, 10.0, nil, nil)
	--	elseif pointIndex == 2 then
	--		scene:SetCamera(0, 0.5, nil, nil)
		elseif pointIndex == 3 then
			scene:SetCamera(303, 20.0, nil, nil)
		end

	end

	count = count + 1

	actor:SetFacingToAbs(lookPoint)
	scene:WaitTimer(2)
	actor:ClearFacing()
	actor:SetHeadFacingToAbs(nextPoint)
	scene:WaitTimer(2)
	actor:ClearHeadFacing()
	scene:WaitTimer(2)

	-- start moving towards the next point
	actor:MoveToAbs(nextPoint, dist / speed)
	print(\"MoveTo: points[\" .. pointIndex .. \"]\" .. nextPoint:ToString())

	-- cheecky over the shoulder look
	scene:WaitTimer(0.5)
	actor:SetHeadFacingToAbs(lookPoint)
	scene:WaitTimer(1)
	actor:ClearHeadFacing()

	actor:WaitMovementComplete()
	scene:WaitTimer(1)


end

actor:Despawn()

print(\"-- END: Darren\'s Movement and Facing Test --\")
"	0	0
14	"Kun Lai Summit - Horde Hub Swap Scene - Worker 01 - JSB"	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( panda01, 1 )

-- run to the tents
RunToLocation( panda01, 5.5, 2290.39, 944.073, 481.63, 341.549 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire02 )
PutOutFire( fire03 )
PutOutFire( fire14 )

Wait(1)

RunToLocation( panda01, 3, 2293.17, 950.125, 481.201, 337.517 )

PlayLoopingSplitBodyAnim( panda01, Animations.EmoteWork )

Wait(2)

FadeOut( fire02.smoke )
FadeOut( fire03.smoke )
FadeOut( fire14.smoke )

Wait(1)

FadeIn( workDust01, 5 )
FadeIn( workDust05, 5 )

-- nazgrim trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

StopLoopingSplitBodyAnim( panda01 )

RunToLocation( panda01, 3, 2276.55, 970.392, 482.394, 101.25 )
panda01: Despawn()"	0	0
16	"Darren\'s Math Test"	"print(\"Darren\'s Math Test\")

v1 = Vector:New(1, 2, 3)
v2 = Vector:New(2, 4, 6)

v3 = Vector.Add(v1, v2)

print(\"v1 = \" .. v1 .. \", v2 = \" .. v2 .. \", add = \" .. v3)

v3 = v1 - v2
print(\"v1 = \" .. v1 .. \", v2 = \" .. v2 .. \", sub = \" .. v3)

v3 = v1*4
print(\"v1 = \" .. v1 .. \", v2 = \" .. v2 .. \", mul x 4 = \" .. v3)

v3 = -v1
print(\"v1 = \" .. v1 .. \", v2 = \" .. v2 .. \", minus = \" .. v3)

len = v1:Magnitude()
-- len = #v1 -- NOTE: this doesn\'t work in Lua 5.1!
print(\"len = \" .. len)
"	0	0
17	"zzOld - PetBattle - Effect Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forard then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
18	"Darren\'s Follower"	"print(\"-- START: Darren\'s Follower --\")

function RunFollower(followTarget)
	local followOffsetX = 5

	if not followTarget then
		return
	end

	local scene = followTarget:GetScene()
	scene:WaitTimer(2)

	local spawnPos = followTarget:GetPosition()
	spawnPos.x = spawnPos.x + followOffsetX

	local actorCreateData = ActorCreateData:New(55242, Transform:New(spawnPos, 0), 1.5)
	local actor = scene:SpawnActor(actorCreateData)
	actor:SetHeadFacingToTarget(followTarget, Vector:New())
	actor:SetInteractible(false)

	while true do
		local facePos = followTarget:GetPosition()
		actor:SetFacingToAbs(facePos)
		scene:WaitTimer(15)

		facePos = followTarget:GetPosition()
		actor:SetFacingToAbs(facePos)
		scene:WaitTimer(15)

		actor:ClearFacing()

		local movePos = followTarget:GetPosition()
		movePos.x = movePos.x + followOffsetX


		actor:WaitMoveToAbs(movePos, 2)
	end

end

print(\"-- END: Darren\'s Follower --\")
"	0	0
22	"Test - Alex\'s Battle Pet - Turn Loop"	"

scene:WaitTimer(2.0)
while 1 do

	local moveTime
	for team=1,2 do 
		local action = math.random (1, 3);

		local pet = allPlayers[team].pets[ allPlayers[team].activePet ]


		local nextTeam = math.fmod(team,2)+1;
		local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]


		if ( action == 1 ) then
			local newPetIndex = math.fmod(allPlayers[team].activePet, #allPlayers[team].pets)+1;
			newPet = allPlayers[team].pets[newPetIndex];

			-- Swap active pet
			allPlayers[team].activePet = newPetIndex

			-- Perform the emote
			allPlayers[team].master:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
			scene:WaitTimer(1.0)

			-- Swap the action
			PerformSwap(pet,newPet, opponent)
		elseif ( action == 2 ) then
			PerformMove(pet,opponent)
		else
			PerformMove(pet,opponent)
		end
	end
end
scene:WaitTimer(20.0)
--
-- done

--------------------------------------------------------------------------------
print(\"|cFFAAFFAAEND: Alex\'s Battle Stage|r\");
--------------------------------------------------------------------------------
"	0	0
25	"Kun Lai Summit - Horde Hub Swap Scene - Master Script - JSB"	"
scene:WaitTimer(2)

scene:SetCamera(304,0,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:SetCamera(305,26,nil,nil)

scene:WaitTimer(18) --was 28
scene:SetCamera(311,25,nil,nil)

scene:WaitTimer(18) --was 28

scene:SetCamera(306,10,nil,nil)

scene:WaitTimer(10)

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0
30	"Kun Lai Summit - Horde Hub Swap Scene - Worker 02 - JSB"	"
-- small tent panda 02
-- wait a little before running in
Wait(2)
FadeIn( panda02, 1 )

-- run to the tents
RunToLocation( panda02, 5.5, 2298.76, 922.011, 481.216, 28.7984 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda02, fire16.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire04, smokeFadeOutTime )
PutOutFire( fire08, smokeFadeOutTime )
PutOutFire( fire16, smokeFadeOutTime )

Wait(1)

RunToLocation( panda02, 3, 2301.44, 926.885, 481.203, 57.6166 )

PlayLoopingSplitBodyAnim( panda02, Animations.EmoteWork )

Wait(2)

FadeOut( fire04.smoke )
FadeOut( fire08.smoke )
FadeOut( fire16.smoke )

Wait(1)

FadeIn( workDust02, 5 )


WaitForTrigger( \"flagPlant\" )

Wait(2)

StopLoopingSplitBodyAnim( panda02 )

RunToLocation( panda02, 3, 2270.03, 950.734, 481.315, 24.7839 )
panda02: Despawn()"	0	0
33	"Darren\'s Test Scene Script 6"	"print(\"-- START: Darren\'s Test Script 6 --\")

local fireCreateData1 = ActorCreateData:NewModel(
	\"Camp Fire\",
	\"world\\generic\\human\\passive doodads\\firewood\\firewoodpile04.m2\",
	Transform:New(Vector:New(0, 0, 0), 0),
	2.0)


local fireCreateData2 = ActorCreateData:NewModel(
	\"Fireworks\",
	\"spells\\fireworks_redstreaks_01.m2\",
	Transform:New(Vector:New(0, 0, 0), 0),
	0.5)

local actorList = scene:CreateActorsAndWaitForLoad({fireCreateData1, fireCreateData2})
local fireActor = actorList[1]
fireActor:SetInteractible(false)
	
while 1 do
	scene:WaitTimer(1)
	local transform = fireActor:GetTransform()
--	transform.position = transform.position + Vector:New(0, 0.1, 0)
	transform.yaw = transform.yaw + 5
	fireActor:SetTransform(transform)
end

print(\"-- END: Darren\'s Test Script 6 --\")
"	0	0
35	"Test - Alex\'s Battle Pet - Test Library"	"-- Add two vectors
function VectorSum( vectorA, vectorB ) 
	return Vector:New( vectorA.x+vectorB.x, vectorA.y+vectorB.y, vectorA.z+vectorB.z );
end

-- Distance between two points
function VectorDist( vectorA, vectorB ) 
	return math.pow (math.pow( vectorA.x-vectorB.x, 2 ) + 
					 math.pow( vectorA.y-vectorB.y, 2 ) +  
					 math.pow( vectorA.z-vectorB.z, 2 ) , 0.5 );	
end

-- Copy a vector
function VectorCopy( vectorA ) 
	return Vector:New( vectorA.x, vectorA.y, vectorA.z )
end

-- Scale a vector up
function VectorScale( vectorA, multi )
	return Vector:New( vectorA.x*multi, vectorA.y*multi, vectorA.z*multi )
end


-- Scale a vector up per axis
function VectorScalePerAxis( vectorA, multiX, multiY, multiZ )
	return Vector:New( vectorA.x*multiX, vectorA.y*multiY, vectorA.z*multiZ )
end

-- Magnitude
function VectorMagnitude ( vectorA )
	return math.pow( 
				math.pow(vectorA.x,2) +
				math.pow(vectorA.y,2) +
				math.pow(vectorA.z,2), 0.5 );
end

-- Normalize
function UnitVectorNormalize ( vectorA ) 
	local magnitude = VectorMagnitude ( vectorA );
  
	return Vector:New(
			vectorA.x/magnitude, 
			vectorA.y/magnitude, 
			vectorA.z/magnitude);
end

-- Unit vector pointing from A to B
function UnitVectorFromAtoB( vectorA, vectorB ) 
	local dist = VectorDist( vectorA, vectorB );

	if (dist == 0 ) then 
		return Vector:New(0,0,1);
	end

	return Vector:New( 
			(vectorB.x-vectorA.x) / dist,
			(vectorB.y-vectorA.y) / dist,
			(vectorB.z-vectorA.z) / dist);
end

-- Unit vector pointing in the perpendicular angle
function UnitVectorCrossProduct ( vectorA, vectorB ) 
	local normalA, normalB = UnitVectorNormalize(vectorA), UnitVectorNormalize(vectorB);

	return Vector:New( 
		((normalA.y * normalB.z) - (normalA.z * normalB.y)),
		((normalA.z * normalB.x) - (normalA.x * normalB.z)),
		((normalA.x * normalB.y) - (normalA.y * normalB.x)) 
		)
end

-- A common function I use for 
function FastLocalFacingCoordinates( baseLoc, faceLoc, offset ) 
	local frontVector = UnitVectorFromAtoB(baseLoc, faceLoc);
	local upVector = UnitVectorFromAtoB(baseLoc, VectorSum(baseLoc, Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	local newLoc = baseLoc
			+ frontVector * offset.x
			+ leftVector * offset.y
			+ upVector * offset.z;

	return newLoc;
end"	0	0
36	"Test - Alex\'s Battle Pet - Move Library 2"	"-- Variables

backwardSpeedMulti = 0.8

function PerformTripleAttack(pet, opponent, damage)
	local points = {
	}

	local numPoints = 5;
	local offset=270
	local step= 720/numPoints;

	for i=offset+step,offset+720,step do 
		local sin = math.sin(i/180*math.pi)
		local cos = math.cos(i/180*math.pi)
		table.insert(points, Vector:New(sin, cos, 0));

	end

	print (\"triple\");
	pet.actor:SetFacingToTarget(opponent.actor, Vector:New())

	local originalOpponentLoc = VectorCopy(opponent.actor:GetPosition());
	local originalPetLoc = VectorCopy(pet.actor:GetPosition());

	for i=1, #points do 
		local v = points[i];
		local newDrift = FastLocalFacingCoordinates(originalOpponentLoc, originalPetLoc , v * -battleScale );

		local opponentDriftPoint 	= opponent.actor:GetPosition() + (newDrift-originalOpponentLoc);
		local driftDistance = opponentDriftPoint:Dist( pet.actor:GetPosition() )

		pet.actor:CastSpell( 122, opponent.actor)	
		pet.actor:WaitMoveToAbs(opponentDriftPoint,driftDistance/pet.moveSpeed );

		opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)
		PerformTinyKnockback(opponent, pet, damage/5)

	end
	pet.actor:ClearFacing();
end
"	0	0
37	"Test - Alex\'s Battle Pet - Move Library 1"	"function CalculateLocationFacingRelativeOffset(pet, location, front, left, up)
	FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );

	return FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );
end

function CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 
	local opponentLocation = opponent.actor:GetPosition();

	return CalculateLocationFacingRelativeOffset(opponent, pet.actor:GetPosition(), front, left, up);
end

function PerformRelativeBump( opponent, pet, front, left, up ) 
	local newDrift = CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 

	local opponentDriftPoint 	= opponent.actor:GetPosition() + newDrift;
	local driftDistance = opponentDriftPoint:Dist( opponent.actor:GetPosition() )

	opponent.actor:MoveToAbs(opponentDriftPoint, driftDistance/battleScale/opponent.moveSpeed );

end

function PerformDodge( opponent, pet) 
	local coin = math.random(0,1);
	if ( coin == 0 ) then 
		coin = -1;
	end

	local front = 0.1;
	local left = 1*coin;
	local up = 0;

	print(\"dodge\") 

	PerformRelativeBump( opponent, pet, front, left, up );
end


function PerformKnockback( opponent, pet, damage ) 
	local front = math.random(10,20)*.01;
	local left = math.random(-10,10)/10;
	local up = 0;

	scene:WaitTimer(0.3)

	print(\"knock\")		
	opponent.actor:AddDamageText(nil, damage, false, false)
	PerformRelativeBump( opponent, pet, front, left, up );
end


function PerformHardKnockback( opponent, pet, damage ) 
	local front = -3;
	local left = 0
	local up = 0;

	scene:WaitTimer(0.3)

	print(\"knock\")		
	opponent.actor:AddDamageText(nil, damage, false, false)
	local opponentFinalPoint 	= opponent.actor:GetPosition() + CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up );
	local driftDistance = 3

	local duration = driftDistance/battleScale/opponent.moveSpeed;

	--opponent.actor:MoveToAbs(opponentFinalPoint,  Vector:New() );
	opponent.actor:SetSnapToGround(false)
	opponent.actor:MoveSplineAbs( 
			BuildKnockbackSpline(opponent, opponentFinalPoint, duration), duration )
	opponent.actor:WaitMovementComplete()
	opponent.actor:SetSnapToGround(true)

end 


function PerformTinyKnockback( opponent, pet, damage ) 
	local front = math.random(15,15)*.01;
	local left = math.random(-15,15)*.01;
	local up = 0;

	--scene:WaitTimer(0.3)

	--print(\"tinyknock\")		
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)

	opponent.actor:AddDamageText(nil, damage, false, false)


	--PerformRelativeBump( opponent, pet, front, left, up );
end

function PerformVerticalKnockback( opponent, pet, damage ) 
	opponent.actor:SetSnapToGround(false)
	opponent.actor:AddDamageText(nil, damage, false, false)

	--opponent.actor:MoveSplineAbs(BuildKnockbackSpline(opponent, opponent.actor:GetPosition(), 0.5), 0.5)


	opponent.actor:WaitMovementComplete()
	opponent.actor:SetSnapToGround(true)
end"	0	0
38	"Test - Alex\'s Battle Pet - Boundary Guy"	"

--[[
local fireCreateData2 = ActorCreateData:NewModel(
	\"Fireworks\",
	\"spells\\fireworks_redstreaks_01.m2\",
	Transform:New(Vector:New(0, 0, 0), 0),
	0.5)

local actorList = scene:CreateActorsAndWaitForLoad({fireCreateData1, fireCreateData2})
local fireActor = actorList[1]
fireActor:SetInteractible(false)
]]

--[[
local newActor = scene:SpawnActor(
	ActorCreateData:NewModel(
		\"Fireworks\",
		\"SPELLS\\Fireball_Missile_High.m2\",
		Transform:New(Vector:New(7.5,0,0), 0),
		1
	) );
]]

local segments = 4;
local distance = 7.5;


local fences = { 
};

local corners = { 
	Vector:New(7.5,0,0),
	Vector:New(0,-7.5,0),
	Vector:New(-7.5,0,0),
	Vector:New(0.0,7.5),
};

for i=1, #corners do 
	local curr=corners[i];
	local next=corners[math.fmod((i),#corners)+1];

	local dx = next.x-curr.x;
	local dy = next.y-curr.y;

	local stepX = dx/4;
	local stepY = dy/4;
	for d = 1, 4 do 
		if i == 2 or i == 4 then 
			table.insert(fences ,
				Transform:New(Vector:New(curr.x+stepX*d,curr.y+stepY*d,0), 225+90*(i))
			);
		else
			table.insert(fences ,
				Transform:New(Vector:New(curr.x+stepX*d,curr.y+stepY*d,0), 45+90*(i))
			);
		end
	end
end

local z = {
	Transform:New(Vector:New(7.50,0,0), -45),
	Transform:New(Vector:New(3.75,-3.75,0), -45),
	Transform:New(Vector:New(0,7.5,0), 45),
	Transform:New(Vector:New(3.75,3.75,0), 45),
	Transform:New(Vector:New(0,-7.5,0), -135),
	Transform:New(Vector:New(-3.75,-3.75,0), -135),
	Transform:New(Vector:New(-7.5,0,0), 135),
	Transform:New(Vector:New(-3.75,3.75,0), 135),
};
local listOfFenceCreateData = {}
for k,v in pairs(fences) do 
	table.insert(listOfFenceCreateData, 
		ActorCreateData:NewModel( 
			\"Ring\",
			\"WORLD\\EXPANSION01\\DOODADS\\EVERSONG\\FENCE\\BE_Fence_Eversong02.m2\",
			v,
			0.5
		)
	);


end
fenceActors = scene:CreateActorsAndWaitForLoad(listOfFenceCreateData, 0);
for k,v in pairs(fenceActors) do
	v:SetInteractible(false);
end


--[[

local arrayOfPoints = {
	Vector:New(   7.50,	  -0,  0),
	Vector:New(   3.75, -3.75,  0),
	Vector:New(   0,	-7.5,  0),
	Vector:New(  -3.75,	-3.75,  0),
	Vector:New(  -7.50,	  -0,  0),
	Vector:New(  -3.75, 3.75,  0),
	Vector:New(      0,  7.5,  0),
	Vector:New(   3.75, 3.75,  0)
};

--
local actors = {

}; 
for k,v in pairs ( arrayOfPoints ) do 
	local newActor = scene:SpawnActor(
		ActorCreateData:NewModel(
			\"Fireworks\",
			\"SPELLS\\Fireball_Missile_High.m2\",
			Transform:New(v, 0), 0.5) );
		
	newActor:SetInteractible(false);
	table.insert(actors, {actor=newActor,point=k});
end

forward = true
current = 0

while true do 
	if ( forward ) then
		direction = 1
	else
		direction = -1
	end
	current = current + direction;
	if ( current> #arrayOfPoints ) then
		current = 1
	elseif ( current <= 0 ) then
		current = #arrayOfPoints
	end

	for k,v in pairs(actors) do 
		v.actor:MoveToAbs(arrayOfPoints[math.fmod(current+v.point, #arrayOfPoints)+1], 1.5)
	end
	actors[1].actor:WaitMovementComplete()
end
]]
"	0	0
39	"Kun Lai Summit - Horde Hub Swap Scene - Init - Generic Actors 01 - JSB"	"
smokeFadeOutTime = 10
throwBucketSpellID = 115882

-- Spawn all tents
smallPandaTentCreatureID = 60522
largePandaTentCreatureID = 60525
smallHordeTentCreatureID = 60526
largeHordeTentCreatureID = 60527
tent01 = SpawnActor( smallPandaTentCreatureID, 2302.269, 948.937, 481.253, 211 ) -- PANDA small tent 01
tent02 = SpawnActor( smallPandaTentCreatureID, 2307.038, 936.111, 481.234, 195 ) -- PANDA small tent 02
tent03 = SpawnActor( largePandaTentCreatureID, 2269.875, 897.456, 480.156, 80 ) -- PANDA Large tent
tent04 = SpawnActor( smallHordeTentCreatureID, 2302.269, 948.937, 481.253, 211 ) -- HORDE small tent
tent05 = SpawnActor( smallHordeTentCreatureID, 2307.038, 936.111, 481.234, 195 ) -- HORDE small tent
tent06 = SpawnActor( largeHordeTentCreatureID, 2269.875, 897.456, 480.156, 80 ) -- HORDE Large tent
FadeOut( tent04, 0 )
FadeOut( tent05, 0 )
FadeOut( tent06, 0 )

-- Spawn all worker pandas
pandaCreatureID = 60152
panda01 = SpawnActor( pandaCreatureID, 2280.04, 981.489, 482.941, 266.84 )
panda02 = SpawnActor( pandaCreatureID, 2286.43, 977.096, 483.15, 276.065 )
panda03 = SpawnActor( pandaCreatureID, 2272.74, 989.461, 483.852, 303.416 )
panda04 = SpawnActor( pandaCreatureID, 2278.36, 992.575, 484.587, 300.843 )
panda05 = SpawnActor( pandaCreatureID, 2269.89, 986.992, 483.538, 320.384 )
panda06 = SpawnActor( pandaCreatureID, 2224.33, 972.759, 489.625, 276.767 )
FadeOut( panda01, 0 )
FadeOut( panda02, 0 )
FadeOut( panda03, 0 )
FadeOut( panda04, 0 )
FadeOut( panda05, 0 )
FadeOut( panda06, 0 )

-- Spawn all the fires to be put out
-- SpawnFire( x, y, z, scale )
fire01 = SpawnFire( 2295.05, 964.531, 483.92, 1 ) -- banner north - TARGET
fire02 = SpawnFire( 2304.65, 937.658, 483.913, 1 ) -- tent, small - WORKER 1
fire03 = SpawnFire( 2298.1, 941.111, 481.459, 1 ) -- tent, small - WORKER 1
fire04 = SpawnFire( 2316.1, 928.04, 481.757, 1 ) -- tent, small - WORKER 2
fire05 = SpawnFire( 2308.92, 906.934, 491.892, 1 ) -- tower - WORKER 3
fire06 = SpawnFire( 2313.74, 905.326, 503.25, 1 ) -- tower - WORKER 3
fire07 = SpawnFire( 2268.93, 889.865, 499.961, 1 ) -- tent, main - WORKER 5
fire08 = SpawnFire( 2319.66, 937.674, 483.92, 1 ) -- tent, small - WORKER 2
fire09 = SpawnFire( 2322.18, 902.429, 482.895, 1 ) -- tower - WORKER 3
fire10 = SpawnFire( 2306.92, 900.443, 481.481, 2 ) -- tower - large fire - TARGET - WORKER 3
fire11 = SpawnFire( 2268.31, 895, 481.306, 2 ) -- tent, main - TARGET - WORKER 5
fire12 = SpawnFire( 2278.66, 901.373, 490.065, 1 ) -- tent, main - WORKER 5
fire13 = SpawnFire( 2262.79, 913.825, 481.15, 1 ) -- tent, main - WORKER 5
fire14 = SpawnFire( 2300.67, 947.892, 481.201, 1 ) -- tent, small - WORKER 1
fire15 = SpawnFire( 2308.14, 962.451, 485.35, 0.5 ) -- banner north, small - nearby
fire16 = SpawnFire( 2305.58, 928.971, 481.152, 0.5 ) -- tent, small, small fire - WORKER 2
fire17 = SpawnFire( 2316.01, 915.215, 481.615, 0.5 ) -- tower, small fire - WORKER 3

fire18 = SpawnFire( 2255.46, 960.028, 480.485, 0.5 ) -- off-screen, small fire - WORKER 6
fire19 = SpawnFire( 2250.81, 942.753, 485.231, 0.5 ) -- off-screen, small fire - WORKER 6
fire20 = SpawnFire( 2241.63, 902.193, 489.048, 0.5 ) -- off-screen, small fire - WORKER 6
fire21 = SpawnFire( 2242.29, 934.299, 481.146, 1 ) -- off-screen, fire - WORKER 6
fire22 = SpawnFire( 2236.61, 915.137, 481.721, 1 ) -- off-screen, fire - WORKER 6
fire23 = SpawnFire( 2245.97, 915.745, 481.147, 2 ) -- off-screen, fire - WORKER 6
fire24 = SpawnFire( 2264.56, 954.792, 481.163, 0.7 ) -- off-screen, fire - WORKER 6

"	0	0
40	"Kun Lai Summit - Hub Swap Scene - Util - JSB"	"
fireBunnyCreatureID = 60291
fireCreatureID = 60157
smokeCreatureID = 60406


-- custom stuff for this scene
function SpawnFire( x, y, z, scale )

	local fireSet = { }
	fireSet.bunny = SpawnActor( fireBunnyCreatureID, x, y, z, 0, scale )
	fireSet.fire = SpawnActor( fireCreatureID, x, y, z, 0, scale )
	fireSet.smoke = SpawnActor( smokeCreatureID, x, y, z, 0, scale )
	
	-- start with smokes invisible
	fireSet.smoke:Fade(0, 0)

	return fireSet

end

function SpawnSmoke( x, y, z, scale )

	-- visible smoke
	local smoke = SpawnActor( smokeCreatureID, x, y, z, 0, scale )
	return smoke

end

function PutOutFire( fire )

	fire.fire:Fade( 0, 1 ) -- fire fade out
	fire.smoke:Fade( 1, 3 ) -- smoke  fade in

end
"	0	0
41	"Cinematic Framework"	"
-- default all cinematics to non relative
scene:SetRelativeCoords(false) -- set to absolute worlld coords

function Wait( time )
	scene:WaitTimer( time )
end

--
-- SpawnActor( creatureID, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnActor( creatureID, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local spawnPos = Vector:New( x, y, z )
	local spawnTransform = Transform:New( spawnPos, facing )
	createData = ActorCreateData:New( creatureID, spawnTransform, scale )
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actor = scene:SpawnActor( createData )
	actor:SetInteractible( false )
	return actor

end

--
-- SpawnModelActor( modelFileName, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnModelActor( modelFileName, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local pos = Vector:New( x, y, z )
	local transform = Transform:New( pos, facing )
	createData = ActorCreateData:NewModel( \"dummy\", modelFileName, transform, scale )
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actor = scene:SpawnActor( createData )
	return actor

end


--
-- RunToLocation( actor, speed, x, y, z, facing [default = direction of travel] )
--   Run actor to location at speed
--
function RunToLocation( actor, speed, x, y, z, facing )

	local destPos = Vector:New(x, y, z)
	
	local currPos = actor:GetPosition()
	local offset = currPos - destPos
	local distance = offset:Magnitude()

	local travelTime = distance / speed
	
	actor:WaitMoveToAbs( destPos, travelTime )

	if facing then
		actor:SetFacing( facing )
	end

end


--
-- CastSpellAtActor( caster, target, spellID, faceTarget [default = false] )
--   Cast a spell at the target actor
--
function CastSpellAtActor( caster, target, spellID, faceTarget )

	-- turn to face the target if required
	if faceTarget and faceTarget == true then
		caster:SetFacingToTarget( target, Vector:New() )
		scene:WaitTimer( 0.75 )
	end

	caster:CastSpell( spellID, target )
	
	if faceTarget and faceTarget == true then
		caster:ClearFacing()
	end

end

--
-- PlayLoopingSplitBodyAnim( actor, anim )
--   Play a looping animation on the actor
--
function PlayLoopingSplitBodyAnim( actor, anim )

	actor:PlayLoopingSplitBodyAnim( anim )

end

--
-- StopLoopingSplitBodyAnim( actor )
--   Stop playing a looping animation on the actor
--
function StopLoopingSplitBodyAnim( actor )

	actor:PlayLoopingSplitBodyAnim( anim )

end

--
-- PlayOneShotSplitBodyAnim( actor, anim )
--   Play a looping animation on the actor
--
function PlayOneShotSplitBodyAnim( actor, anim )

	actor:PlayOneShotSplitBodyAnim( anim )

end

--
-- StopLoopingSplitBodyAnim( actor )
--   Stop the looping anim kit currently playing on the actor
--
function StopLoopingSplitBodyAnim( actor )

	actor:StopAnimKit( AnimKits.LoopingSplitBody )

end

--
-- FadeOut( actor, fadeTime [ default = 2 ] )
--   Fade the actor out over fadeTime seconds
--
function FadeOut( actor, fadeTime )

	if not fadeTime then
		fadeTime = 2
	end

	actor:Fade( 0, fadeTime )

end

--
-- FadeIn( actor, fadeTime [ default = 0.5 ] )
--   Fade the actor in over fadeTime seconds
--
function FadeIn( actor, fadeTime )

	if not fadeTime then
		fadeTime = 0.5
	end

	actor:Fade( 1, fadeTime )

end

Triggers = { }
function SendTrigger( triggerName )
	Triggers[triggerName] = true
end

function WaitForTrigger( triggerName )

	local waitCondition = function()
		return (Triggers[triggerName] == true)
	end
	"	0	599
47	"Global Constants - Animation"	"
-- Useful Anim Kit IDs
AnimKits =
{
	OneShotSplitBody	= 2127;
	OneShotUpperBody	= 2128;
	OneShotFullBody		= 2129;
	LoopingSplitBody	= 2130;
	LoopingUpperBody	= 2131;
	LoopingFullBody		= 2132;
}


-- Construct an animation table out of the 5 individual anim tables
-- When we have removed the 4000 character limit we can eliminate this step

Animations = { }

function AddToAnimTable(subTable)
	for animName, id in pairs(subTable) do
		Animations[animName] = id
	end
end

AddToAnimTable(AnimTable1)
AddToAnimTable(AnimTable2)
AddToAnimTable(AnimTable3)
AddToAnimTable(AnimTable4)

-- avoid duplicate memory
AnimTable1 = nil
AnimTable2 = nil
AnimTable3 = nil
AnimTable4 = nil
"	0	0
48	"Test - Alex\'s Battle Pet - CoreMove"	"
function PerformMove(pet, opponent, effect)

		local opponentLocation = opponent.actor:GetPosition();
		local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
		local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
		local leftVector = UnitVectorCrossProduct(frontVector, upVector);

		local meleePoint = frontVector * 1*battleScale;
		local rangedPoint = frontVector * 3*battleScale;

		local meleeAttackPoint = opponentLocation + meleePoint;
		local rangedAttackPoint = opponentLocation + rangedPoint;

		pet.actor:ClearFacing(); 

		local move = 1--math.random(1,6);

		local melee = true; 
		local ranged = false;

		if ( move == 4 or move == 5 ) then
			melee = false;
		elseif ( move == 6 ) then 
			melee = false;
			ranged = true;
		end

		if ( melee ) then 
			local distance = meleeAttackPoint:Dist( pet.actor:GetPosition() );
			moveTime = distance/battleScale/(pet.moveSpeed);
			pet.actor:WaitMoveToAbs(meleeAttackPoint, moveTime)
		elseif ( ranged ) then 
			local distance = rangedAttackPoint:Dist( pet.actor:GetPosition() );
			moveTime = distance/battleScale/(pet.moveSpeed);
			pet.actor:WaitMoveToAbs(rangedAttackPoint, moveTime)
		else
			pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
		end

	local damage = opponent.health - effect.targets[1].newHealth;
	opponent.health = opponent.health - damage;
		
		if ( move == 6 ) then
			PerformRuptureLine(pet, opponent, damage)
		elseif ( move == 5 ) then 
			PerformArcaneBarrage(pet, opponent, damage);
		elseif ( move == 4 ) then 
			PerformWaveAttack( pet,opponent, damage );
		elseif ( move == 1 ) then
			PerformTripleAttack( pet, opponent, damage );
		elseif ( move == 2 ) then 
			PerformDodge(opponent, pet);
			pet.actor:CastSpell( 122, opponent.actor );
		else
			pet.actor:CastSpell( 122, opponent.actor );

			PerformKnockback(opponent, pet, damage);
		end
		
		pet.actor:WaitCastingComplete(true, 122)
		scene:WaitTimer(0.25)

		ReturnOrResetCheck( pet, opponent );

		--pet.actor:SetFacingToAbs(pet.currentLocation)
end

function ReturnOrResetCheck (pet, opponent)
	local newFrontVector = UnitVectorFromAtoB(opponent.actor:GetPosition(), pet.actor:GetPosition()  );
	local returnPoint = newFrontVector * 1.5*battleScale;

	local petLoc = returnPoint;
	local petHome = HOME_LIST[pet.team].position;
	local newDist = petLoc:Dist ( petHome );

	local returnDistance = pet.actor:GetPosition():Dist(petLoc)

	if ( newDist > 3 * battleScale ) then 
		petLoc = HOME_LIST[pet.team].position;
		returnDistance = petHome:Dist(pet.actor:GetPosition());
		print ( \"reset\" );
	end

	local opponentHome = HOME_LIST[opponent.team].position;

	local opponentReturnDistance = opponent.actor:GetPosition():Dist(opponentHome)

	if ( opponentReturnDistance > 3 * battleScale ) then 		
		local distance = opponentHome:Dist(pet.actor:GetPosition());
		print ( \"opponent reset\" );
		opponent.actor:WaitMoveToAbs( opponentHome, distance/ ( opponent.moveSpeed*backwardSpeedMulti) );

	end

	--pet.actor:WaitMoveToAbs( pet.home, returnDistance/ ( pet.speed*backwardSpeedMulti) );

	pet.actor:WaitMoveToAbs( petLoc, returnDistance/ ( pet.moveSpeed*backwardSpeedMulti) );
	pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
end"	0	0
49	"Kun Lai Summit - Horde Hub Swap Scene - Worker 03 - JSB"	"
-- tower fire panda
-- wait a little before running in
Wait(3)
FadeIn( panda03, 1 )

-- run to the tents
RunToLocation( panda03, 5.5, 2294.56, 906.778, 480.939, 346.291 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda03, fire10.bunny, throwBucketSpellID )

-- wait for missile to hit
-- Wait(2)
PutOutFire( fire10, smokeFadeOutTime )
PutOutFire( fire05, smokeFadeOutTime )
PutOutFire( fire06, smokeFadeOutTime )
PutOutFire( fire09, smokeFadeOutTime )
PutOutFire( fire17, smokeFadeOutTime )

Wait(1)

RunToLocation( panda03, 3, 2286.12, 903.9, 481.107, 204.091 )

PlayLoopingSplitBodyAnim( panda03, Animations.EmoteWork )

-- Wait(2)

FadeOut( fire10.smoke )
FadeOut( fire05.smoke )
FadeOut( fire06.smoke )
FadeOut( fire09.smoke )
FadeOut( fire17.smoke )

FadeIn( workDust04, 5 )
FadeIn( workDust06, 5 )

-- nazgrim trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

StopLoopingSplitBodyAnim( panda03 )

Wait(10)

panda03: Despawn()"	0	0
50	"Kun Lai Summit - Horde Hub Swap Scene - Worker 04 - JSB"	"
-- northern banner panda
-- wait a little before running in
Wait(10)
FadeIn( panda04, 1 )

-- run to north post
RunToLocation( panda04, 5.5, 2294.89, 972.168, 484.038, 262.369 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda04, fire01.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire01, smokeFadeOutTime )
PutOutFire( fire15, smokeFadeOutTime )

Wait(1)

RunToLocation( panda04, 5, 2295.67, 968.115, 484.196, 257.869 )

PlayLoopingSplitBodyAnim( panda04, Animations.EmoteWork )

Wait(2)

FadeOut( fire01.smoke )
FadeOut( fire15.smoke )"	0	0
51	"Kun Lai Summit - Horde Hub Swap Scene - Worker 05 - JSB"	"
-- large tent panda
-- wait a little before running in
Wait(2)
FadeIn( panda05, 1 )

-- run to the tents
RunToLocation( panda05, 5.5, 2279.65, 959.75, 481.641, 287.309 )
RunToLocation( panda05, 5.5, 2269.5, 922.868, 481.587, 273.584 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda05, fire11.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(3.5)
PutOutFire( fire11, smokeFadeOutTime )
PutOutFire( fire07, smokeFadeOutTime )
PutOutFire( fire12, smokeFadeOutTime )
PutOutFire( fire13, smokeFadeOutTime )

Wait(1)

RunToLocation( panda05, 3, 2268.36, 914.467, 481.184, 210.584 )

PlayLoopingSplitBodyAnim( panda05, Animations.EmoteWork )

Wait(2)

FadeOut( fire11.smoke )
FadeOut( fire07.smoke )
FadeOut( fire12.smoke )
FadeOut( fire13.smoke )

-- Wait(1)

FadeIn( workDust03, 5 )

WaitForTrigger( \"flagPlant\" )

Wait(1.5)

StopLoopingSplitBodyAnim( panda05 )

RunToLocation( panda05, 3, 2256.42, 939.436, 481.148, 126.017 )
panda05: Despawn()"	0	0
52	"Test - Alex\'s Battle Pet - CoreSwap"	"
function PerformSwap ( pet, newPet, opponent )
	local currentPetLoc = pet.actor:GetPosition();
	local currentBacklineLoc = newPet.actor:GetPosition();

	local distance = currentPetLoc:Dist(currentBacklineLoc);

	-- New guy faces the enemy
	newPet.actor:SetFacingToAbs(opponent.actor:GetPosition())

	-- Swap locations
	pet.actor:ClearFacing();
	pet.actor:MoveToAbs(currentBacklineLoc, distance/pet.moveSpeed)
	newPet.actor:WaitMoveToAbs(currentPetLoc, distance/newPet.moveSpeed)

	ReturnOrResetCheck( newPet, opponent );

	-- Make all of your pets look at their teammate

	for k,v in pairs( allPlayers[pet.team].pets ) do 
		if ( k ~= allPlayers[pet.team].activePet ) then 
			v.actor:SetFacingToTarget(newPet.actor, Vector:New());
		end
	end
end "	0	0
53	"Test - Alex\'s Battle Pet - Init"	"print(\"|cFFCCFFccAlex\'s Battle Pet Stage|r\")

--------------------------------------------------------------------------------
-- battle constants
--------------------------------------------------------------------------------
battleScale    = 1.0
initialFadeInTime = 0.5 
backlineAlpha = 1.0
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}
 

HOME_LIST = {
	Transform:New(Vector:New( 2*battleScale, 0, 0), 180);
	Transform:New(Vector:New( -2*battleScale, 0, 0), 0);
};
MASTER_SPOTS = { 
	Transform:New(Vector:New( 6, -6, 3), 180);
	Transform:New(Vector:New( -6, 6, 3), 0);
};
BACKROW_PET_OFFSETS = {
	Vector:New(-1, 2, 0 );
	Vector:New(-1, -2, 0 );
};

allPlayers = { }

function InitTeam(team)

	-- Store the team object
	allPlayers[#allPlayers + 1] = team;

	-- Spawn a Pad
	local homeTransform = HOME_LIST[#allPlayers];

	-- Spawn Pad Location Object
	team.pad = DoPadInit(homeTransform);

	-- Create the Master
	local masterTransform = MASTER_SPOTS[#allPlayers];
	local masterLoc = masterTransform.position;
	
	local master = scene:SpawnActor(ActorCreateData:New(55242, masterTransform, battleScale) );
	master:SetFacingToAbs(Vector:New());

	-- Assign the master to his team
	team.master = master;

	-- Assign Pets to temporary data
	team.pets = {};

	mainPetLoc = homeTransform;
	
	local backLineCount = 0;

	for k,v in pairs( team.petDescs ) do 
		if ( k == team.activePet ) then 
			table.insert(team.pets, InitPet(team, k, mainPetLoc) );
		else
			backLineCount = backLineCount + 1;

			-- Placed in master-relative coordinates
			local offset = FastLocalFacingCoordinates ( masterTransform.position, Vector:New(), BACKROW_PET_OFFSETS[backLineCount] );
			local newPet = InitPet(team, k, Transform:New( offset, masterTransform.yaw ) );

			table.insert(team.pets, newPet );
		end
	end

	-- Make them all face the guy in the center
	for k,v in pairs(team.pets) do
		if ( k ~= team.activePet ) then 
			v.actor:SetFacingToTarget(team.pets[team.activePet].actor, Vector:New());
		end
	end

	-- Save the home loc
	team.home = homeTransform.position;

end

function InitPet(team, petIndex, transform)
	local petData = team.petDescs[petIndex];
	local petActor = scene:SpawnActor(ActorCreateData:New(petData.creatureID, transform, battleScale))

	-- apply initial auras / states
	for auraIndex, auraData in pairs(petData.auras or { }) do
		--[[
		local abilityTurn = petAbilityTurns[auraData.abilityTurnID]
		if (abilityTurn) then
			ApplyAura(pet, auraData.instanceID, abilityTurn.spellVisualID)
		end
		]]--
	end

	-- Initially invisible?
	petActor:SetInteractible(false);
	petActor:SetHidden(true);
	petActor:Fade(0, 0);

	local pet = { actor = petActor; moveSpeed = 5; auras = {}; slot = petIndex; team = team.playerID; health = petData.health };

	return pet;
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetHidden(false)

			local targetAlpha = backlineAlpha
			if slot == player.activePet then
				-- use the front alpha if it is the active pet
				targetAlpha = 1.0 --GetAlpha(pet)
			end

			pet.actor:Fade(targetAlpha, fadeInTime or 1)
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetInteractible( true )
		end
	end

end

"	0	0
54	"Kun Lai Summit - Horde Hub Swap Scene - Worker 06 - JSB"	"
-- off-screen panda
-- wait a little before running in
Wait(2)
FadeIn( panda06, 1 )

-- run to the tents
RunToLocation( panda06, 5.5, 2246.38, 937.082, 481.146, 302.191 )

Wait(1)

-- throw bucket at tents
-- CastSpellAtActor( panda06, fire11.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire18, smokeFadeOutTime )
PutOutFire( fire19, smokeFadeOutTime )
PutOutFire( fire20, smokeFadeOutTime )
PutOutFire( fire21, smokeFadeOutTime )
PutOutFire( fire22, smokeFadeOutTime )
PutOutFire( fire23, smokeFadeOutTime )
PutOutFire( fire24, smokeFadeOutTime )

Wait(3)

RunToLocation( panda06, 3, 2256.22, 910.613, 481.148, 327.391 )

PlayLoopingSplitBodyAnim( panda06, Animations.EmoteWork )

Wait(3)

FadeOut( fire18.smoke )
FadeOut( fire19.smoke )
FadeOut( fire20.smoke )
FadeOut( fire21.smoke )
FadeOut( fire22.smoke )
FadeOut( fire23.smoke )
FadeOut( fire24.smoke )

-- nazgrim trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

StopLoopingSplitBodyAnim( panda06 )

RunToLocation( panda06, 3, 2254.1, 944.32, 481.123, 104.867 )
panda06: Despawn()
"	0	0
55	"zzOld - PetBattle - Test Teams"	"--------------------------------------------------------------------------------
-- Test Teams
function InitTestTeams()

	local currentAbilityID = 0
	local abilityID = function()
		currentAbilityID = currentAbilityID + 1
		return currentAbilityID
	end

	local currentTurnID = 0
	local turnID = function()
		currentTurnID = currentTurnID + 1
		return currentTurnID
	end

	-- Venomous Bite
	local venomousBite = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 32739,
				isMelee = true,
				spellVisualID = 809,
				castTime = 0.0,
				impactTime = 0.1,
			}
		}
	}	

	-- Acid Spit
	local acidSpit = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 20657,
				isMelee =  false,
				spellVisualID = 854,
				castTime = 1.0,
				impactTime = 0.5,
			}
		}
	}

	-- Heroic Strike
	local heroicStrike = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 78,
				isMelee =  true,
				spellVisualID = 19654,
				castTime = 0.0,
				impactTime = 0.1,
			}
		}
	}

	-- Frost Nova
	local frostNova = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 122,
				isMelee =  true,
				spellVisualID = 17,
				castTime = 0.0,
				impactTime = 0.0,
			}
		}
	}

	-- Chain Lightning
	local chaingLightning = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 421,
				isMelee =  false,
				spellVisualID = 36,
				castTime = 1.5,
				impactTime = 0.0,
			}
		}
	}

	-- Fireball
	local fireBall = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 133,
				isMelee =  false,
				spellVisualID = 67,
				castTime = 1.25,
				impactTime = 0.25,
			}
		}
	}	

	-- Fire Nova
	local fireNova =
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 11969,
				isMelee =  true,
				spellVisualID = 963,
				castTime = 2.0,
				impactTime = 0.0,
			}
		}
	}	

	-- Immolate
	local immolate = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 348,
				isMelee =  false,
				spellVisualID = 46,
				castTime = 1.5,
				impactTime = 0.0,
			}
		}
	}	

	local abilityList = 
	{
		venomousBite,
		acidSpit,
		heroicStrike,
		frostNova,
		chaingLightning,
		fireBall,
		fireNova,
		immolate
	}

	-- set up the parent ability IDs
	for j,ability in pairs(abilityList) do
		for i,abilityTurn in pairs(ability.turns) do
			abilityTurn.abilityID = ability.ID
		end
	end

	-- Raptor
	local petDescRaptor = 
	{
		creatureID = 59709,
		health = 100,
		abilityIDs = { venomousBite.ID, acidSpit.ID, heroicStrike.ID }
	}

	-- Robot
	local petDescRobot =
	{
		creatureID = 59710,
		health = 100,
		abilityIDs = { frostNova.ID, chaingLightning.ID, heroicStrike.ID }
	}

	-- Fire Elemental
	local petDescFireElemental =
	{
		creatureID = 59795,
		health = 100,
		abilityIDs = { fireBall.ID, fireNova.ID, immolate.ID }
	}

	-- Team 1
	local team1 =
	{
		playerID = 1,	
		activePet = 1,
		petDescs = { petDescRaptor, petDescRobot, petDescFireElemental }
	}

	-- Team 2
	local team2 =
	{
		playerID = 2,
		activePet = 2,
		petDescs = { petDescRobot, petDescFireElemental, petDescRaptor }
	}

	local initBattleState = 
	{
		players = { team1, team2 };
		abilityDescs = abilityList;
	}

	return initBattleState
end
"	0	0
56	"Test - Alex\'s Battle Pet - Move Library 3"	"
-- Barrage of Moonfires
function PerformArcaneBarrage (pet, opponent, damage)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition(), opponentLocation   );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);


print(\"barrage\");
	local beams = {};
	for i = 1, 5 do 
		local f = math.random(-150,150)*0.01;
		local l = math.random(-250,250)*0.01;

		if ( i == 3 ) then 
			f,l = 0,0
		end

		local v = frontVector*f+leftVector*l;
		v = opponentLocation + v;
		local t = Transform:New(v,math.random(-180,180));

		local create = ActorCreateData:NewModel(
			\"Moonfire\",
			\"SPELLS\\MOONFIRE_IMPACT_BASE.m2\",
			t,
			0.5);
		local newActor = scene:SpawnActor(create);

		table.insert(beams, newActor);
		scene:WaitTimer(0.3)
		opponent.actor:AddDamageText(nil, damage/5, false, false)
	end

	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)

	scene:WaitTimer(1.0)

	for k,v in pairs(beams) do 
		v:Despawn();
	end
end

"	0	0
57	"Kun Lai Summit - Horde Hub Swap Scene - Init - Named Actors - JSB"	"
-- Spawn all actors
nazgrimCreatureID = 60149
kirynCreatureID = 60592
bannerCreatureID = 60574
nazgrim01 = SpawnActor( nazgrimCreatureID, 2284.16, 980.726, 483.094, 266.8 ) -- Nazgrim
kiryn01 = SpawnActor( kirynCreatureID, 2287.65, 982.313, 483.283, 70 ) -- Kiryn
banner01 = SpawnActor( bannerCreatureID, 2284.02, 917.727, 481.979, 345 ) -- Banner

-- Initial fade
FadeOut( nazgrim01, 0 )
FadeOut( kiryn01, 0 )
FadeOut( banner01, 0 )"	0	0
58	"Kun Lai Summit - Horde Hub Swap Scene - Nazgrim 01 - JSB"	"

-- wait before running in
Wait(20)

FadeIn( nazgrim01, 5 )

-- run to tent
RunToLocation( nazgrim01, 5, 2284.52, 921.019, 481.976, 272 )

Wait(1)

-- plant banner - NEED EMOTE HERE
-- CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )


-- tent swap
PlayOneShotSplitBodyAnim( nazgrim01, Animations.Attack1H )
Wait(0.5)
FadeIn( banner01, 0 )

FadeIn( tent04, 1 )
FadeIn( tent05, 1 )
FadeIn( tent06, 1 )
FadeOut( tent01, 0 )
FadeOut( tent02, 0 )
FadeOut( tent03, 0 )

Wait(1)

FadeOut( workDust01, 2 )
FadeOut( workDust02, 2 )
FadeOut( workDust03, 2 )
FadeOut( workDust04, 2 )
FadeOut( workDust05, 2 )
FadeOut( workDust06, 2 )

SendTrigger( \"flagPlant\" )

-- walk to tent
RunToLocation( nazgrim01, 3, 2273.15, 914.13, 481.287, 262.367 )
RunToLocation( nazgrim01, 3, 2272.32, 907.589, 481.128, 273.167 )
RunToLocation( nazgrim01, 3, 2272.157, 896.843, 481.231, 100 )


"	0	0
59	"Kun Lai Summit - Horde Hub Swap Scene - Init - Generic Actors 02 - JSB"	"
-- Spawn Dust Clouds
workDustModel = \"spells\\xplosion_dust_impact_noflash.m2\"
workDust01 = SpawnModelActor( workDustModel, 2298.7, 950.208, 481.153, 126.691 )
workDust02 = SpawnModelActor( workDustModel, 2305.26, 935.646, 481.217, 2.49143 )
workDust03 = SpawnModelActor( workDustModel, 2267.43, 910.647, 481.253, 199.366, 2 )
workDust04 = SpawnModelActor( workDustModel, 2279.81, 904.865, 482.649, 61.441 )
workDust05 = SpawnModelActor( workDustModel, 2304.87, 952.176, 481.153, 37.365 )
workDust06 = SpawnModelActor( workDustModel, 2276.11, 901.96, 492.636, 237.166, 3 )

FadeOut( workDust01, 0 )
FadeOut( workDust02, 0 )
FadeOut( workDust03, 0 )
FadeOut( workDust04, 0 )
FadeOut( workDust05, 0 )
FadeOut( workDust06, 0 )"	0	0
60	"Kun Lai Summit - Horde Hub Swap Scene - Kiryn 01 - JSB"	"
-- wait before running in
Wait(22)

FadeIn( kiryn01, 0 )

-- run into scene
RunToLocation( kiryn01, 5, 2284.09, 957.011, 481.36, 248.193 )
RunToLocation( kiryn01, 5, 2271.45, 940.75, 481.629, 300 )

-- nazgrim trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

PlayOneShotSplitBodyAnim( kiryn01, Animations.EmoteCheer )

Wait(2.5)

PlayOneShotSplitBodyAnim( kiryn01, Animations.EmoteApplaud )

Wait(10)
kiryn01: Despawn()"	0	0
61	"Global Functions - Actor Movement"	"
function Actor:WaitMovementComplete()
	local waitCondition = function()
		return not self:IsMoving()
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitMoveToRel(...)
	self:MoveToRel(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveSplineRel(...)
	self:MoveSplineRel(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveToAbs(...)
	self:MoveToAbs(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveSplineAbs(...)
	self:MoveSplineAbs(...)
	self:WaitMovementComplete()
end
"	0	0
62	"Global Functions - Actor Animation"	"--
-- Animation Helper Functions
--
function Actor:PlayLoopingAnimKit(animKitID)	return self:PlayAnimKit(animKitID, true, Animations.None)			end
function Actor:PlayLoopingSplitBodyAnim(anim)	return self:PlayAnimKit(AnimKits.LoopingSplitBody, false, anim)		end
function Actor:PlayLoopingUpperBodyAnim(anim)	return self:PlayAnimKit(AnimKits.LoopingUpperBody, false, anim)		end
function Actor:PlayLoopingFullBodyAnim(anim)	return self:PlayAnimKit(AnimKits.LoopingFullBody, false, anim)		end

function Actor:StopLoopingSplitBodyAnim()		return self:StopAnimKit(AnimKits.LoopingSplitBody)					end
function Actor:StopLoopingUpperBodyAnim()		return self:StopAnimKit(AnimKits.LoopingUpperBody)					end
function Actor:StopLoopingFullBodyAnim()		return self:StopAnimKit(AnimKits.LoopingFullBody)					end

function Actor:PlayOneShotAnimKit(animKitID)	return self:PlayAnimKit(animKitID, false, Animations.None)			end
function Actor:PlayOneShotSplitBodyAnim(anim)	return self:PlayAnimKit(AnimKits.OneShotSplitBody, true, anim)		end
function Actor:PlayOneShotUpperBodyAnim(anim)	return self:PlayAnimKit(AnimKits.OneShotUpperBody, true, anim)		end
function Actor:PlayOneShotFullBodyAnim(anim)	return self:PlayAnimKit(AnimKits.OneShotFullBody, true, anim)		end

function Actor:WaitAnimKitComplete(animKit)
	if not animKit then
		return
	end
	local waitCondition = function()
		return animKit:IsStopped()
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitPlayOneShotAnimKit(animKitID)	self:WaitAnimKitComplete(self:PlayAnimKit(animKitID, false, Animations.None))		end
function Actor:WaitPlayOneShotSplitBodyAnim(anim)	self:WaitAnimKitComplete(self:PlayAnimKit(AnimKits.OneShotSplitBody, true, anim))	end
function Actor:WaitPlayOneShotUpperBodyAnim(anim)	self:WaitAnimKitComplete(self:PlayAnimKit(AnimKits.OneShotUpperBody, true, anim))	end
function Actor:WaitPlayOneShotFullBodyAnim(anim)	self:WaitAnimKitComplete(self:PlayAnimKit(AnimKits.OneShotFullBody, true, anim))	end
"	0	0
63	"zzOld - PetBattle - Test Events"	"
--------------------------------------------------------------------------------
-- A Random Battle To The Death
local testBattleCurrentPlayer = 1
function GenerateTestBattleEvent()

	local event = nil

	local attacker = GetActivePetByIndex(testBattleCurrentPlayer)
	local victim = GetActivePetByIndex(3-testBattleCurrentPlayer)
	local turnType
	if (victim.currentHealth <= 0) then
		-- force swap victim
		turnType = 1
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
	elseif (attacker.currentHealth <= 0) then
		-- force swap my pet (killed self somehow)
		turnType = 1
	else
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
		turnType = math.random(2)
	end

	local playerID = testBattleCurrentPlayer
	attacker = GetActivePetByIndex(playerID)
	victim = GetActivePetByIndex(3-playerID)

	if (turnType == 1) then
		local team = GetTeamByIndex(playerID)
		-- find a living pet to swap to
		local aliveBacklinePets = { }
		local numAlive = 0
		for petIndex, pet in pairs(team.pets) do
			if (petIndex ~= team.activePet) and (pet.currentHealth > 0) then
				numAlive = numAlive + 1
				aliveBacklinePets[numAlive] = petIndex
			end
		end

		if (numAlive > 0) then
			local petIndex = aliveBacklinePets[math.random(#aliveBacklinePets)]

			event =
			{
				type = PetBattleEffect.PetSwap;
				casterPlayerID = playerID;
				newFrontPet = petIndex;
			}
		end
	elseif (turnType == 2) then
		local abilityIndex = math.random(#attacker.desc.abilityIDs)
		local abilityID = attacker.desc.abilityIDs[abilityIndex]
		local usedAbilityTurnID = petAbilities[abilityID].turns[1].ID
		local abilityDamage = math.random(40,60)
		local targetHealth = victim.currentHealth - abilityDamage
		local attackerPlayerID = playerID

		event =
		{
			type = PetBattleEffect.Ability;
			casterPlayerID = attackerPlayerID;
			casterPetSlot = attacker.slot;
			abilityTurnID = usedAbilityTurnID;
			targets =
			{
				{
					playerID = 3 - attackerPlayerID;
					petSlot = victim.slot;
					newHealth = targetHealth;
				}
			};
		}
	end

	if (event) then
		scene:WaitTimer(0.25)
	end

	return event

end
"	0	0
64	"zzOld - PetBattle - Effect Ability"	"
--------------------------------------------------------------------------------
-- ABILITY

function EffectAbility(effect)
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, effect.abilityTurnID)
	if (not spellVisualID) then
		print(\"ERROR: no spellVisual found for abilityTurn \" .. effect.abilityTurnID)
		return
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		targetPet.actor:PlaySpellImpactVisual(spellVisualID)

		local newHealth = targetData.newHealth
		SetHealth(targetPet, newHealth, false)
	end

	-- wait until the casters animation has completed
	casterCastingPet.actor:WaitCastingComplete(true)
end
"	0	0
65	"zzOld - PetBattle - Effect Aura Apply"	"
--------------------------------------------------------------------------------
-- APPLY AURA

function EffectAuraApply(effect)
	
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, effect.auraAbilityTurnID)
	if (not spellVisualID) then
		return
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		targetPet.actor:PlaySpellImpactVisual(spellVisualID)

		-- apply an aura, tracked by instance ID
		ApplyAura(targetPet, targetData.auraInstanceID, spellVisualID)

		local newHealth = targetData.newHealth
		SetHealth(targetPet, newHealth, false)
	end

	-- wait until the casters animation has completed
	casterCastingPet.actor:WaitCastingComplete(true)

end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)

end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end
"	0	0
66	"zzOld - PetBattle - Init Player"	"
allPlayers = { }

function InitTeam(team)

	-- save the team
	allPlayers[#allPlayers + 1] = team

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, -idleRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	team.pad = scene:SpawnActor(padCreateData)
	team.pad:Fade(padAlpha, 0.5)

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }

		team.pets[id] = pet
			
		local radius = backlineRadius
		local offset = 0
		if id == team.activePet then
			radius = idleRadius
		else
			offset = backLineOffset
			backLineOffset = backLineOffset + backlineSpacing
		end
		
		local pos = BuildVector(team.teamFacing, -radius, offset)
		local transform = Transform:New(pos, team.teamFacing)
		
		local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
		petCreateData.creatureDisplayID = petDesc.displayID or 0

		pet.actor = scene:SpawnActor(petCreateData)

		SetHealth(pet, petDesc.health, true)

		pet.currentRadius = radius
		pet.currentOffset = offset

		-- always face the opponent location (at idleRadius)
		LookAtOpposingTeam(pet)

		-- apply initial auras
		for auraIndex, auraData in pairs(petDesc.auras or { }) do
			local abilityTurn = petAbilityTurns[auraData.abilityTurnID]
			if (abilityTurn) then
				ApplyAura(pet, auraData.instanceID, abilityTurn.spellVisualID)
			end
		end

		-- hide all pets until loaded
		pet.actor:SetInteractible(false)
		pet.actor:SetHidden(true)
		pet.actor:Fade(0, 0)
		pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetHidden(false)

			local targetAlpha = backlineAlpha
			if slot == player.activePet then
				-- use the front alpha if it is the active pet
				targetAlpha = GetAlpha(pet)
			end

			pet.actor:Fade(targetAlpha, fadeInTime)
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetInteractible( true )
		end
	end

end


"	0	0
67	"Townlong Steppes - Ring worm Intro - Init"	"
local RingWormBossID = 62324
RingWormBoss = SpawnActor( RingWormBossID, 1209.34, 2818.61, 264.553, 0, 1.0, false )"	0	0
68	"Townlong Steppes - Ring worm Intro - Camera"	"
scene:WaitTimer(1)

scene:SetCamera(400,10,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(14)
scene:SetCamera(0,4,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(4)"	0	0
69	"Townlong Steppes - Ring worm Intro - Bunny 01"	"
-- small tent panda 01
-- wait a little before running in
Wait(1)
FadeIn( RingWormBoss, 1 )"	0	0
70	"Kun Lai Summit - Alliance Hub Swap Scene - Init - Generic Actors 01 - JSB"	"
smokeFadeOutTime = 10
throwBucketSpellID = 115882

-- Spawn all tents
smallPandaTentCreatureID = 60522
largePandaTentCreatureID = 60525
smallAllianceTentCreatureID = 60820
largeAllianceTentCreatureID = 60821
tent01 = SpawnActor( smallPandaTentCreatureID, 2152.409, 1501.663, 487.742, 268.5 ) -- PANDA small tent 01
tent02 = SpawnActor( smallPandaTentCreatureID, 2138.757, 1500.734, 487.761, 284.5 ) -- PANDA small tent 02
tent03 = SpawnActor( smallPandaTentCreatureID, 2148.100, 1435.750, 487.660, 108.5 ) -- PANDA small tent 03
tent04 = SpawnActor( largePandaTentCreatureID, 2168.000, 1472.986, 480, 211.5 ) -- PANDA Large tent
tent05 = SpawnActor( smallAllianceTentCreatureID, 2152.409, 1501.663, 487.742, 268.5 ) -- ALLIANCE small tent 01
tent06 = SpawnActor( smallAllianceTentCreatureID, 2138.757, 1500.734, 487.761, 284.5 ) -- ALLIANCE small tent 02
tent07 = SpawnActor( smallAllianceTentCreatureID, 2148.100, 1435.750, 487.660, 108.5 ) -- ALLIANCE small tent 03
tent08 = SpawnActor( largeAllianceTentCreatureID, 2168.000, 1472.986, 480, 211.5 ) -- ALLIANCE Large tent
FadeOut( tent05, 0 )
FadeOut( tent06, 0 )
FadeOut( tent07, 0 )
FadeOut( tent08, 0 )

-- Spawn all worker pandas
pandaCreatureID = 60152
panda01 = SpawnActor( pandaCreatureID, 2103.91, 1417.33, 484.7, 74.5427 )
panda02 = SpawnActor( pandaCreatureID, 2096.83, 1418.82, 483.977, 68.0177 )
panda03 = SpawnActor( pandaCreatureID, 2098.09, 1414.32, 484.135, 51.8177 )
panda04 = SpawnActor( pandaCreatureID, 2103.89, 1412.06, 484.121, 65.5426 )
panda05 = SpawnActor( pandaCreatureID, 2087.87, 1438.84, 484.083, 119.093 )
panda06 = SpawnActor( pandaCreatureID, 2099.66, 1417.14, 484.388, 53.8431 )
FadeOut( panda01, 0 )
FadeOut( panda02, 0 )
FadeOut( panda03, 0 )
FadeOut( panda04, 0 )
FadeOut( panda05, 0 )
FadeOut( panda06, 0 )

-- Spawn all the fires to be put out
-- SpawnFire( x, y, z, scale )
fire01 = SpawnFire( 2159.96, 1476.05, 487.886, 3 ) -- Large panda tent, 3x fire
fire02 = SpawnFire( 2168.71, 1476.88, 487.886, 3 ) -- Large panda tent, 3x fire
fire03 = SpawnFire( 2110.28, 1485.25, 487.913, 3 ) -- Near Tower, 3x fire
fire04 = SpawnFire( 2122.64, 1493.68, 515.617, 3 ) -- Tower, 3x fire
fire05 = SpawnFire( 2125.73, 1490.26, 509.835, 1 ) -- Tower, 1x fire
fire06 = SpawnFire( 2122.71, 1496.35, 501.108, 1 ) -- Tower, 1x fire
fire07 = SpawnFire( 2124.03, 1491.26, 488.064, 1 ) -- Tower, 1x fire
fire08 = SpawnFire( 2143.5, 1508.59, 487.921, 1 ) -- Small Tents, 1x fire
fire09 = SpawnFire( 2138.67, 1499.58, 493.044, 1 ) -- Small Tents, 1x fire 
fire10 = SpawnFire( 2150.04, 1498.04, 490.246, 1 ) -- Small Tents, 1x fire 
fire11 = SpawnFire( 2120.79, 1483.48, 497.618, 1 ) -- Tower, 1x fire
fire12 = SpawnFire( 2176.27, 1470.22, 487.886, 1 ) -- Large panda tent, 1x fire
fire13 = SpawnFire( 2101.56, 1457.59, 487.886, 1 ) -- Banners, 1x fire
fire14 = SpawnFire( 2147.09, 1439, 487.886, 1 ) -- Small Tent, 1x fire
fire15 = SpawnFire( 2124.7, 1434.41, 490.16, 0.5 ) -- Banner, 0.5x fire
fire16 = SpawnFire( 2143.98, 1427.61, 487.886, 0.5 ) -- Small Tent, 0.5x fire
fire17 = SpawnFire( 2140.25, 1436.31, 488.941, 0.5 ) -- Small Tent, 0.5x fire
fire18 = SpawnFire( 2136.92, 1450.06, 488.658, 0.5 ) -- Bonfire, 0.5x fire
fire19 = SpawnFire( 2136.95, 1425.65, 487.886, 0.5 ) -- Banner, 0.5x fire
fire20 = SpawnFire( 2158.72, 1435.44, 489.272, 0.5 ) -- Small Tent, 0.5x fire
fire21 = SpawnFire( 2163.96, 1437.02, 489.037, 0.5 ) -- Small Tent, 0.5x fire
fire22 = SpawnFire( 2177.94, 1444.31, 487.903, 0.5 ) -- Small Tent, 0.5x fire
fire23 = SpawnFire( 2154.34, 1464.3, 509.851, 0.5 ) -- Large panda tent, 0.5x fire

"	0	0
71	"Kun Lai Summit - Alliance Hub Swap Scene - Init - Generic Actors 02 - JSB"	"
-- Spawn Dust Clouds
workDustModel = \"spells\\xplosion_dust_impact_noflash.m2\"
workDust01 = SpawnModelActor( workDustModel, 2147.85, 1436.33, 487.886, 126.691, 1.5 ) -- Smal Tent
workDust02 = SpawnModelActor( workDustModel, 2139.15, 1499.97, 487.886, 2.49143, 1.5 ) -- Small Tents
workDust03 = SpawnModelActor( workDustModel, 2158.62, 1472.41, 487.886, 217.141, 2 ) -- Large Tent LEFT
workDust04 = SpawnModelActor( workDustModel, 2153.06, 1501.22, 487.886, 61.441, 1.5 ) -- Small Tents
workDust05 = SpawnModelActor( workDustModel, 2146.45, 1502.85, 487.886, 37.365, 1.5 ) -- Small Tents
workDust06 = SpawnModelActor( workDustModel, 2165.57, 1466.66, 487.886, 217.366, 3 ) -- Large Tent RIGHT

FadeOut( workDust01, 0 )
FadeOut( workDust02, 0 )
FadeOut( workDust03, 0 )
FadeOut( workDust04, 0 )
FadeOut( workDust05, 0 )
FadeOut( workDust06, 0 )"	0	0
72	"Kun Lai Summit - Alliance Hub Swap Scene - Init - Named Actors - JSB"	"
-- Spawn all actors
taylorCreatureID = 60828
mishkaCreatureID = 60829
sullyCreatureID = 60861
bannerCreatureID = 60830
taylor01 = SpawnActor( taylorCreatureID, 2096.16, 1417.78, 483.821, 58 ) -- Taylor
mishka01 = SpawnActor( mishkaCreatureID, 2106.12, 1417.89, 484.903, 58 ) -- Mishka
sully01 = SpawnActor( sullyCreatureID, 2108.15, 1429.34, 486.384, 58 ) -- Sully
banner01 = SpawnActor( bannerCreatureID, 2144.02, 1472.73, 487.886, 214 ) -- Banner

-- Initial fade
FadeOut( taylor01, 0 )
FadeOut( mishka01, 0 )
FadeOut( sully01, 0 )
FadeOut( banner01, 0 )"	0	0
73	"Kun Lai Summit - Alliance Hub Swap Scene - Master Script - JSB"	"
scene:WaitTimer(2)

scene:SetCamera(314,0,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:SetCamera(315,26,nil,nil)
-- left off here
scene:WaitTimer(18) --was 28
scene:SetCamera(326,25,nil,nil)

scene:WaitTimer(18) --was 28

scene:SetCamera(327,10,nil,nil)

scene:WaitTimer(10)

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0
74	"Kun Lai Summit - Alliance Hub Swap Scene - Worker 01 - JSB"	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( panda01, 1 )

-- run to the tents
RunToLocation( panda01, 5.5, 2124.77, 1439.72, 487.887, 13.4 )
RunToLocation( panda01, 5.5, 2142.83, 1443.31, 487.887, 311.3 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda01, fire14.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire14 )
PutOutFire( fire16 )
PutOutFire( fire17 )
PutOutFire( fire20 )
PutOutFire( fire21 )
PutOutFire( fire22 )
PutOutFire( fire18 )
PutOutFire( fire19 )

Wait(1)

RunToLocation( panda01, 3, 2142.27, 1441.6, 487.886, 319.625 )

PlayLoopingSplitBodyAnim( panda01, Animations.EmoteWork )

Wait(2)

FadeOut( fire14.smoke )
FadeOut( fire16.smoke )
FadeOut( fire17.smoke )
FadeOut( fire20.smoke )
FadeOut( fire21.smoke )
FadeOut( fire22.smoke )
FadeOut( fire18.smoke )
FadeOut( fire19.smoke )

Wait(1)

FadeIn( workDust01, 5 )

-- taylor trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

StopLoopingSplitBodyAnim( panda01 )

RunToLocation( panda01, 3, 2110.84, 1445.04, 149 )
panda01: Despawn()"	0	0
75	"Kun Lai Summit - Alliance Hub Swap Scene - Worker 02 - JSB"	"
-- small tents panda 02
-- wait a little before running in
Wait(1)
FadeIn( panda02, 1 )

-- run to the tents
-- RunToLocation( panda02, 5.5, 2129.01, 1466.96, 487.886, 47.8317 )
RunToLocation( panda02, 5.5, 2152.03, 1484.51, 487.886, 91.0317 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda02, fire10.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire09, smokeFadeOutTime )
PutOutFire( fire08, smokeFadeOutTime )
PutOutFire( fire10, smokeFadeOutTime )

Wait(1)

RunToLocation( panda02, 3, 2149.38, 1493.51, 487.886, 86.5315 )

PlayLoopingSplitBodyAnim( panda02, Animations.EmoteWork )

Wait(2)

FadeOut( fire09.smoke )
FadeOut( fire08.smoke )
FadeOut( fire10.smoke )

Wait(1)

FadeIn( workDust02, 5 )
FadeIn( workDust04, 5 )
FadeIn( workDust05, 5 )


WaitForTrigger( \"flagPlant\" )

Wait(2)

StopLoopingSplitBodyAnim( panda02 )

RunToLocation( panda02, 3, 2161.75, 1492.9, 487.886, 87.4315 )
RunToLocation( panda02, 3, 2166.38, 1522.54, 494.402, 78.4314 )
panda02: Despawn()"	0	0
76	"Kun Lai Summit - Alliance Hub Swap Scene - Worker 03 - JSB"	"
-- tower fire panda
-- wait a little before running in
Wait(3)
FadeIn( panda03, 1 )

-- run to the tents
RunToLocation( panda03, 5.5, 2119.68, 1473.66, 487.886, 98.231 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda03, fire03.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire03, smokeFadeOutTime )
PutOutFire( fire05, smokeFadeOutTime )
PutOutFire( fire06, smokeFadeOutTime )
PutOutFire( fire04, smokeFadeOutTime )
PutOutFire( fire11, smokeFadeOutTime )
PutOutFire( fire07, smokeFadeOutTime )

Wait(1)

RunToLocation( panda03, 3, 2148.77, 1477.56, 487.887, 339.207 )

PlayLoopingSplitBodyAnim( panda03, Animations.EmoteWork )

-- Wait(2)

FadeOut( fire03.smoke )
FadeOut( fire05.smoke )
FadeOut( fire06.smoke )
FadeOut( fire04.smoke )
FadeOut( fire11.smoke )
FadeOut( fire07.smoke )

FadeIn( workDust03, 5 )

-- nazgrim trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

StopLoopingSplitBodyAnim( panda03 )

Wait(10)

panda03: Despawn()"	0	0
77	"Kun Lai Summit - Alliance Hub Swap Scene - Worker 04 - JSB"	"
-- banner panda
-- wait a little before running in
Wait(10)
FadeIn( panda04, 1 )

-- run to north post
RunToLocation( panda04, 5.5, 2099.62, 1447.23, 487.911, 69.189 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda04, fire13.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire13, smokeFadeOutTime )
PutOutFire( fire15, smokeFadeOutTime )

Wait(1)

RunToLocation( panda04, 5, 2098.87, 1447.92, 487.936, 123.639 )

PlayLoopingSplitBodyAnim( panda04, Animations.EmoteWork )

Wait(2)

FadeOut( fire13.smoke )
FadeOut( fire15.smoke )"	0	0
78	"Kun Lai Summit - Alliance Hub Swap Scene - Worker 05 - JSB"	"
-- large tent panda
-- wait a little before running in
Wait(3)
FadeIn( panda05, 1 )

-- run to the tents
-- RunToLocation( panda05, 5.5, 2134.59, 1451.11, 487.886, 34.7651 )
RunToLocation( panda05, 5.5, 2152.82, 1462.71, 487.886, 30.484 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda05, fire01.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(3.5)
PutOutFire( fire01, smokeFadeOutTime )
PutOutFire( fire02, smokeFadeOutTime )
PutOutFire( fire12, smokeFadeOutTime )
PutOutFire( fire23, smokeFadeOutTime )

Wait(1)

RunToLocation( panda05, 3,  2159.28, 1460.91, 487.886, 5.73899 )

PlayLoopingSplitBodyAnim( panda05, Animations.EmoteWork )

Wait(2)

FadeOut( fire01.smoke )
FadeOut( fire02.smoke )
FadeOut( fire12.smoke )
FadeOut( fire23.smoke )

-- Wait(1)

FadeIn( workDust06, 5 )

WaitForTrigger( \"flagPlant\" )

Wait(1.5)

StopLoopingSplitBodyAnim( panda05 )

RunToLocation( panda05, 3, 2135.24, 1461.33, 487.886, 178.989 )
panda05: Despawn()"	0	0
80	"Kun Lai Summit - Alliance Hub Swap Scene - Taylor 01 - JSB"	"

-- wait before running in
Wait(20)

FadeIn( taylor01, 5 )

-- run to tent
RunToLocation( taylor01, 5,  2141.59, 1470.78, 487.886, 44 )

Wait(1)

-- plant banner - NEED EMOTE HERE
-- CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )


-- tent swap
PlayOneShotSplitBodyAnim( taylor01, Animations.Attack1H )
Wait(0.5)
FadeIn( banner01, 0 )

FadeIn( tent05, 0 )
FadeIn( tent06, 0 )
FadeIn( tent07, 0 )
FadeIn( tent08, 0 )
FadeOut( tent01, 0 )
FadeOut( tent02, 0 )
FadeOut( tent03, 0 )
FadeOut( tent04, 0 )

Wait(1)

FadeOut( workDust01, 2 )
FadeOut( workDust02, 2 )
FadeOut( workDust03, 2 )
FadeOut( workDust04, 2 )
FadeOut( workDust05, 2 )
FadeOut( workDust06, 2 )

SendTrigger( \"flagPlant\" )

-- walk to tent
RunToLocation( taylor01, 3, 2149.99, 1464.34, 487.886, 2.649 )
RunToLocation( taylor01, 3, 2168.91, 1474.57, 487.886, 193 )
"	0	0
81	"Kun Lai Summit - Alliance Hub Swap Scene - Mishka 01 - JSB"	"
-- wait before running in
Wait(22)

FadeIn( mishka01, 0 )

-- run into scene
RunToLocation( mishka01, 5, 2117.27, 1453.24, 487.886, 41.1248 )
RunToLocation( mishka01, 3, 2124.83, 1468.99, 487.886, 14.7998 )

-- taylor trigger
WaitForTrigger( \"flagPlant\" )

Wait(1)

PlayOneShotSplitBodyAnim( mishka01, Animations.EmoteCheer )

Wait(2.5)

PlayOneShotSplitBodyAnim( mishka01, Animations.EmoteApplaud )

Wait(10)
mishka01: Despawn()"	0	0
82	"Kun Lai Summit - Alliance Hub Swap Scene - Sully 01 - JSB"	"
-- wait before running in
Wait(24)

FadeIn( sully01, 0 )

-- run into scene
RunToLocation( sully01, 5, 2117.5, 1443.63, 487.887, 30.1199 )
RunToLocation( sully01, 3, 2136.57, 1454.03, 487.886, 13.4693 )

-- taylor trigger
WaitForTrigger( \"flagPlant\" )

Wait(2)

PlayOneShotSplitBodyAnim( sully01, Animations.EmoteCheer )

Wait(2.5)

PlayOneShotSplitBodyAnim( sully01, Animations.EmoteApplaud )

Wait(10)
mishka01: Despawn()"	0	0
85	"zzOld - PetBattle - Constants"	"--------------------------------------------------------------------------------
-- event types
PetBattleEvent = 
{
	RoundEffect = 0;
	RoundComplete = 1;
	BattleOver = 2;
	ObserverChange = 3;
}

--------------------------------------------------------------------------------
-- effect types
PetBattleEffect = 
{
	Invalid = -1;
	Ability = 0;
	AuraApply = 1;
	AuraCancel = 2;
	AuraChange = 3;
	PetSwap = 4;
	StatusChange = 5;
	SetState = 6;
}

--------------------------------------------------------------------------------
-- battle states
PetBattleState = 
{
	Invalid = -1;
	Created = 0;
	WaitingPreBattle = 1;
	RoundInProgress = 2;
	WaitingForRoundPlayback = 3;
	WaitingForFrontPets = 4;
	CreatedFailed = 5;
	FinalRound = 6;
	Finished = 7;
}

--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
idleRadius     = 1.5
rangedRadius   = 0.75
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.5

--------------------------------------------------------------------------------
-- pad: temp
--padModel = \"world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"
padModel = \"world\\goober\\g_runegroundpurple01.m2\"
padAlpha = 0.0
padScale = 0.4

--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand = 2267;
	Death = 2268;
	Dead  = 2269;
}
"	0	0
86	"zzOld - PetBattle - Effect Shared"	"
--------------------------------------------------------------------------------
-- Helper Functions for processing effects

local currentEffectInstanceID = nil

function ProcessEffect(event)
	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType
	local effectType = event.effectType
	if (event.type) then
		-- backwardsCompatibility for Build <= 15418
		if (event.type == PetBattleEffect.Invalid) then
			return false
		end

		eventType = PetBattleEvent.RoundEffect
		effectType = event.type
	end

	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.RoundEffect) then

		-- battle round effects
		if (effectType == PetBattleEffect.Ability) then
			EffectAbility(event)
		elseif (effectType == PetBattleEffect.AuraApply) then
			EffectAuraApply(event)
		elseif (effectType == PetBattleEffect.AuraCancel) then
			EffectAuraRemove(event)
		elseif (effectType == PetBattleEffect.PetSwap) then
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		elseif (effectType == PetBattleEffect.StatusChange) then
			-- HACK - for backwards compatibility
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		end

	end

	if currentEffectInstanceID then
		-- Noone manually signaled the effect applied, do it now
		battleScene:SignalEffectApplied(currentEffectInstanceID)
	end

	if (battleScene and battleScene:HasPendingEffects() == false) then
		ResetActivePets()
	end

	return true
end

--------------------------------------------------------------------------------
function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end
"	0	0
87	"zzOld - PetBattle - Effect Aura Remove"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraRemove(effect)

	local casterPlayerID = effect.casterPlayerID
	local casterPetSlot = effect.casterPetSlot

	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterPet = casterPlayer.pets[casterPetSlot]

	if not casterPet then
		return
	end

	RemoveAura(casterPet, effect.auraInstanceID)

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil

end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end
"	0	0
92	"Kun Lai Summit - Reclaiming the Thunder God - Init - Generic Actors 01 - JSB"	"
-- Spawn Clone
playerCloneCreatureID = 61079
playerClone01 = SpawnActor( playerCloneCreatureID, 3630.21, 1780.71, 742.973, 221.07 ) -- player clone
FadeOut( playerClone01, 0 )

-- Spawn Mogu Door
moguDoorCreatureID = 61129
moguDoor01 = SpawnActor( moguDoorCreatureID, 3674.03, 1657.67, 742.974, 353 ) -- mogu door

-- Spawn Priest
trollPriestCreatureID = 61075
trollPriest01 = SpawnActor( trollPriestCreatureID, 3605.16, 1622.07, 742.666, 85.6491 ) -- troll priest
FadeOut( trollPriest01, 0 )

-- Spawn PriestGrunt 01
-- trollGruntACreatureID = 61148
-- trollPriestGrunt01 = SpawnActor( trollGruntACreatureID, 3606.02, 1600, 742.973, 81.5797 ) -- troll priest grunt a
-- FadeOut( trollPriestGrunt01, 0 )

-- Spawn PriestGrunt 02
-- trollGruntBCreatureID = 61149
-- trollPriestGrunt02 = SpawnActor( trollGruntBCreatureID, 3599.39, 1600, 742.973, 81.5797 ) -- troll priest grunt b
-- FadeOut( trollPriestGrunt02, 0 )

-- Spawn Grunts

-- Spawn Grunt 01
trollGruntCreatureID = 61074

trollGrunt01 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt02 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt03 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt04 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt05 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt06 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt07 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt08 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt09 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )

"	0	0
93	"Kun Lai Summit - Reclaiming the Thunder God - Init - Generic Actors 02 - JSB"	"
-- Spawn Fire Wall
-- fireWallModel = \"WORLD\\EXPANSION03\\DOODADS\\GRIMBATOLRAID\\GrimBatolRaid_Fire_Wall_01.M2\"
-- fireWall01 = SpawnModelActor( fireWallModel, 3617.5, 1754.9, 742.973, 45, 0.4 )

-- FadeOut( fireWall01, 0 )

-- Spawn Mogu Remains
moguRemainsModel = \"WORLD\\EXPANSION04\\DOODADS\\MOGU\\Mogu_Statue_02Broken_Piece01.M2\"
moguRemains01 = SpawnModelActor( moguRemainsModel, 3759, 1655.91, 748.963, 180, 3 )

-- Spawn Mogu Statues
-- moguStatueModel = \"WORLD\\EXPANSION04\\DOODADS\\MOGU\\Mogu_Statue_Double.M2\"
-- moguStatue01 = SpawnModelActor( moguStatueModel, 3739.53, 1657.26, 742.974, 180, 3 )

-- Spawn Mogu Effects
moguPulseModel = \"SPELLS\\BloodBolt_Chest.M2\"
moguPulse01 = SpawnModelActor( moguPulseModel, 3759, 1655.91, 750, 180, 2, false )

Wait (50)"	0	0
95	"Kun Lai Summit - Reclaiming the Thunder God - Master Script - JSB"	"
scene:WaitTimer(1)

scene:SetCamera(345,4,nil,nil) -- (camera, transition time, primary target, secondary target)


scene:WaitTimer(2)

scene:SetCamera(346,3,nil,nil)

scene:WaitTimer(2)

scene:SetCamera(347,2.2,nil,nil) -- down the hall

scene:WaitTimer(1.2)

scene:SetCamera(337,4,nil,nil) -- turn
scene:WaitTimer(1.5) -- wait for doors to open

scene:SetCamera(338,15,nil,nil)

scene:WaitTimer(5.5) 
scene:SetCamera(339,5,nil,nil)

scene:WaitTimer(2) 

scene:SetCamera(340,6,nil,nil) -- look at thunder king

scene:WaitTimer(5)

scene:SetCamera(338,2.5,nil,nil) -- backing up

scene:WaitTimer(1)

SendTrigger( \"cloneTrigger\" )

scene:SetCamera(337,2.5,nil,nil) -- backing up

scene:WaitTimer(1)

SendTrigger( \"priestTrigger\" )

scene:SetCamera(347,4,nil,nil)

scene:WaitTimer(2)

scene:SetCamera(344,3.5,nil,nil) -- zoom


-- scene:SetCamera(341,0,nil,nil)

-- scene:SetCamera(342,10,nil,nil)

-- scene:WaitTimer(10)

-- scene:SetCamera(343,2,nil,nil) -- ready to zoom

-- scene:WaitTimer(1.5)

-- scene:SetCamera(344,3,nil,nil) -- zoom

scene:WaitTimer(9.5)

scene:SetCamera(346,3,nil,nil)

scene:WaitTimer(2)

scene:SetCamera(345,4,nil,nil)

scene:WaitTimer(3)

scene:SetCamera(0,3,nil,nil) -- sets camera back to game-cam
"	0	0
116	"Kun Lai Summit - Reclaiming the Thunder God - Mogu Door 01 - JSB"	"-- close door
moguDoor01:PlayLoopingFullBodyAnim(Animations.Closed) 

Wait(8)
moguDoor01:StopLoopingFullBodyAnim()
moguDoor01:PlayLoopingAnimKit(2209)"	0	0
117	"Kun Lai Summit - Reclaiming the Thunder God - Troll Priest 01 - JSB"	"-- clone trigger
WaitForTrigger( \"cloneTrigger\" )
FadeIn ( trollPriest01, 0 )

Wait(2)

RunToLocation( trollPriest01, 5, 3606.92, 1640.85, 742.683, 84.3163 )

PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteLaugh )

-- SendTrigger( \"priestTrigger\" )

Wait(2.5)

PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteTalk )

Wait(2.5)

PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteTalkExclamation )

-- trollPriest01:PlaySpellStateVisual( 24391 )

Wait(2.5)

RunToLocation( trollPriest01, 5, 3606.92, 1640.85, 742.683, 264 )

RunToLocation( trollPriest01, 5, 3605.16, 1622.07, 742.666, 264 )

RunToLocation( trollPriest01, 5, 3602.81, 1598.81, 743.012, 264.299 )

RunToLocation( trollPriest01, 5, 3600.05, 1571.08, 757.963, 264.075 )

RunToLocation( trollPriest01, 5, 3615.26, 1557.32, 759.908, 21.2992 )

-- SendTrigger( \"priestTrigger\" )


Wait(100)"	0	0
120	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 01 - JSB"	"-- path 01
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

trollGrunt01:FollowPath( 3049, 12 )

Wait(100)"	0	0
121	"Kun Lai Summit - Resurrecting the Thunder God - Master Script - JSB"	"
scene:WaitTimer(1)

scene:SetCamera(359,3,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(348,5,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(349,5,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(350,5,nil,nil) -- aiming at island
scene:WaitTimer(1.5)

scene:SetCamera(351,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(352,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(353,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(354,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(358,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(355,6,nil,nil)
scene:WaitTimer(2.5)

scene:SetCamera(356,16,nil,nil)
scene:WaitTimer(14)

scene:SetCamera(357,26,nil,nil)
scene:WaitTimer(23)

scene:SetCamera(0,0,nil,nil)
"	0	0
122	"Kun Lai Summit - Resurrecting the Thunder God - Init - Generic Actors 01 - JSB"	"
-- Spawn Priest
trollUnderlingCreatureID = 61309
trollGuard01CreatureID = 61292
trollGuard02CreatureID = 61300
trollGuard03CreatureID = 61301
moguGuardCreatureID = 61304
trollPriestCreatureID = 61310

-- Spawn Underlings
trollUnderling01 = SpawnActor( trollUnderlingCreatureID, 4931.42, 66.8542, 6.84169, 25 ) -- first drum
trollUnderling02 = SpawnActor( trollUnderlingCreatureID, 4928.74, 22.5174, 1.05685, 317.344 )
trollUnderling03 = SpawnActor( trollUnderlingCreatureID, 5103.04, 25.6123, 6.4546, 287.645 )
trollUnderling04 = SpawnActor( trollUnderlingCreatureID, 5102.15, 18.2928, 5.92104, 54.319 )
trollUnderling05 = SpawnActor( trollUnderlingCreatureID, 5171.84, 15.3511, 12.9757, 104.494 )
trollUnderling06 = SpawnActor( trollUnderlingCreatureID, 5242.5, 44.022, 31.9608, 279.659 ) -- scene drum right
trollUnderling07 = SpawnActor( trollUnderlingCreatureID, 5250.12, 70.2691, 31.9608, 60.0603 ) -- scene drum left
trollUnderling08 = SpawnActor( trollUnderlingCreatureID, 4840.43, 39.5383, 2.19625, 292.79 ) -- kneeling
trollUnderling09 = SpawnActor( trollUnderlingCreatureID, 4832.77, 33.9119, 1.61703, 227.54 ) -- reading
trollUnderling10 = SpawnActor( trollUnderlingCreatureID, 4814.25, 65.1461, 3.15087, 56.99 ) -- working
trollUnderling11 = SpawnActor( trollUnderlingCreatureID, 5251.9, 66.0285, 31.9608, 24.2841 ) -- scene drum middle

-- Spawn Mogu
moguGuard01 = SpawnActor( moguGuardCreatureID, 5153.18, 87.0011, 13.2936, 152.085 ) -- base of stairs 01
moguGuard02 = SpawnActor( moguGuardCreatureID, 5167.13, 104.879, 15.1742, 144.21 ) -- base of stairs 02
moguGuard03 = SpawnActor( moguGuardCreatureID, 4883.96, 46.1186, 6.17683, 168.735 )
moguGuard04 = SpawnActor( moguGuardCreatureID, 4856.31, 63.453, 5.6103, 216.21 )

-- Spawn Troll Guards
trollGuard01 = SpawnActor( trollGuard01CreatureID, 4949.93, 50.9107, 1.9036, 187.411 ) -- first patroller




-- Spawn Grunt 01
-- trollGruntCreatureID = 61074

-- trollGrunt01 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt02 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt03 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt04 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt05 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt06 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt07 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt08 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt09 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )

"	0	0
123	"Kun Lai Summit - Resurrecting the Thunder God - Troll Patroller 01"	"
Wait(3)

RunToLocation( trollGuard01, 4, 4905.35, 48.013, 3.56636, 151.861 )
RunToLocation( trollGuard01, 4, 4885.88, 56.5586, 4.25848, 156.811 )"	0	0
124	"Kun Lai Summit - Resurrecting the Thunder God - Trolls at Dock"	"
PlayLoopingSplitBodyAnim( trollUnderling08, Animations.KneelLoop )
PlayLoopingSplitBodyAnim( trollUnderling09, Animations.EmoteReadLoop )
PlayLoopingSplitBodyAnim( trollUnderling10, Animations.EmoteWork )

-- trollUnderling08 =  -- kneeling
-- trollUnderling09 =  -- reading
-- trollUnderling10 = -- working"	0	0
125	"Kun Lai Summit - Resurrecting the Thunder God - Troll Drummers"	"
PlayLoopingSplitBodyAnim( trollUnderling01, Animations.Attack1H )
PlayLoopingSplitBodyAnim( trollUnderling06, Animations.Attack1H )
PlayLoopingSplitBodyAnim( trollUnderling07, Animations.Attack1H )

scene:WaitTimer(0.5)

PlayLoopingSplitBodyAnim( trollUnderling11, Animations.Attack1H )"	0	0
126	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 02 - JSB"	"-- path 02
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(1)

trollGrunt02:FollowPath( 3050, 12 )


Wait(100)"	0	0
127	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 03 - JSB"	"-- path 03
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(0.6)

trollGrunt03:FollowPath( 3051, 12 )


Wait(100)"	0	0
128	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 04 - JSB"	"-- path 04
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(0.3)

trollGrunt04:FollowPath( 3052, 12 )


Wait(100)"	0	0
129	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 09 - JSB"	"-- path 09
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

-- Wait(1)

trollGrunt09:FollowPath( 3062, 12 )


Wait(100)"	0	0
130	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 08 - JSB"	"-- path 08
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(1)

trollGrunt08:FollowPath( 3061, 12 )


Wait(100)"	0	0
131	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 07 - JSB"	"-- path 07
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(0.6)

trollGrunt07:FollowPath( 3060, 12 )


Wait(100)"	0	0
132	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 06 - JSB"	"-- path 06
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

Wait(0.3)

trollGrunt06:FollowPath( 3059, 12 )


Wait(100)"	0	0
133	"Kun Lai Summit - Reclaiming the Thunder God - Grunt 05 - JSB"	"-- path 05
-- priest trigger
WaitForTrigger( \"priestTrigger\" )

-- Wait(0.3)

trollGrunt05:FollowPath( 3058, 12 )


Wait(100)"	0	0
134	"Test - Alex\'s Battle Pet - Init Library"	"--- Pad Setup
-- pad: temp
--padModel = \"world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"
padModel = \"world\\goober\\g_runegroundpurple01.m2\"
padAlpha = 0.333
padScale = 0.4

function DoPadInit(transform)
	-- spawn a pad for this team
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, transform, padScale*battleScale)
	pad = scene:SpawnActor(padCreateData)
	pad:Fade(padAlpha, 0.5)
	pad:SetInteractible(false);

	return pad;
end"	0	0
135	"Test - Alex\'s Battle Pet - Camera Mode Library"	"-- Manual Target

local camModel = \"world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\";
local camModel2 = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker_noAnims.mdx\" -- \"Spells\\FIREBALL_MISSILE_HIGH.MDX\"; --

	local a = ActorCreateData:NewModel( \"target\", camModel2, Transform:New(Vector:New(0,0,0),0), battleScale);
	a.groundSnap = false;
	local b = ActorCreateData:NewModel( \"camera\", camModel2, Transform:New(Vector:New(0, -15, 5),0), battleScale);
	b.groundSnap = false;

mainCameraTarget = scene:SpawnActor( a );
mainCamera = scene:SpawnActor( b );


--scene:SetCamera(307, 1.0, nil, nil)
function SetCamera( camera )
	camera = 3;

	if ( camera == 0 ) then
		scene:SetCamera(360, 0.0, pad1, pad2)
		scene:SetCamera(362, 3.0, mainCamera, mainCameraTarget)

	elseif ( camera == 1 ) then 
		-- Intro
		scene:SetCamera(360, 0.0, pad1, pad2)
	elseif ( camera == 2 ) then 
		-- Idle
		scene:SetCamera(361, 3.0, pad1, pad2)
	elseif ( camera == 3 ) then 
		-- Spinny

		scene:SetCamera(362, 3.0, mainCamera, mainCameraTarget)
	elseif ( camera == 4 ) then
		--scene:SetCamera(335, 3.0, mainCamera, mainCameraTarget)
		--scene:SetCamera(362, 3.0, mainCameraTarget, mainCamera)
	end
end 

function SpinCamera ()
	-- Silly loop
	local arrayOfPoints = {};
	local radius = 15;
	local max = 36
	for i=1,max do 
		local v = Vector:New(  math.cos(math.pi*2*i/max)*radius, math.sin(math.pi*2*i/max)*radius, 5 );

		table.insert(arrayOfPoints,v);
	end

	local point = 1;
	local forward = true;
	local current = 1;

	while true do 
		if ( forward ) then
			direction = 1
		else
			direction = -1
		end
		current = current + direction;
		if ( current> #arrayOfPoints ) then
			current = 1
		elseif ( current <= 0 ) then
			current = #arrayOfPoints
		end

		mainCamera:MoveSplineAbs(arrayOfPoints, 100)
		mainCamera:WaitMovementComplete()
	end

end"	0	0
136	"Test - Alex\'s Battle Pet - Setup Team Actors"	"function SetupTeamActors()

	local radius = 2
	local facing = 0

	home1 = Vector:New( radius*battleScale, 0, 0)
	home2 = Vector:New(-radius*battleScale, 0, 0)

	homeTransform1 = Transform:New(home1, 180)
	homeTransform2 = Transform:New(home2, 0)


	-- Camera Targets
	pad1 = DoPadInit(homeTransform1);
	pad2 = DoPadInit(homeTransform2);


	master1Loc = Vector:New( 6, -6, 3);
	master1Transform = Transform:New(master1Loc, 180);
	
	master1 = scene:SpawnActor(ActorCreateData:New(55242, master1Transform, battleScale) );
	master1:SetFacingToAbs(Vector:New());

	master1petloc = home1;

	local master1frontVector = UnitVectorFromAtoB(master1Loc, Vector:New());
	local master1upVector = UnitVectorFromAtoB(master1Loc, VectorSum(master1Loc, Vector:New(0,0,1) ) );
	local master1leftVector = UnitVectorCrossProduct(master1frontVector, master1upVector);

	master1backpet1loc = master1Loc  + master1leftVector *  2  + master1frontVector*-1;
	master1backpet2loc = master1Loc  + master1leftVector * -2  + master1frontVector*-1;

	-- Pet Loc
	master1pet = scene:SpawnActor(ActorCreateData:New(40295, homeTransform1, battleScale))

	-- Armadillo
	master1backupPet1 = scene:SpawnActor(ActorCreateData:New(48242, Transform:New(master1backpet1loc,0), battleScale));
	master1backupPet1:SetFacingToTarget(master1pet, Vector:New())
	-- Parrot
	master1backupPet2 = scene:SpawnActor(ActorCreateData:New(11236, Transform:New(master1backpet2loc,0), battleScale));
	master1backupPet2:SetFacingToTarget(master1pet, Vector:New())

	-- Set the home point
	current1 = VectorCopy(master1pet:GetPosition());

	master2Loc = Vector:New( -6, 6, 3);
	master2Transform = Transform:New(master2Loc, 0);

	master2 = scene:SpawnActor(ActorCreateData:New(53828, master2Transform, battleScale/3) );
	master2:SetFacingToAbs(Vector:New());

	master2petloc = home2;


	local master2frontVector = UnitVectorFromAtoB(master1Loc, Vector:New());
	local master2upVector = UnitVectorFromAtoB(master1Loc, VectorSum(master1Loc, Vector:New(0,0,1) ) );
	local master2leftVector = UnitVectorCrossProduct(master1frontVector, master1upVector);

	master2backpet1loc = master2Loc  + master1leftVector *  2  + master2frontVector*-1;
	master2backpet2loc = master2Loc  + master1leftVector * -2  + master2frontVector*-1;


	-- Pet Loc
	master2pet = scene:SpawnActor(ActorCreateData:New(45340, homeTransform2, battleScale))

	-- Frog
	master2backupPet1 = scene:SpawnActor(ActorCreateData:New(14878, Transform:New(master2backpet1loc,0), battleScale));
	master2backupPet1:SetFacingToTarget(master2pet, Vector:New())

	-- Croc
	master2backupPet2 = scene:SpawnActor(ActorCreateData:New(24388, Transform:New(master2backpet2loc,0), battleScale));
	master2backupPet2:SetFacingToTarget(master2pet, Vector:New())

	-- Set the home point
	current2 = VectorCopy(master2pet:GetPosition());

end"	0	0
138	"Test - Alex\'s Battle Pet - Move Library 4"	"-- Earthen explosion
function PerformRuptureLine (pet, opponent, damage ) 

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition() , opponentLocation );
	local upVector = UnitVectorFromAtoB(pet.actor:GetPosition(), (pet.actor:GetPosition() + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

print(\"rupture line\");
	local distance = (pet.actor:GetPosition()+frontVector*-1):Dist(opponentLocation+frontVector*-3)+4;

	local objects = {};
	local total = 15;

	for i = 1, total do 
		
		local f = distance/total*i;
		local l = math.sin(math.rad(i*(600/total)))*3;

		l = l * (0.1 + 0.9 * i/total)

		local v = frontVector*f+leftVector*l;
		v = pet.actor:GetPosition() + v;
		local t = Transform:New(v,math.random(-180,180));

		local create = ActorCreateData:NewModel(
			\"Dirt\",
			\"SPELLS\\burrowearth_brown_missile_v2.m2\",
			t,
			0.2);
		local newActor = scene:SpawnActor(create);
		newActor:SetInteractible(false);

		table.insert(objects, newActor);

		local v = frontVector*f+leftVector*-l;
		v = pet.actor:GetPosition() + v;
		local t = Transform:New(v,math.random(-180,180));

		local create = ActorCreateData:NewModel(
			\"Dirt\",
			\"SPELLS\\burrowearth_brown_missile_v2.m2\",
			t,
			0.2);
		local newActor = scene:SpawnActor(create);
		newActor:SetInteractible(false);

		table.insert(objects, newActor);
		scene:WaitTimer(0.05)
	end

	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)

	scene:WaitTimer(0.5)

	for i = 1, total do 
		
		local f = distance/total*i;
		local l = math.sin(math.rad(i*(600/total)))*3;

		l = l * (0.1 + 0.9 * i/total)

		local v = frontVector*f+leftVector*l;
		v = pet.actor:GetPosition() + v;
		local t = Transform:New(v,math.random(-180,180));

		local create = ActorCreateData:NewModel(
			\"Dirt\",
			\"SPELLS\\GROUNDSPIKE_IMPACT.m2\",
			t,
			0.2);
		local newActor = scene:SpawnActor(create);
		newActor:PlayLoopingAnimKit(2133)
		newActor:SetInteractible(false);
		table.insert(objects, newActor);

		local v = frontVector*f+leftVector*-l;
		v = pet.actor:GetPosition() + v;
		local t = Transform:New(v,math.random(-180,180));

		local create = ActorCreateData:NewModel(
			\"Dirt\",
			\"SPELLS\\GROUNDSPIKE_IMPACT.m2\",
			t,
			0.2);
		local newActor = scene:SpawnActor(create);
		newActor:PlayLoopingAnimKit(2133)
		newActor:SetInteractible(false);
		table.insert(objects, newActor);

		scene:WaitTimer(0.05)

		if ( i == 12 ) then 
			opponent.actor:AddDamageText(nil, 10, false, false)
			PerformVerticalKnockback(opponent, pet, damage);
		end
	end




	scene:WaitTimer(1)

	for k,v in pairs(objects) do 
		v:StopAnimKit(2133)
	end
	scene:WaitTimer(0.4)
	for k,v in pairs(objects) do 
		v:Fade(0,0);
		v:Despawn();
	end
end"	0	0
139	"Test - Alex\'s Battle Pet - Move Library 5"	"function BuildKnockbackSpline(pet, petFinalPoint, duration)
	local gravity = -9.8; -- M / sec / sec
	local points = 10;  

	local dx = petFinalPoint.x - pet.actor:GetPosition().x;
	local dy = petFinalPoint.y - pet.actor:GetPosition().y;
	local xVelocity = dx / duration;  -- M / sec
	local yVelocity = dy / duration;  -- M / sec

	local zVelocity = ( gravity * duration * duration ) * -2;

	local list = {};
	local timeStep = duration / points

	for i=0, points do 
		local time = timeStep * i; 
		local x = time * xVelocity;
		local y = time * yVelocity;
		local u = gravity*time*time + zVelocity*time;
--print(\"t: \",time,\" x: \",x,\"u: \",u);
		table.insert(list, 
			pet.actor:GetPosition()+ Vector:New(x,y,u) 
			);
		
	end
	table.insert(list, petFinalPoint);
	table.remove(list, 1);

	return list;
end"	0	0
140	""	""	0	0
142	"Test - Alex\'s Battle Pet - ProcessEffect"	"function ProcessEffect(effect)
	if ( not effect ) then 
		return;
	end

	if ( effect.type == PetBattleEffect.PetSwap	) then

		print(\"Process SWAP\");
		ProcessSwap(effect);

	elseif ( effect.type == PetBattleEffect.Ability ) then 

		print(\"Process Ability\");
		ProcessAbility(effect);
	else
		print ( \"Effect: \"..effect.instanceID );
		for k,v in pairs(effect) do 
			print(\"k: \", k, \" v: \", v );
		end
	end


	if ( effect.type == PetBattleEffect.FinalRound ) then 
		return;
	end 

	battleScene:SignalEffectApplied(effect.instanceID)
end

function ProcessSwap(effect)
	local team = effect.casterPlayerID;
	local newPetIndex = effect.newFrontPet;

	local pet = allPlayers[team].pets[allPlayers[team].activePet];
	local newPet = allPlayers[team].pets[newPetIndex];

	local nextTeam = math.fmod(team,2)+1;
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]

	-- Swap active pet
	allPlayers[team].activePet = newPetIndex

	-- Perform the emote
	allPlayers[team].master:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
	scene:WaitTimer(1.0)

	-- Swap the action
	PerformSwap(pet,newPet, opponent)
end

function ProcessAbility(effect)
	local team = effect.casterPlayerID;
	local pet = allPlayers[team].pets[allPlayers[team].activePet];

	local nextTeam = math.fmod(team,2)+1;
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]

	PerformMove(pet,opponent, effect)
end"	0	0
144	"zzOld - PetBattle - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 3.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.5, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
145	"Test - Alex\'s Battle Pet - Move Library 6"	"
function PerformWaveAttack(pet, opponent, damage)
	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition(), opponentLocation  );
	local upVector = UnitVectorFromAtoB(pet.actor:GetPosition(), (pet.actor:GetPosition() + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

print(\"wave\");
	local newActor = scene:SpawnActor(
	ActorCreateData:NewModel(
		\"Wave\",
		\"SPELLS\\MISSILE_WAVE_WATER.m2\",
		Transform:New( pet.actor:GetPosition()+frontVector*-5, 0),
		0.5
	) );
	newActor:PlayLoopingAnimKit(2133)
	newActor:SetInteractible(false);
	local target = opponent.actor:GetPosition() + frontVector*6;
	newActor:SetFacingToAbs(target);
	scene:WaitTimer(1.0)


	newActor:MoveToAbs(target, 3);
	lastD = newActor:GetPosition():Dist(opponent.actor:GetPosition());
	local test = function() 
		local d = newActor:GetPosition():Dist(opponent.actor:GetPosition());
print(d)
		if( d < 1 or d > lastD ) then
			return true;
		else
			lastD = d;
			return false;
		end

	end

	scene:WaitCondition(test, nil, 6);
	PerformHardKnockback(opponent,pet, damage);

	newActor:WaitMovementComplete();
	newActor:Fade(0,1);
	scene:WaitTimer(1.0)
	newActor:Despawn();
end

"	0	0
146	"zzOld - PetBattle - Effect Cast"	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityTurnID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, idleRadius)
	end

	local abilityTurn = petAbilityTurns[abilityTurnID]
	if not abilityTurn then
		-- ERROR:
		print(\"ERROR: unknown abilityTurnID \" .. abilityTurnID)
		return
	end

	local attackRadius = meleeRadius
	if not abilityTurn.isMelee then
		attackRadius = rangedRadius
	end
	
	-- move front pet to the correct radius, if it was the caster
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then
		WaitMoveToRadius(casterFrontPet, attackRadius)
	end

	--
	-- Actually cast
	--	
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]
	local spellVisualID = abilityTurn.spellVisualID

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityTurn.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (casterCastingPet.actor ~= targetPet.actor) then
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(
				spellVisualID,
				abilityTurn.impactTime,
				true,
				{targetPet.actor})
		else
			-- self targeted
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
		end
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityTurn.impactTime)
	end

	return casterCastingPet, spellVisualID
end
"	0	0
147	"zzOld - PetBattle - Intro"	"
--------------------------------------------------------------------------------
function BattleIntro()

	SetCamera(1)
	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	scene:WaitTimer(0.25)
	SetCamera(2)
	scene:WaitTimer(0.75)
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
149	"Jade Forest - Fresco Scene - Master Script - JSB"	"
-- scene:WaitTimer(2)

scene:SetCamera(363,7,nil,nil) -- (camera, transition time, primary target, secondary target)


scene:WaitTimer(10) 


scene:SetCamera(364,7,nil,nil) 

scene:WaitTimer(5) 

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0
150	"Jade Forest - Horde Intro Scene - Master - JSB"	"
local sceneOrigin = scene:GetPosition()
scene:SetCamera(0, 0.0, nil, nil)

Wait(1.0)

-- initial pan
-- scene:SetCamera(365, 0.0, nil, nil)

--CameraPosFollowPath( 370, 3095, 10 )
--CameraTgtFollowPath( 370, 3096, 10 )
SetCameraFollowPath( 370, 0.0, 3095, 3096, 15 )

local shakeY
local shakeZ
if Scene.AddCameraShake then
	shakeY = scene:AddCameraShake(203, sceneOrigin)
	shakeZ = scene:AddCameraShake(204, sceneOrigin)
end


--scene:SetCamera(366, 15.0, nil, nil)
Wait(8)
SendTrigger( \"gorrokMove\" )
Wait(3)
-- cut to Nazgrim

-- scene:SetCamera(367, 10, nil, nil)

scene:SetCamera(367, 15, nil, nil)

Wait(9)
scene:SetCamera(374, 0, nil, nil) -- rivett intial shot
WaitForTrigger( \"rivettTalk\" )
scene:SetCamera(375, 0.25, nil, nil) -- rivett close shot


if Scene.ClearCameraShake and shakeY and shakeZ then
	scene:ClearCameraShake(shakeY)
	scene:ClearCameraShake(shakeZ)
end

-- Cliff cam
Wait(6)

SetCameraFollowPath( 372, 0, nil, 3097, 20 )


Wait(10)
SendTrigger( \"allianceShip\" )

Wait(7)
-- look down at alliance ship
scene:SetCamera(373, 1, nil, nil)
SendTrigger( \"shipSpotted\" )
Wait(3)

scene:SetCamera(386, 1, nil, nil)

scene:SetCamera(382, 20, nil, nil) -- panning nazgrim
Wait(5.5)

scene:SetCamera(380, 0, nil, nil) -- ship to zepp

scene:SetCamera(379, 35, nil, nil)
Wait( 0.1 )
SendTrigger( \"zeppelinMove\" )
Wait(13)

SendTrigger( \"shipMove\" )

-- scene:SetCamera(381, 0, nil, nil)
SetCameraFollowPath( 383, 0.0, 3114, 3113, 14 )

Wait(10)

SetCameraFollowPath( 385, 4.0, 3116, 3117, 16 )

Wait(12)
SendTrigger( \"crashMove\" )
scene:SetCamera(384, 0, nil, nil)

Wait( 10 )
SendTrigger( \"zeppelinCrash\" )"	0	0
151	"Jade Forest - Horde Intro Scene - Zeppelin - JSB"	"
-- PlayLoopingSplitBodyAnim( zeppelin, Animations.ShipMoving )

zeppelin:PlayLoopingAnimKit(2272)


zeppelinDest = Vector:New(3292.78, -337.059, 266.204)
zeppelinMoveSpeed = 6
zeppelinSrc = zeppelin:GetPosition()
zeppelinMoveOffset = zeppelinDest - zeppelinSrc

-- force the ship to face a direction
zeppelin:SetFacingToAbs(Vector:New(3969.94, -99.27, 259.995))

WaitForTrigger( \"zeppelinMove\" )

RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest.x, zeppelinDest.y, zeppelinDest.z)

--[[
--
-- COPY THIS INTO ZEPP PASSENGER SCRIPT
-- COPY STARTS HERE
--
local relativeMover = allianceCaptain -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY THIS INTO ZEPP PASSENGER SCRIPT
-- COPY ENDS HERE
--
]]

WaitForTrigger( \"crashMove\" )

zeppelin:FollowPath( 3118, 10 )

Wait( 10.2 )

FadeOut( zeppelin, 0 )
zeppelinFire:Despawn()
zeppelinFire01:Despawn()
zeppelinFire02:Despawn()
zeppelinFire03:Despawn()
Wait( 2.5 )
zeppelin:Despawn()"	0	0
152	"Jade Forest - Horde Intro Scene - Init - JSB"	"
-- spawn zeppelin
local zeppelinModel = \"world\\expansion03\\doodads\\generic\\flying_horde_zeppelin.m2\"
--zeppelin = SpawnModelActor( zeppelinModel, 3444.23, -278.363, 284.752, 249.2335, 1.0, false )
local zeppelins = SpawnModelActorsAtPoints( zeppelinModel, 3093, false )
zeppelin = zeppelins[1]

local allianceShipModel = \"world\\expansion03\\doodads\\generic\\alliance_ship01.m2\"
allianceShip = SpawnModelActor( allianceShipModel, 3457.83, -923.965, 0, 257.2773, 1.0, false )

-- spawn nazgrim
local nazgrimCreatureID = 61682
nazgrim = SpawnActor( nazgrimCreatureID, 3447.54, -289.77, 266.9, 175.826, 1.0, false )

-- spawn gorrok
local gorrokCreatureID = 61846
gorrok = SpawnActor( gorrokCreatureID, 3434.29, -289.758, 268.19, 203.226, 1.0, false )

-- spawn clone
local cloneCreatureID = 61833
clone = SpawnActor( cloneCreatureID, 3447.19, -285, 266.9, 215.151, 1.0, false )

-- spawn rivett
local rivettCreatureID = 61844
rivett = SpawnActor( rivettCreatureID, 3458.38, -288.321, 268.1, 290.783, 1.0, false )

-- spawn shokia
local shokiaCreatureID = 61866
shokia = SpawnActor( shokiaCreatureID, 3449.31, -278.87, 266.9, 209.976, 1.0, false )

-- spawn kiryn
local kirynCreatureID = 61867
kiryn = SpawnActor( kirynCreatureID, 3459.4, -278.842, 268.458, 202.139, 1.0, false )
kiryn:PlayLoopingFullBodyAnim(Animations.SitChairMed)

-- spawn zin\'jun
local zinjunCreatureID = 61868
zinjun = SpawnActor( zinjunCreatureID, 3461.3, -283.872, 268.4, 199.819, 1.0, false )
zinjun:PlayLoopingFullBodyAnim(Animations.SitChairMed)

-- spawn snuff
local snuffCreatureID = 61869
snuff = SpawnActor( snuffCreatureID, 3459.5, -283.872, 268.1, 108, 0.7, false )
snuff:PlayLoopingFullBodyAnim(Animations.Sleep)

-- spawn Vanguard01
local vanguard01CreatureID = 61845
vanguard01 = SpawnActor( vanguard01CreatureID, 3432.55, -287.139, 268.19, 133.576, 1.0, false )

-- spawn Vanguard02
local vanguard02CreatureID = 61845
vanguard02 = SpawnActor( vanguard02CreatureID, 3435.51, -293.801, 268.19, 273, 1.0, false )

-- spawn Vanguard03
local vanguard03CreatureID = 61845
vanguard03 = SpawnActor( vanguard03CreatureID, 3452.83, -289.126, 266.9, 186, 1.0, false )

-- spawn Vanguard04
-- local vanguard04CreatureID = 61845
-- vanguard04 = SpawnActor( vanguard04CreatureID, 3449.31, -278.87, 266.9, 209.976, 1.0, false )

-- spawn Alliance Captain
local allianceCaptainCreatureID = 62635
allianceCaptain = SpawnActor( allianceCaptainCreatureID, 3438.27, -953.387, 18.8127, 63, 1.0, false )

-- spawn Zeppelin Cannon Bunnies
local zeppelinCannonBunnyCreatureID = 61997
zeppelinCannon01 = SpawnActor( zeppelinCannonBunnyCreatureID, 3454.88, -291.905, 263.772, 307.796, 1.0, false )
zeppelinCannon02 = SpawnActor( zeppelinCannonBunnyCreatureID, 3448.31, -294.369, 263.772, 296.321, 1.0, false )
zeppelinCannon03 = SpawnActor( zeppelinCannonBunnyCreatureID, 3442.37, -295.521, 263.957, 279.446, 1.0, false )
zeppelinCannon04 = SpawnActor( zeppelinCannonBunnyCreatureID, 3437.49, -295.544, 264.3, 280.5711, 1.0, false )


-- spawn fogs
-- in front
local cloudModel = \"world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"
mists = SpawnModelActorsAtPoints( cloudModel, 3094, false )

-- special fog
local mistModel = \"world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"
mist = SpawnModelActor( mistModel, 3450.53, -299.764, 269, 128.282, 4.0, false )
FadeOut( mist, 0 )

"	0	0
153	"Jade Forest - Horde Intro Scene - Nazgrim - JSB"	"
WaitForTrigger( \"nazgrimTalk\" )

nazgrim:PlayOneShotAnimKit(2332)
Wait(2)
nazgrim:PlayOneShotFullBodyAnim(Animations.EmoteTalkNoSheathe)

WaitForTrigger( \"rivettTalk\" )

RunToLocation( nazgrim, 4, 3447.87, -293.173, 266.9, 294 )

WaitForTrigger( \"shipSpotted\" )
Wait( 1 )

nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)
Wait( 2 )

nazgrim:SetFacing(120)
Wait( 1 )

nazgrim:PlayOneShotAnimKit(2329)

Wait( 4 )



-- COPY STARTS HERE
--
local relativeMover = nazgrim -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
nazgrim:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

"	0	0
154	"Cinematic Framework - Spawning"	"
--
-- SpawnModelActor( modelFileName, pointsPathID, snapToGround [=true] )
--   Spawn an uninteractible actor
--
function SpawnModelActorsAtPoints( modelFileName, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.model = modelFileName
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	return actors

end


function SpawnActorAtPoint( creatureID, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.creatureID =  creatureID
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	return actors[1]

end

function SpawnFadedActorAtPoint( creatureID, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.creatureID =  creatureID
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	local actor = actors[1]
	FadeOut(actor, 0)
	return actor

end
"	0	0
155	"Cinematic Framework - Camera"	"
--
-- Internal variables
--
local cameraDummyDefaultPos = scene:GetPosition()
local cameraDummyModel = \"creature\\invisiblestalker\\invisiblestalker.m2\"

local cameraDummyCreateData = ActorCreateData:Default()
cameraDummyCreateData.model = cameraDummyModel
cameraDummyCreateData.transform.position = cameraDummyDefaultPos
cameraDummyCreateData.groundSnap = false
cameraDummyCreateData.interactible = false
cameraDummyCreateData.floatingTooltip = false

local cameraDummyPositions = { }
local cameraDummyTargets = { }

--
-- SetCameraFollowPath
--
function SetCameraFollowPath( cameraModeID, transitionTime, posPathID, tgtPathID, moveTime )
	local posDummy = CameraPosFollowPath( cameraModeID, posPathID, moveTime )
	local tgtDummy = CameraTgtFollowPath( cameraModeID, tgtPathID, moveTime )
	scene:SetCamera( cameraModeID, transitionTime, posDummy, tgtDummy )
end

--
-- CameraPosFollowPath
--
function CameraPosFollowPath( cameraModeID, pathID, moveTime )
	if not pathID then
		return nil
	end

	local cameraDummyPos = cameraDummyPositions[cameraModeID]
	if (not cameraDummyPos) then
		cameraDummyPos = scene:SpawnActor(cameraDummyCreateData)
		cameraDummyPositions[cameraModeID] = cameraDummyPos
	end
	CameraDummyFollowPath( cameraDummyPos, pathID, moveTime )
	return cameraDummyPos
end

--
-- CameraPosFollowPath
--
function CameraTgtFollowPath( cameraModeID, pathID, moveTime )
	if not pathID then
		return nil
	end

	local cameraDummyTgt = cameraDummyTargets[cameraModeID]
	if (not cameraDummyPos) then
		cameraDummyTgt = scene:SpawnActor(cameraDummyCreateData)
		cameraDummyTargets[cameraModeID] = cameraDummyTgt
	end
	CameraDummyFollowPath( cameraDummyTgt, pathID, moveTime )
	return cameraDummyTgt
end

--
-- CameraDummyFollowPath
--
function CameraDummyFollowPath( cameraDummy, pathID, moveTime )
	local path = scene:LoadPath( pathID )
	if #path.nodes > 0 then
		-- snap to the first point
		local transform = cameraDummy:GetTransform()
		transform.position = path.nodes[1].pos
		cameraDummy:SetTransform( transform )

		-- start following
		cameraDummy:FollowPath( pathID, moveTime )
	end
end
"	0	0
156	"Jade Forest - Horde Intro Scene - Alliance Ship - JSB"	"

allianceShipDest = Vector:New(3650.85, -622.323, 0)
allianceShipMoveTime = 25


allianceShipSrc = allianceShip:GetPosition()
allianceShipMoveOffset = allianceShipDest - allianceShipSrc

-- force the ship to face a direction
allianceShip:SetFacingToAbs(Vector:New(3416.34, -985.503, 0))

WaitForTrigger( \"allianceShip\" )

RunToLocation(allianceShip, allianceShipMoveTime, allianceShipDest.x, allianceShipDest.y, allianceShipDest.z)

-- WaitForTrigger( \"shipMove\" )

-- RunToLocation(allianceShip, 10, 4113.9, -581.805, 0)


WaitForTrigger( \"zeppelinMove\" )
Wait( 13.5 )

-- allianceShipDest = Vector:New(3603.17, -571.637, 0)
RunToLocation(allianceShip, 500, 3845.42, -645.091, 0)
RunToLocation(shipFire03, 500, 3859.47, -636.061, 18.5503)
RunToLocation(shipFire02, 500, 3851.24, -641.253, 6.3)
RunToLocation(shipFire01, 500, 3835.78, -653.77, 12.9994)
RunToLocation(zeppelinTarget04, 500, 3822.34, -663.603, 17.7212)

local instance = shipFire01:PlaySpellStateVisual(19388)
local instance = shipFire02:PlaySpellStateVisual(19388)
local instance = shipFire03:PlaySpellStateVisual(19388)
local instance = zeppelinTarget04:PlaySpellStateVisual(19388)
"	0	0
160	"zzOld - PetBattle - Prototype 2.0 - Constants"	"--------------------------------------------------------------------------------
if (not MissReasons) then
	MissReasons = { }
end

if (not PetBattleMoveFailureReason) then
	PetBattleMoveFailureReason = { }
end

if (not PetBattlePetID) then
	PetBattlePetID =
	{
		Pad = 0;
	}
end

--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
idleRadius     = 1.5
rangedRadius   = 0.75
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.25

--------------------------------------------------------------------------------
-- pad: temp
--padModel = \"world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"
padModel = \"world\\goober\\g_runegroundpurple01.m2\"
padAlpha = 0.0
padScale = 0.4

--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand = 2267;
	Death = 2268;
	Dead  = 2269;
}
"	0	0
161	"zzOld - PetBattle - Prototype 2.0 - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function GetAlpha(pet)
	
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end

end
"	0	0
162	"zzOld - PetBattle - Prototype 2.0 - Init Player"	"
allPlayers = { }

function InitTeam(team)

	-- save the team
	allPlayers[#allPlayers + 1] = team

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, -idleRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	team.pad = scene:SpawnActor(padCreateData)
	team.pad:Fade(padAlpha, 0.5)

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		if (id == PetBattlePetID.Pad) then

		else
			local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }

			team.pets[id] = pet
				
			local radius = backlineRadius
			local offset = 0
			if id == team.activePet then
				radius = idleRadius
			else
				offset = backLineOffset
				backLineOffset = backLineOffset + backlineSpacing
			end
			
			local pos = BuildVector(team.teamFacing, -radius, offset)
			local transform = Transform:New(pos, team.teamFacing)
			
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
			petCreateData.creatureDisplayID = petDesc.displayID or 0

			pet.actor = scene:SpawnActor(petCreateData)

			SetHealth(pet, petDesc.health, true)

			pet.currentRadius = radius
			pet.currentOffset = offset

			-- always face the opponent location (at idleRadius)
			LookAtOpposingTeam(pet)

			-- apply initial auras
			for auraIndex, auraData in pairs(petDesc.auras or { }) do
				local auraVisual = petAbilityVisuals[auraData.auraVisualID]
				if (auraVisual) then
					ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
				end
			end

			-- hide all pets until loaded
			pet.actor:SetInteractible(false)
			pet.actor:SetHidden(true)
			pet.actor:Fade(0, 0)
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
		end
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetHidden(false)

			local targetAlpha = backlineAlpha
			if slot == player.activePet then
				-- use the front alpha if it is the active pet
				targetAlpha = GetAlpha(pet)
			end

			pet.actor:Fade(targetAlpha, fadeInTime)
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		for slot, pet in pairs ( player.pets ) do
			pet.actor:SetInteractible( true )
		end
	end

end
"	0	0
163	"zzOld - PetBattle - Prototype 2.0 - Effect Shared"	"
--------------------------------------------------------------------------------
-- Helper Functions for processing effects

local currentEffectInstanceID = nil

function ProcessEffect(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType
	local effectType = event.effectType

	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.RoundEffect) then

		-- battle round effects
		if (effectType == PetBattleEffect.SetHealth) then
			-- test: run set custom scripts on set health
			local abilityVisual = petAbilityVisuals[event.abilityVisualID]
			local processed = nil
			if (abilityVisual and abilityVisual.scriptFunction) then
				if ( abilityVisual.scriptFunction( {event} ) ) then
					processed = true
				end
			end
			if (not processed) then 
				EffectSetHealth(event)
			end
		elseif (effectType == PetBattleEffect.AuraApply) then
			EffectAuraApply(event)
		elseif (effectType == PetBattleEffect.AuraCancel) then
			EffectAuraChange(event, true)
		elseif (effectType == PetBattleEffect.AuraChange) then
			EffectAuraChange(event, false)
		elseif (effectType == PetBattleEffect.PetSwap) then
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		elseif (effectType == PetBattleEffect.StatusChange) then
			-- HACK - for backwards compatibility
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		end

	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (battleScene and battleScene:HasPendingEffects() == false) then
		ResetActivePets()
	end

	return true
end

--------------------------------------------------------------------------------
function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(effects)
  local customFunc = function(effects)
    return %s
  end
  customFunc(effects)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString
	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\"ERROR: loading script on BattlePetVisual ID=\" .. abilityVisual.ID .. \" failed: \" .. createString)
			print(\"ERROR: \" .. result)
		end
	end

end

"	0	0
164	"zzOld - PetBattle - Prototype 2.0 - Effect Cast"	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, idleRadius)
	end

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local attackRadius = idleRadius
	if abilityVisual.range == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif abilityVisual.range == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	
	-- move front pet to the correct radius, if it was the caster
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then
		WaitMoveToRadius(casterFrontPet, attackRadius)
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (casterCastingPet.actor ~= targetPet.actor) then
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(
				spellVisualID,
				abilityVisual.impactTime,
				true,
				{targetPet.actor})
		else
			-- self targeted
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
		end
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return casterCastingPet, spellVisualID
end
"	0	0
165	"zzOld - PetBattle - Prototype 2.0 - Effect Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		lastPet.actor:Fade(0, backlineFadeTime)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forard then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
166	"zzOld - PetBattle - Prototype 2.0 - Effect Set Health"	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisualID = effect.abilityVisualID
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for SetHealth\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
			targetPet.actor:AddWorldText(casterCastingPet, MissReasons.Physical, false, false)
		else
			if (spellVisualID) then
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)
			end

			local newHealth = targetData.newHealth
			SetHealth(targetPet, newHealth, false)
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		casterCastingPet.actor:WaitCastingComplete(true)
	end
end
"	0	0
167	"zzOld - PetBattle - Prototype 2.0 - Effect Aura Apply"	"
--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local auraVisualID = 0
	if (effect.targets[1]) then
		auraVisualID = effect.targets[1].auraVisualID
	end

	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, auraVisualID)
	if (not auraVisualID) or (auraVisualID == 0) then
		print(\"WARNING: no auraVisual for aura\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. auraVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
			targetPet.actor:AddWorldText(casterCastingPet, MissReasons.Physical, false, false)
		else
			if (spellVisualID) then
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)
			end

			-- apply an aura, tracked by instance ID
			ApplyAura(targetPet, targetData.auraInstanceID, targetData.turnsRemaining, spellVisualID)
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		casterCastingPet.actor:WaitCastingComplete(true)
	end
end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	if (aura.spellVisualID) then
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	else
		aura.spellVisualInstanceID = nil
	end
	aura.turnsRemaining = turnsRemaining
end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end
"	0	0
168	"zzOld - PetBattle - Prototype 2.0 - Effect Aura Change"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	for index, target in pairs(effect.targets) do
		local petPlayerID = target.playerID
		local petSlot = target.petSlot

		local player = GetTeamByIndex(petPlayerID)
		local pet = player.pets[petSlot]

		if not petSlot then
			return
		end

		local auraInstanceID = target.auraInstanceID
		local aura = pet.auras[auraInstanceID]
		if not aura then
			print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
			return
		end

		if (cancel == true) or (target.turnsRemaining < 1) then
			RemoveAura(pet, auraInstanceID)
		else
			aura.turnsRemaining = target.turnsRemaining
		end
	end

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil

end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end
"	0	0
169	"zzOld - PetBattle - Prototype 2.0 - Test Teams"	"--------------------------------------------------------------------------------
-- Test Teams
function InitTestTeams()

	local currentAbilityID = 0
	local abilityID = function()
		currentAbilityID = currentAbilityID + 1
		return currentAbilityID
	end

	local currentTurnID = 0
	local turnID = function()
		currentTurnID = currentTurnID + 1
		return currentTurnID
	end

	-- Venomous Bite
	local venomousBite = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 32739,
				isMelee = true,
				spellVisualID = 809,
				castTime = 0.0,
				impactTime = 0.1,
			}
		}
	}	

	-- Acid Spit
	local acidSpit = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 20657,
				isMelee =  false,
				spellVisualID = 854,
				castTime = 1.0,
				impactTime = 0.5,
			}
		}
	}

	-- Heroic Strike
	local heroicStrike = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 78,
				isMelee =  true,
				spellVisualID = 19654,
				castTime = 0.0,
				impactTime = 0.1,
			}
		}
	}

	-- Frost Nova
	local frostNova = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 122,
				isMelee =  true,
				spellVisualID = 17,
				castTime = 0.0,
				impactTime = 0.0,
			}
		}
	}

	-- Chain Lightning
	local chaingLightning = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 421,
				isMelee =  false,
				spellVisualID = 36,
				castTime = 1.5,
				impactTime = 0.0,
			}
		}
	}

	-- Fireball
	local fireBall = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 133,
				isMelee =  false,
				spellVisualID = 67,
				castTime = 1.25,
				impactTime = 0.25,
			}
		}
	}	

	-- Fire Nova
	local fireNova =
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 11969,
				isMelee =  true,
				spellVisualID = 963,
				castTime = 2.0,
				impactTime = 0.0,
			}
		}
	}	

	-- Immolate
	local immolate = 
	{
		ID = abilityID(),
		turns =
		{
			{
				ID = turnID(),
				spellID = 348,
				isMelee =  false,
				spellVisualID = 46,
				castTime = 1.5,
				impactTime = 0.0,
			}
		}
	}	

	local abilityList = 
	{
		venomousBite,
		acidSpit,
		heroicStrike,
		frostNova,
		chaingLightning,
		fireBall,
		fireNova,
		immolate
	}

	-- set up the parent ability IDs
	for j,ability in pairs(abilityList) do
		for i,abilityTurn in pairs(ability.turns) do
			abilityTurn.abilityID = ability.ID
		end
	end

	-- Raptor
	local petDescRaptor = 
	{
		creatureID = 59709,
		health = 100,
		abilityIDs = { venomousBite.ID, acidSpit.ID, heroicStrike.ID }
	}

	-- Robot
	local petDescRobot =
	{
		creatureID = 59710,
		health = 100,
		abilityIDs = { frostNova.ID, chaingLightning.ID, heroicStrike.ID }
	}

	-- Fire Elemental
	local petDescFireElemental =
	{
		creatureID = 59795,
		health = 100,
		abilityIDs = { fireBall.ID, fireNova.ID, immolate.ID }
	}

	-- Team 1
	local team1 =
	{
		playerID = 1,	
		activePet = 1,
		petDescs = { petDescRaptor, petDescRobot, petDescFireElemental }
	}

	-- Team 2
	local team2 =
	{
		playerID = 2,
		activePet = 2,
		petDescs = { petDescRobot, petDescFireElemental, petDescRaptor }
	}

	local initBattleState = 
	{
		players = { team1, team2 };
		abilityDescs = abilityList;
	}

	return initBattleState
end
"	0	0
170	"zzOld - PetBattle - Prototype 2.0 - Test Events"	"
--------------------------------------------------------------------------------
-- A Random Battle To The Death
local testBattleCurrentPlayer = 1
function GenerateTestBattleEvent()

	local event = nil

	local attacker = GetActivePetByIndex(testBattleCurrentPlayer)
	local victim = GetActivePetByIndex(3-testBattleCurrentPlayer)
	local turnType
	if (victim.currentHealth <= 0) then
		-- force swap victim
		turnType = 1
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
	elseif (attacker.currentHealth <= 0) then
		-- force swap my pet (killed self somehow)
		turnType = 1
	else
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
		turnType = math.random(2)
	end

	local playerID = testBattleCurrentPlayer
	attacker = GetActivePetByIndex(playerID)
	victim = GetActivePetByIndex(3-playerID)

	if (turnType == 1) then
		local team = GetTeamByIndex(playerID)
		-- find a living pet to swap to
		local aliveBacklinePets = { }
		local numAlive = 0
		for petIndex, pet in pairs(team.pets) do
			if (petIndex ~= team.activePet) and (pet.currentHealth > 0) then
				numAlive = numAlive + 1
				aliveBacklinePets[numAlive] = petIndex
			end
		end

		if (numAlive > 0) then
			local petIndex = aliveBacklinePets[math.random(#aliveBacklinePets)]

			event =
			{
				type = PetBattleEffect.PetSwap;
				casterPlayerID = playerID;
				newFrontPet = petIndex;
			}
		end
	elseif (turnType == 2) then
		local abilityIndex = math.random(#attacker.desc.abilityIDs)
		local abilityID = attacker.desc.abilityIDs[abilityIndex]
		local usedAbilityTurnID = petAbilities[abilityID].turns[1].ID
		local abilityDamage = math.random(40,60)
		local targetHealth = victim.currentHealth - abilityDamage
		local attackerPlayerID = playerID

		event =
		{
			type = PetBattleEffect.Ability;
			casterPlayerID = attackerPlayerID;
			casterPetSlot = attacker.slot;
			abilityTurnID = usedAbilityTurnID;
			targets =
			{
				{
					playerID = 3 - attackerPlayerID;
					petSlot = victim.slot;
					newHealth = targetHealth;
				}
			};
		}
	end

	if (event) then
		scene:WaitTimer(0.25)
	end

	return event

end
"	0	0
171	"zzOld - PetBattle - Prototype 2.0 - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 3.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.5, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
172	"zzOld - PetBattle - Prototype 2.0 - Intro"	"
--------------------------------------------------------------------------------
function BattleIntro()

	SetCamera(1)
	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	scene:WaitTimer(0.25)
	SetCamera(2)
	scene:WaitTimer(0.75)
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
173	"zzOld - PetBattle - Prototype 2.0 - Main"	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
else
	-- no battle scene implies a manually created test battle
	isObserved = true
	observingPlayerIndex = 1
end

--------------------------------------------------------------------------------
-- see if we\'re using test teams
if (battleScene and battleScene:UseTestPlayerData() == true) or (not initialBattleState) then
	initialBattleState = InitTestTeams()
end

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
if (isObserved == true) then
	-- backwards compatibility
	initialBattleState.players[observingPlayerIndex].teamFacing = 0
	initialBattleState.players[3-observingPlayerIndex].teamFacing = 180
else
	initialBattleState.players[1].teamFacing = 0
	initialBattleState.players[2].teamFacing = 180
end

teams = { initialBattleState.players[1], initialBattleState.players[2] }
InitTeam(teams[1])
InitTeam(teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		SetCamera(3)
	end

	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local effect = nil
	if (battleScene:IsTestBattle() == true) then
		effect = GenerateTestBattleEvent()
		if (not effect) then
			scene:WaitTimer(0)
		end
	else
		-- poll for round effects
		local waitForEffects = function()
			return battleScene:HasPendingEffects()
		end
		scene:WaitCondition(waitForEffects)
		effect = battleScene:GetPendingEffect()
	end

	inBattle, winnerID = ProcessEffect(effect)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if winnerTeam.activePet ~= petIndex and pet.currentHealth > 0 then
			-- move backline up to celebrate
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	SetCamera(4);
end

scene:WaitTimer(0.75)
battleScene:SignalBattleComplete()
"	0	0
189	"Jade Forest - Horde Intro Scene - Alliance Captain - JSB"	"allianceCaptain:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCaptain -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 2 )

allianceCaptain:PlayOneShotFullBodyAnim(Animations.EmoteTalkExclamation)

Wait( 8.1 )

local shakeOrigin = Vector:New(3723.47, -639.766, 14.877)
shakeX = scene:AddCameraShake( 211, shakeOrigin )
shakeY = scene:AddCameraShake( 212, shakeOrigin )
shakeZ = scene:AddCameraShake( 213, shakeOrigin )


allianceCaptain:PlayLoopingFullBodyAnim(Animations.FlyFall)
local actorAuraVisual = allianceCaptain:PlaySpellStateVisual(9628) --Cast Actor Visual

allianceCaptain:FollowPath( 3231, 2 )

Wait( 3 )

allianceCaptain:Despawn()"	0	0
191	"Jade Forest - Horde Intro Scene - Gorrok - JSB"	"
WaitForTrigger( \"gorrokMove\" )
RunToLocation( gorrok, 2, 3442.33, -288.137, 267.447, 336 )
Wait(1)

gorrok:PlayLoopingFullBodyAnim(Animations.EmoteTalk)
Wait(4)
gorrok:StopLoopingFullBodyAnim()

Wait(4)

SendTrigger( \"nazgrimTalk\" )
Wait(5)
gorrok:PlayOneShotFullBodyAnim(Animations.EmoteSalute)
Wait(3)

RunToLocation( gorrok, 2, 3434.29, -289.758, 268.19, 203.226 )

SendTrigger( \"rivettTalk\" )


WaitForTrigger( \"shipSpotted\" )
Wait(1.5)
RunToLocation( gorrok, 2, 3439.87, -293.908, 267.8, 293.237 )



-- COPY STARTS HERE
--
local relativeMover = gorrok -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

gorrok:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
-- gorrok:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
192	"Jade Forest - Horde Intro Scene - Rivett - JSB"	"
WaitForTrigger( \"gorrokMove\" )
Wait(5)
RunToLocation( rivett, 2, 3454.62, -276.787, 268.1, 60 )
Wait(6)
rivett:SetFacing(157)
Wait(5)
RunToLocation( rivett, 2, 3456.92, -282.23, 268.1, 251.326 )

WaitForTrigger( \"rivettTalk\" )
Wait(0.25)
rivett:PlayOneShotFullBodyAnim(Animations.EmoteShout)
Wait(2)
rivett:PlayOneShotFullBodyAnim(Animations.EmotePoint)

WaitForTrigger( \"shipSpotted\" )
Wait(2)
RunToLocation( rivett, 2, 3456.49, -282.811, 268.1, 275 )


-- COPY STARTS HERE
--
local relativeMover = rivett -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

rivett:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
193	"Jade Forest - Horde Intro Scene - Special Fog - JSB"	"
WaitForTrigger( \"rivettTalk\" )
FadeIn( mist, 0 )

Wait(8)
FadeOut( mist, 6 )
"	0	0
194	"Jade Forest - Horde Intro Scene - Zin\'jun - JSB"	"
WaitForTrigger( \"rivettTalk\" )

Wait( 1 )

zinjun:PlayOneShotAnimKit(2331)

Wait(10)
zinjun:PlayOneShotFullBodyAnim(Animations.Stand)
Wait(1)
zinjun:PlayLoopingFullBodyAnim(Animations.Stand)
-- zinjun:PlayOneShotFullBodyAnim(Animations.EmotePoint)

Wait(4)

RunToLocation( zinjun, 1, 3460.48, -284.169, 268.1, 199.819 )

-- COPY STARTS HERE
--
local relativeMover = zinjun -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

zinjun:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()

"	0	0
195	"Jade Forest - Horde Intro Scene - Kiryn - JSB"	"WaitForTrigger( \"rivettTalk\" )

Wait(12)

kiryn:PlayLoopingFullBodyAnim(Animations.Stand)


Wait(4)

RunToLocation( kiryn, 1, 3456.55, -280.263, 268.1, 130.8 )


-- COPY STARTS HERE
--
local relativeMover = kiryn -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
kiryn:PlayLoopingFullBodyAnim(Animations.Cower)
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
--relativeMover:StopLoopingFullBodyAnim()

"	0	0
196	"Lorewalker Story - S1: Grummle - Init - Scene 1 Actors - ZTO"	"-- Spell preloads
grummleTransformSpellID = 120566
grummleTransformEffectSpellID = 120704

-- Spawn troggs
troggID = 61900
troggMain = SpawnActor( troggID, 1447.39, 361.676, 550.221, 42.0026 ) -- Trogg protagonist
trogg01 = SpawnActor( troggID, 1455.21, 362.066, 550.221, 162.378 ) -- Trogg extra
trogg02 = SpawnActor( troggID, 1447.25, 367.173, 550.221, 335.853 ) -- Trogg extra
trogg03 = SpawnActor( troggID, 1450.18, 360.01, 550.221, 242.928 ) -- Trogg extra
FadeOut( troggMain, 0 )
FadeOut( trogg01, 0 )
FadeOut( trogg02, 0 )
FadeOut( trogg03, 0 )

-- Spawn mogu
moguFleshshaperID = 61898
moguGruntID = 61899
moguMain = SpawnActor( moguFleshshaperID, 1460.34, 362.918, 550.222, 131.724 ) -- Mogu Main Character
moguGrunt01 = SpawnActor( moguGruntID, 1464.41, 378.03, 550.222, 218.403 ) -- Mogu Grunt Character
moguGrunt02 = SpawnActor( moguGruntID, 1467.7, 374.153, 550.222, 218.403 ) -- Mogu Grunt Character
FadeOut( moguMain, 0 )
FadeOut( moguGrunt01, 0 )
FadeOut( moguGrunt02, 0 )

-- Spawn Grummle
grummleID = 61901
grummleBagID = 61902
grummleMain = SpawnActor( grummleID, 1454.37, 369.568, 550.222, 41.102 ) -- Grummle spawns where Trogg fades
grummleMainBag = SpawnActor( grummleBagID, 1460.31, 374.792, 550.222, 221.327 ) -- Grummle spawns where Trogg fades
grummlePacker1 = SpawnActor( grummleBagID, 1463.23, 374.766, 550.222, 221.327 ) -- Grummle spawns offset from grummlemainbag
grummlePacker2 = SpawnActor( grummleBagID, 1460.55, 377.703, 550.222, 221.327 ) -- Grummle spawns offset from grummlemainbag
grummleIncenseSniffer = SpawnActor( grummleID, 1448.58, 362.965, 550.222, 131.491 ) -- Grummle spawns offset from grummlemainbag
FadeOut( grummleMain, 0 )
FadeOut( grummleMainBag, 0 )
FadeOut( grummlePacker1, 0 )
FadeOut( grummlePacker2, 0 )
FadeOut( grummleIncenseSniffer, 0 )

-- Spawn Grummle Incense
incenseID = 62262
incense1 = SpawnActor( incenseID, 1447.74, 358.042, 550.221, 117.09)
incense2 = SpawnActor( incenseID, 1450.52, 358.761, 550.221, 127.665)
incense3 = SpawnActor( incenseID, 1451.03, 361.861, 550.221, 140.265)
incense4 = SpawnActor( incenseID, 1446.18, 360.548, 550.221, 114.165)
FadeOut( incense1, 0 )
FadeOut( incense2, 0 )
FadeOut( incense3, 0 )
FadeOut( incense4, 0 )
"	0	0
197	"Lorewalker Story - S1: Grummle - Trogg01 - ZTO"	"-- Wandering Trogg
-- meander around
WaitForTrigger( \"Spawn Troggs\" )
FadeIn( trogg01, 1 )
local actorAuraVisual = trogg01:PlaySpellStateVisual(24803) --Cast Actor Visual

-- Run forward
RunToLocation( trogg01, 5.5, 1451.81, 362.822, 550.222, 177.767 )
Wait(1)
RunToLocation( trogg01, 5.5, 1452.64, 360.794, 550.222, 292.292 )
Wait(1)
RunToLocation( trogg01, 5.5, 1453.48, 362.303, 550.222, 60.7672 )

-- grummle trigger
WaitForTrigger( \"grummleTransform\" )

Wait(1)

RunToLocation( trogg01, 5.5, 1448.95, 356.926, 550.222, 228.392 )
trogg01: Despawn()"	0	0
198	"Lorewalker Story - S1: Grummle - Trogg02 - ZTO"	"-- Wandering Trogg
-- meander around
WaitForTrigger( \"Spawn Troggs\" )
FadeIn( trogg02, 1 )
local actorAuraVisual = trogg02:PlaySpellStateVisual(24803) --Cast Actor Visual

-- Run forward
RunToLocation( trogg02, 5.5, 1445.27, 364.92, 550.221, 228.754 )
Wait(1)
RunToLocation( trogg02, 5.5, 1444.47, 367.409, 550.221, 91.9536 )
Wait(1)
RunToLocation( trogg02, 5.5, 1446.52, 365.808, 550.221, 8.25353 )

-- grummle trigger
WaitForTrigger( \"grummleTransform\" )

Wait(1)

RunToLocation( trogg02, 5.5, 1442.34, 362.558, 550.221, 222.679 )
trogg02: Despawn()"	0	0
199	"Lorewalker Story - S1: Grummle - Trogg03 - ZTO"	"-- Wandering Trogg
-- meander around
WaitForTrigger( \"Spawn Troggs\" )
FadeIn( trogg03, 1 )
local actorAuraVisual = trogg03:PlaySpellStateVisual(24803) --Cast Actor Visual

-- Run forward
RunToLocation( trogg03, 5.5, 1448.08, 355.902, 550.221, 242.928 )
Wait(1)
RunToLocation( trogg03, 5.5, 1446.66, 357.854, 550.221, 122.103 )
Wait(1)
RunToLocation( trogg03, 5.5, 1448.39, 358.707, 550.221, 18.378 )

-- grummle trigger
WaitForTrigger( \"grummleTransform\" )

Wait(1)

RunToLocation( trogg03, 5.5, 1446.07, 357.41, 550.221, 209.178 )
trogg03: Despawn()"	0	0
200	"Lorewalker Story - S1: Grummle - TroggMain - ZTO"	"-- Wandering Trogg
-- meander around
WaitForTrigger( \"Spawn Troggs\" )
local actorAuraVisual = troggMain:PlaySpellStateVisual(24803) --Cast Actor Visual

WaitForTrigger( \"troggSpawn\" )
FadeIn( troggMain, 1 )
Wait(2)

-- Run forward
RunToLocation( troggMain, 2, 1454.37, 369.568, 550.222, 41.102 )
Wait(1)


-- grummle transform trigger
WaitForTrigger( \"grummleTransform\" )
CastSpellAtActor( troggMain, troggMain, grummleTransformEffectSpellID )
FadeOut( troggMain, 1 )
troggMain: Despawn()"	0	0
201	"Lorewalker Story - S1: Grummle - MoguMain - ZTO"	"-- Mogu enters stage right
-- cross to slightly center stage right
WaitForTrigger( \"Spawn Mogu\" )

SendTrigger( \"cueLight_CC\" )
FadeIn( moguMain, 2 )
local actorAuraVisual = moguMain:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation( moguMain, 2, 1457.22, 366.413, 550.222, 131.724 )

-- Summons the Troggs
SendTrigger( \"troggSpawn\" )

-- Continue forward march
RunToLocation( moguMain, 2, 1458.92, 371.169, 550.222, 218.403 )
Wait(5)

CastSpellAtActor( moguMain, troggMain, grummleTransformSpellID )
Wait (1)
SendTrigger(\"grummleTransform\")
Wait (1)
FadeOut( moguMain, 1)
moguMain:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait (5)


moguMain: Despawn()

-- Wait for command and then drift off stage
--WaitForTrigger(\"startRunning\")
--moguMain: SetFacingToAbs(Vector:New(1444.44, 360.476, 550.221)) 
--moguMain: PlayLoopingAnimKit( 2319 )
--RunToLocation( moguMain, 2, 1467.41, 377.901, 550.222, 218.403 )
--FadeOut( moguMain, 1)
--moguMain:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
--
--Wait (5)
--
--
--moguMain: Despawn()"	0	0
202	"Lorewalker Story - S1: Grummle - MoguGrunt01 - ZTO"	"-- MoguGrunts enter stage right
-- Remain at attention
WaitForTrigger(\"Spawn Mogu\")
Wait (2)
FadeIn( moguGrunt01, 1 )
local actorAuraVisual = moguGrunt01:PlaySpellStateVisual(24803) --Cast Actor Visual


-- Wait for Grummle Trigger
WaitForTrigger( \"grummleTransform\" )
Wait(2)
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )
Wait(1)
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )
Wait(1)
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )



-- Wait for command and then drift off stage
WaitForTrigger(\"startRunning\")
FadeOut( moguGrunt01, 1)

Wait(5)
moguGrunt01: Despawn()"	0	0
203	"Lorewalker Story - S1: Grummle - MoguGrunt02 - ZTO"	"-- MoguGrunts enter stage right
-- Remain at attention
WaitForTrigger(\"Spawn Mogu\")
Wait (2)
FadeIn( moguGrunt02, 1 )
local actorAuraVisual = moguGrunt02:PlaySpellStateVisual(24803) --Cast Actor Visual

-- Wait for Grummle Trigger
WaitForTrigger( \"grummleTransform\" )
Wait(2)
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )
Wait(1)
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )
Wait(1)
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )



-- Wait for command and then drift off stage
WaitForTrigger(\"startRunning\")
FadeOut( moguGrunt02, 1)

Wait(5)
moguGrunt02: Despawn()"	0	0
205	"Stormwind - Varian Gets Punched - Master - PRK"	"scene:SetCamera(376, 0.5, nil, nil)

Wait(5.0)

scene:SetCamera(377, 0, nil, nil)

Wait(3.0)

scene:SetCamera(378, 0, nil, nil)

Wait(3.0)

scene:SetCamera(0, 1, nil, nil) -- sets camera back to game-cam"	0	0
206	"Jade Forest - Horde Intro Scene - Snuff - JSB"	"
WaitForTrigger( \"rivettTalk\" )
Wait(1.5)
snuff:StopLoopingFullBodyAnim()
-- snuff:PlayOneShotFullBodyAnim(Animations.SleepUp)
snuff:PlayOneShotAnimKit(2330)
Wait(10)


RunToLocation( snuff, 4, 3458.08, -288.528, 268.1, 290.064 )


WaitForTrigger( \"shipSpotted\" )
Wait( 1.5 )

snuff:PlayOneShotFullBodyAnim(Animations.EmoteRoar)

-- snuff:PlayLoopingFullBodyAnim(Animations.Stand)
-- snuff:SetFacing( 190 ) 

-- COPY STARTS HERE
--
local relativeMover = snuff -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

snuff:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()"	0	0
207	"Lorewalker Story - S1: Grummle - GrummleMain - ZTO"	"-- Grummle spawns where trogg got tacknuked
WaitForTrigger( \"grummleTransform\" )
FadeIn( grummleMain, 0 )
local actorAuraVisual = grummleMain:PlaySpellStateVisual(24803) --Cast Actor Visual
Wait(2)

-- Face downstage center
grummleMain: SetFacing( 132.227 )
Wait(1)

-- Cheer
PlayOneShotSplitBodyAnim( grummleMain, Animations.BattleRoar )
Wait(1)



-- Face Stage left and begin fake running
grummleMain: SetFacing( 221.327 )
SendTrigger( \"startRunning\" )
PlayLoopingSplitBodyAnim( grummleMain, Animations.Run )
Wait(3)

-- Despawn and replace with bag version
SendTrigger( \"grummleTransform2\" )
SendTrigger( \"blackLight_CC\" )
FadeOut(grummleMain, 1)
Wait(1)
grummleMain: Despawn()
"	0	0
208	"Lorewalker Story - S1: Grummle - GrummleMainBag - ZTO"	"-- Grummle spawns where non-pack version of grummle is running in place
WaitForTrigger( \"grummleTransform2\" )
PlayLoopingSplitBodyAnim( grummleMainBag, Animations.Run )
SendTrigger( \"cueLight_CR\" )
FadeIn( grummleMainBag, 1 )
local actorAuraVisual = grummleMainBag:PlaySpellStateVisual(24803) --Cast Actor Visual
Wait(1)

-- Start Scene 2
--SendTrigger(\"scene2Trigger\")

Wait(5)

-- Start Scene 3
--SendTrigger(\"scene3Trigger\")
Wait(1)
SendTrigger(\"addGrummle1\")
Wait(3)

-- Start Scene 4
--SendTrigger(\"scene4Trigger\")
Wait(1)
SendTrigger(\"addGrummle2\")
Wait(3)
SendTrigger(\"callSmack\")

-- Wait for tree hit
WaitForTrigger(\"treeSmack\")
grummleMainBag: StopLoopingSplitBodyAnim( Animations.Run )
grummleMainBag: PlayOneShotAnimKit( 2327 )
local dazeAuraVisual = grummleMainBag:PlaySpellStateVisual(84) --Cast Daze Visual
PlayLoopingSplitBodyAnim( grummleMainBag, Animations.SitGround )
Wait(3)

SendTrigger(\"clearTree\")
Wait(1)

-- Call in the Pandas, look at each, and then walk off with stinky one
--SendTrigger(\"callPandas\")
--grummleMainBag:ClearSpellStateVisual(84, dazeAuraVisual) --Clear Daze Visual
--PlayOneShotSplitBodyAnim( grummleMainBag, Animations.SitGroundUp )
--grummleMainBag: StopLoopingSplitBodyAnim( Animations.SitGround )
--grummleMainBag: SetFacing(130.147)

--PlayLoopingSplitBodyAnim( grummleMainBag, Animations.Stand )

--Wait(2)
--grummleMainBag: SetFacing(183) -- Face Stinky Pandaren
--Wait(2)
--grummleMainBag: SetFacing(80) -- Face Rich Pandaren
--Wait(2)
--grummleMainBag: SetFacing(183) -- Face Stinky Pandaren
--Wait(2)

--RunToLocation( grummleMainBag, 2, 1450.79, 369.54, 550.221  )
--SendTrigger(\"clearPandas\") -- Fade out pandas mid pathing
--RunToLocation( grummleMainBag, 2, 1447.98, 369.523, 550.221  )


-- End Scene
SendTrigger( \"blackLight_CR\" )
--SendTrigger(\"endScene\")
FadeOut(grummleMainBag, 1)
grummleMainBag: Despawn()"	0	0
209	"Lorewalker Story - S1: Grummle - Init - Scene 2 Actors - ZTO"	"-- Spawn Pack 1 group
pandarenSlaveID = 61904
--pandarenSlave01 = SpawnActor(pandarenSlaveID, 1448.95, 358.934, 550.222, 268.352 ) -- Pandaren Slave
--moguSlaver01 = SpawnActor(moguGruntID, 1450.02, 356.149, 550.222, 90.8269 ) -- Mogu Slaver
--FadeOut( pandarenSlave01, 0 )
--FadeOut( moguSlaver01, 0 )

-- Spawn Pack 2 group
pandarenSlave02 = SpawnActor(pandarenSlaveID, 1457.77, 366.87, 550.222, 328.589 ) -- Pandaren Slave
pandarenSlave03 = SpawnActor(pandarenSlaveID, 1461.31, 370.165, 550.222, 278.864 ) -- Pandaren Slave
moguSlaver02 = SpawnActor(moguGruntID, 1461.65, 365.438, 550.222, 122.714 ) -- Mogu Slaver
grummleCheer1 = SpawnActor(grummleID, 1461.78, 361.129, 551.808, 131.713 ) -- Grummle Cheer 1
grummleCheer2 = SpawnActor(grummleID, 1459.34, 358.958, 551.808, 93.2375 ) -- Grummle Cheer 1
grummleCheer3 = SpawnActor(grummleID, 1457.85, 360.444, 550.223, 82.6616 ) -- Grummle Cheer 1
grummleCheer4 = SpawnActor(grummleID, 1455.37, 362.743, 550.223, 34.5116 ) -- Grummle Cheer 1
FadeOut( pandarenSlave02, 0 )
FadeOut( pandarenSlave03, 0 )
FadeOut( moguSlaver02, 0 )
FadeOut( grummleCheer1, 0 )
FadeOut( grummleCheer2, 0 )
FadeOut( grummleCheer3, 0 )
FadeOut( grummleCheer4, 0 )

-- Spawn Pack 3 group
--shadopanID = 61908
--hozenID = 61906
--hozen01 = SpawnActor(hozenID, 1448.95, 358.934, 550.222, 268.352 ) -- Hozen Downstage
--hozen02 = SpawnActor(hozenID, 1447.04, 357.023, 550.222, 359.702 ) -- Hozen Downstage
--shadopan01 = SpawnActor(shadopanID, 1450.02, 356.149, 550.222, 90.8269 ) -- Shadowpan Upstage
--FadeOut( shadopan01, 0 )
--FadeOut( hozen01, 0 )
--FadeOut( hozen02, 0 )"	0	0
210	"Lorewalker Story - S1: Grummle - Scene 2 - pandarenSlave01 - ZTO"	"-- Wait until scene 2 begins
-- pandarenSlave01: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
-- pandarenSlave01: PlayLoopingAnimKit( 2312 )

-- WaitForTrigger(\"scene2Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
-- FadeIn( pandarenSlave01, 1)
-- local actorAuraVisual = pandarenSlave01:PlaySpellStateVisual(24803) --Cast Actor Visual
-- RunToLocation( pandarenSlave01, 2, 1466.88, 375.627, 550.221 )
-- FadeOut( pandarenSlave01, 1)
-- pandarenSlave01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

-- Wait(5)
-- pandarenSlave01: Despawn()"	0	0
211	"Lorewalker Story - S1: Grummle - Scene 2 - moguSlaver01 - ZTO"	"-- Wait until scene 2 begins
-- moguSlaver01: SetFacingToAbs(Vector:New(1448.66, 601.672, 550.222)) 
-- moguSlaver01:PlayLoopingFullBodyAnim(Animations.EmoteLaugh)

-- WaitForTrigger(\"scene2Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
-- FadeIn( moguSlaver01, 1)
-- local actorAuraVisual = moguSlaver01:PlaySpellStateVisual(24803) --Cast Actor Visual
-- RunToLocation( moguSlaver01, 2, 1467.81, 372.467, 550.222 )
-- FadeOut( moguSlaver01, 1)
-- moguSlaver01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
-- 
-- Wait(5)
-- moguSlaver01: Despawn()"	0	0
212	"Lorewalker Story - S1: Grummle - Scene 3 - pandarenSlave02 - ZTO"	"-- Wait until scene 3 begins
--pandarenSlave02: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
pandarenSlave02: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\"scene3Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
FadeIn( pandarenSlave02, 1)
local actorAuraVisual = pandarenSlave02:PlaySpellStateVisual(24803) --Cast Actor Visual
--RunToLocation( pandarenSlave02, 2, 1466.88, 375.627, 550.221 )


--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( pandarenSlave02, 1)
pandarenSlave02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
pandarenSlave02: Despawn()"	0	0
213	"Lorewalker Story - S1: Grummle - Scene 3 - pandarenSlave03 - ZTO"	"-- Wait until scene 3 begins
--pandarenSlave03: SetFacingToAbs(Vector:New(1739.47, 358.197, 550.222)) 
Wait (1)
pandarenSlave03: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\"scene3Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
FadeIn( pandarenSlave03, 1)
local actorAuraVisual = pandarenSlave03:PlaySpellStateVisual(24803) --Cast Actor Visual
--RunToLocation( pandarenSlave03, 2, 1464.94, 373.747, 550.222 )

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( pandarenSlave03, 1)
pandarenSlave03:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
pandarenSlave03: Despawn()"	0	0
214	"Lorewalker Story - S1: Grummle - Scene 3 - moguSlaver02 - ZTO"	"-- Wait until scene 3 begins
moguSlaver02: SetFacingToAbs(Vector:New(1448.66, 601.672, 550.222)) 
moguSlaver02: PlayLoopingAnimKit( 2316 )

WaitForTrigger(\"scene3Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
SendTrigger( \"cueLight_UC\")
FadeIn( moguSlaver02, 1)
local actorAuraVisual = moguSlaver02:PlaySpellStateVisual(24803) --Cast Actor Visual
--RunToLocation( moguSlaver02, 2, 1467.81, 372.467, 550.222 )

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
SendTrigger( \"blackLight_UC\")
FadeOut( moguSlaver02, 1)
moguSlaver02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
moguSlaver02: Despawn()"	0	0
215	"Lorewalker Story - S1: Grummle - Scene 4 - hozen01 - ZTO"	"-- Wait until scene 4 begins
-- hozen01: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
-- hozen01: PlayLoopingAnimKit( 2315 )

-- WaitForTrigger(\"scene4Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
-- FadeIn( hozen01, 1)
-- local actorAuraVisual = hozen01:PlaySpellStateVisual(24803) --Cast Actor Visual
-- RunToLocation( hozen01, 2, 1466.88, 375.627, 550.221  )
-- FadeOut( hozen01, 1)
-- hozen01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

-- Wait(5)
-- hozen01: Despawn()"	0	0
216	"Lorewalker Story - S1: Grummle - Scene 5 - shadopan01 - ZTO"	"-- Wait until scene 5 begins
--shadopan01: SetFacingToAbs(Vector:New(1281.7, 556.612, 536.167)) 
--shadopan01: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\"scene5Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
FadeIn( light_cr, 1)
FadeIn( shadopan01, 1)
local actorAuraVisual = shadopan01:PlaySpellStateVisual(24803) --Cast Actor Visual

--Wait for grummles to arrive
WaitForTrigger (\"Scene5a\")
PlayOneShotSplitBodyAnim( shadopan01, Animations.EmoteBow )

-- Clear shado-pan at end of scene
WaitForTrigger (\"endScene5\")
FadeOut( light_cr, 1)
FadeOut( shadopan01, 1)
shadopan01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
shadopan01: Despawn()"	0	0
217	"Lorewalker Story - S1: Grummle - Scene 4 - hozen02 - ZTO"	"-- Wait until scene 3 begins
-- hozen02: SetFacingToAbs(Vector:New(1739.47, 358.197, 550.222)) 
-- Wait (1)
-- hozen02: PlayLoopingAnimKit( 2315 )

-- WaitForTrigger(\"scene4Trigger\")

-- Kneel before slavemaster and truck from stage left to stage right
-- FadeIn( hozen02, 1)
-- local actorAuraVisual = hozen02:PlaySpellStateVisual(24803) --Cast Actor Visual
-- RunToLocation( hozen02, 2, 1464.94, 373.747, 550.222 )
-- FadeOut( hozen02, 1)
-- hozen02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

-- Wait(5)
-- hozen02: Despawn()"	0	0
218	"Jade Forest - Horde Intro Scene - Cannon01 - JSB"	"cannon01:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 15 )


cannon01:Despawn()"	0	0
219	"Jade Forest - Horde Intro Scene - Cannon02 - JSB"	"cannon02:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 15 )


cannon02:Despawn()"	0	0
220	"Jade Forest - Horde Intro Scene - Mists - JSB"	"WaitForTrigger( \"shipSpotted\" )

Wait( 3 )
for index, mist in pairs(mists) do
	mist:Fade( 0, 3 )
end

Wait( 3 )

-- despawn all the mists
for index, mist in pairs(mists) do
	mist:Despawn()
end"	0	0
221	"Jade Forest - Horde Intro Scene - Vangard01 - JSB"	"-- COPY STARTS HERE
--
local relativeMover = vanguard01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

vanguard01:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
-- vanguard01:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
222	"Jade Forest - Horde Intro Scene - Vangard02 - JSB"	"-- COPY STARTS HERE
--
local relativeMover = vanguard02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

vanguard02:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
-- vanguard02:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
223	"Jade Forest - Horde Intro Scene - Vangard03 - JSB"	"-- COPY STARTS HERE
--
local relativeMover = vanguard03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

vanguard03:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
-- vanguard03:PlayLoopingFullBodyAnim(Animations.Cower)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
225	"Jade Forest - Horde Intro Scene - Shokia - JSB"	"
WaitForTrigger( \"shipSpotted\" )
Wait(1.9)
RunToLocation( shokia, 2, 3450.24, -285.118, 267.019, 267.956 )


-- COPY STARTS HERE
--
local relativeMover = shokia -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

shokia:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))
shokia:PlayLoopingFullBodyAnim(Animations.KneelLoop)

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
226	"Jade Forest - Horde Intro Scene - Clone - JSB"	"
WaitForTrigger( \"rivettTalk\" )

Wait(16)

RunToLocation( clone, 1, 3449.42, -286.845, 266.9, 276.345 )


-- COPY STARTS HERE
--
local relativeMover = clone -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )

clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

WaitForTrigger( \"zeppelinCrash\" )

RunToLocation( clone, 400, 3168.19, -429.932, 246.441, 213 )
clone:PlayLoopingFullBodyAnim(Animations.FlyFall)
clone:FollowPath( 3246, 3 )

Wait( 2.5 )

scene:SetCamera(402, 0, nil, nil)

Wait( 0.5 )

scene:SetCamera(0, 0, nil, nil)"	0	0
228	"Jade Forest - Horde Intro Scene - Zeppelin Cannon01 - JSB"	"zeppelinCannon01:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship

WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )


--
-- COPY STOPS HERE
--

"	0	0
229	"Jade Forest - Horde Intro Scene - Zeppelin Cannon02 - JSB"	"zeppelinCannon02:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
--relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

"	0	0
230	"Jade Forest - Horde Intro Scene - Zeppelin Cannon03 - JSB"	"zeppelinCannon03:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
--relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

"	0	0
231	"Jade Forest - Horde Intro Scene - Zeppelin Cannon04 - JSB"	"zeppelinCannon04:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
--relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--
"	0	0
232	"Jade Forest - Horde Intro Scene - Cannons Fire - JSB"	"
WaitForTrigger( \"zeppelinMove\" )
Wait( 2.5 ) 
CastSpellAtActor( zeppelinCannon01, zeppelinTarget02,120673 )
Wait( 0.6 ) 
CastSpellAtActor( zeppelinCannon02, zeppelinTarget01,120673 )
Wait( 0.8 ) 
CastSpellAtActor( zeppelinCannon03, zeppelinTarget03,120673 )
Wait( 0.5 ) 
CastSpellAtActor( zeppelinCannon04, zeppelinTarget04,120682 )

Wait( 1.26 )

CastSpellAtActor( cannon01, shipTarget01,120705 )
CastSpellAtActor( cannon01, shipTarget01,122262 )
Wait( 0.3 ) 
CastSpellAtActor( cannon02, shipTarget02,120705 )
CastSpellAtActor( cannon02, shipTarget02,122262 )
Wait( 0.3 ) 
CastSpellAtActor( cannon03, shipTarget03,120705 )
CastSpellAtActor( cannon03, shipTarget03,122262 )
Wait( 0.3 ) 
CastSpellAtActor( cannon04, shipTarget04,120705 )
CastSpellAtActor( cannon04, shipTarget04,122262 )

"	0	0
233	"Jade Forest - Horde Intro Scene - Init 02 - JSB"	"-- spawn Zeppelin Cannon Targets
local zeppelinTargetBunnyCreatureID = 61997
zeppelinTarget01 = SpawnActor( zeppelinTargetBunnyCreatureID, 3609.44, -593.548, 0, 326.921, 1.0, false )
zeppelinTarget02 = SpawnActor( zeppelinTargetBunnyCreatureID, 3676.5, -557.003, 0, 251.096, 1.0, false )
zeppelinTarget03 = SpawnActor( zeppelinTargetBunnyCreatureID, 3593.46, -636.814, 0, 303.071, 1.0, false )
zeppelinTarget04 = SpawnActor( zeppelinTargetBunnyCreatureID, 3633.02, -648.158, 16.8191, 333.671, 1.0, false )

-- spawn Ship Cannon Targets
local shipTargetBunnyCreatureID = 61997
shipTarget01 = SpawnActor( shipTargetBunnyCreatureID, 3479.28, -207.399, 284.855, 283.35, 1.0, false )
shipTarget02 = SpawnActor( shipTargetBunnyCreatureID, 3423.08, -246.839, 269.832, 283.825, 1.0, false )
shipTarget03 = SpawnActor( shipTargetBunnyCreatureID, 3417.72, -262.495, 268.646, 294.4, 1.0, false )
shipTarget04 = SpawnActor( shipTargetBunnyCreatureID, 3446.75, -291.758, 298.825, 307.425, 1.0, false )

-- spawn Ship Fire Bunnies
shipFire01 = SpawnActor( shipTargetBunnyCreatureID, 3645.32, -629.195, 12.1322, 139.734, 1.0, false )
shipFire02 = SpawnActor( shipTargetBunnyCreatureID, 3653.98, -615.715, 8.04192, 146.709, 1.0, false )
shipFire03 = SpawnActor( shipTargetBunnyCreatureID, 3658.26, -610.236, 18.7299, 141.309, 1.0, false )

-- spawn Cannons
local cannonModel = \"CREATURE\\ALLIANCEBRASSCANNON\\AllianceBrassCannon.M2\"
cannon01 = SpawnModelActor( cannonModel, 3443.82, -935.37, 12.12, 144.899, 1, false ) -- ( modelFileName, x, y, z, facing, scale, snapToGround )
cannon02 = SpawnModelActor( cannonModel, 3446.112, -932.104, 11.9, 285.375, 1, false )
cannon03 = SpawnModelActor( cannonModel, 3448.505, -928.838, 11.75, 312.15, 1, false )
cannon04 = SpawnModelActor( cannonModel, 3451.00, -925.57, 11.652, 143.099, 1, false )

-- spawn zeppelin fire
local zeppelinFireCreatureID = 61997
zeppelinFire = SpawnActor( zeppelinFireCreatureID, 3310.88, -336.348, 279, 143, 5, false )

-- spawn zeppelin fire 01
local zeppelinFireCreatureID = 61997
zeppelinFire01 = SpawnActor( zeppelinFireCreatureID, 3302.44, -334.681, 278.071, 325.581, 1, false )

-- spawn zeppelin fire 02
local zeppelinFireCreatureID = 61997
zeppelinFire02 = SpawnActor( zeppelinFireCreatureID, 3308.47, -332.332, 273.305, 313.882, 1, false )

-- spawn zeppelin fire 03
local zeppelinFireCreatureID = 61997
zeppelinFire03 = SpawnActor( zeppelinFireCreatureID, 3292.96, -344.628, 282.832, 27.9496, 1, false )


-- spawn crash bunny
local crashbunnyCreatureID = 61997
crashBunny = SpawnActor( crashbunnyCreatureID, 3172.29, -422.428, 239.355, 203.225, 1, false )

-- spawn Alliance Crewman 01
local allianceCrewmanCreatureID = 62634
allianceCrewman01 = SpawnActor( allianceCrewmanCreatureID, 3448.72, -936.778, 12.8252, 133.159, 1.0, false )

-- spawn Alliance Crewman 02
local allianceCrewmanCreatureID = 62634
allianceCrewman02 = SpawnActor( allianceCrewmanCreatureID, 3457.39, -935.658, 12.1602, 143.644, 1.0, false )

-- spawn Alliance Crewman 03
local allianceCrewmanCreatureID = 62634
allianceCrewman03 = SpawnActor( allianceCrewmanCreatureID, 3453.5, -941.767, 12.6392, 88.2943, 1.0, false )

-- spawn Alliance Crewman 04
local allianceCrewmanCreatureID = 62634
allianceCrewman04 = SpawnActor( allianceCrewmanCreatureID, 3464.04, -922.214, 6.76588, 150.169, 1.0, false )

-- spawn Alliance Crewman 05
local allianceCrewmanCreatureID = 62634
allianceCrewman05 = SpawnActor( allianceCrewmanCreatureID, 3470.05, -911.329, 17.9969, 128.254, 1.0, false )

"	0	0
234	"Jade Forest - Horde Intro Scene - Cannon03 - JSB"	"cannon03:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do


WaitForTrigger( \"zeppelinMove\" )
Wait( 15 )


cannon03:Despawn()"	0	0
235	"Jade Forest - Horde Intro Scene - Cannon04 - JSB"	"cannon04:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )
Wait( 15 )


cannon04:Despawn()"	0	0
236	"Lorewalker Story - S1: Grummle - Fog Bunnies - ZTO DEPRECATED"	"-- DEPRECATED
-- local actorAuraVisual = fogbunny1:PlaySpellStateVisual(24841) --Cast Actor Visual
-- local actorAuraVisual = fogbunny2:PlaySpellStateVisual(24841) --Cast Actor Visual
-- local actorAuraVisual = fogbunny3:PlaySpellStateVisual(24841) --Cast Actor Visual

-- WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
-- FadeOut(fogbunny1, 1)
-- FadeOut(fogbunny2, 1)
-- FadeOut(fogbunny3, 1)
-- fogbunny1: Despawn()
-- fogbunny2: Despawn()
-- fogbunny3: Despawn()"	0	0
237	"Jade Forest - Horde Intro Scene - Ship Cannon Target - JSB"	"
WaitForTrigger( \"zeppelinMove\" )

Wait( 11 )

-- local instance = zeppelinTarget04:PlaySpellStateVisual(19388)
local instance = zeppelinTarget04:PlaySpellStateVisual(25187)

Wait( 4 )

local instance = shipFire01:PlaySpellStateVisual(25187)
local instance = shipFire02:PlaySpellStateVisual(25187)
local instance = shipFire03:PlaySpellStateVisual(25187)
"	0	0
238	"Jade Forest - Horde Intro Scene - Cannons Target 01 - Zeppelin - JSB"	"-- COPY STARTS HERE
--
local relativeMover = shipTarget01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
239	"Jade Forest - Horde Intro Scene - Cannons Target 02 - Zeppelin - JSB"	"-- COPY STARTS HERE
--
local relativeMover = shipTarget02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
240	"Jade Forest - Horde Intro Scene - Cannons Target 03 - Zeppelin - JSB"	"-- COPY STARTS HERE
--
local relativeMover = shipTarget03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
241	"Jade Forest - Horde Intro Scene - Cannons Target 04 - Zeppelin - JSB"	"-- COPY STARTS HERE
--
local relativeMover = shipTarget04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinMove\" )
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()
"	0	0
242	"Lorewalker Story - S1: Grummle - grummlePacker1 - ZTO"	"-- Wait until called
WaitForTrigger(\"addGrummle1\")

PlayLoopingSplitBodyAnim( grummlePacker1, Animations.Run )
FadeIn( grummlePacker1, 1 )
local actorAuraVisual = grummlePacker1:PlaySpellStateVisual(24803) --Cast Actor Visual



-- Wait until tree hits lead grummle, then cross and exit stage right
WaitForTrigger(\"treeSmack\")
RunToLocation( grummlePacker1, 7, 1443.38, 362.09, 550.221  )
FadeOut( grummlePacker1, 1)
grummlePacker1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummlePacker1: Despawn()"	0	0
243	"Lorewalker Story - S1: Grummle - grummlePacker2 - ZTO"	"-- Wait until called
WaitForTrigger(\"addGrummle2\")

PlayLoopingSplitBodyAnim( grummlePacker2, Animations.Run )
FadeIn( grummlePacker2, 1 )
local actorAuraVisual = grummlePacker2:PlaySpellStateVisual(24803) --Cast Actor Visual



-- Wait until tree hits lead grummle, then cross and exit stage right
WaitForTrigger(\"treeSmack\")
RunToLocation( grummlePacker2, 7, 1446.07, 358.825, 550.221  )
FadeOut( grummlePacker2, 1)
grummlePacker2:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummlePacker2: Despawn()"	0	0
244	"Lorewalker Story - S1: Grummle - Init - Scene 4 Actors - ZTO"	"-- Spawn Pack 1 group
lamppostID = 62032
lamppost1 = SpawnActor(lamppostID, 1454.04, 369.326, 550.221, 268.352 ) -- Lamppost spawn stage left
FadeOut( lamppost1, 0 )

-- Spawn Pandaren group
richPandarenID = 62053
richPandaren1 = SpawnActor(richPandarenID, 1445.58, 361.45, 550.222, 71.41 ) -- Spawns downstage right
FadeOut( richPandaren1, 0 )

-- Spawn Grummle Vendors
grummleVendor1 = SpawnActor(grummleID, 1448.32, 363.899, 550.222, 207.985 ) -- Spawns downstage left
grummleVendor2 = SpawnActor(grummleBagID, 1448.64, 360.894, 550.221, 145.9) -- Spawn second vendor
FadeOut( grummleVendor1, 0 )
FadeOut( grummleVendor2, 0 )

-- Spawn Yak
yakID = 62272
whiteyak = SpawnActor(yakID, 1450.86, 362.875, 550.222, 188.409 ) -- Spawns downstage left
FadeOut( whiteyak, 0 )"	0	0
245	"Lorewalker Story - S1: Grummle - Scene 1 - lamppost1 - ZTO"	"-- Wait until scene 3 begins
WaitForTrigger(\"callSmack\")

-- Kneel before slavemaster and truck from stage left to stage right
FadeIn( lamppost1, 1)
local actorAuraVisual = lamppost1:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation( lamppost1, 4, 1460.04, 374.389, 550.222 )
SendTrigger(\"treeSmack\")


-- Kneel before slavemaster and truck from stage left to stage right
WaitForTrigger(\"clearTree\")
FadeOut( lamppost1, 1)
lamppost1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
lamppost1: Despawn()"	0	0
246	"PetBattle Template - Custom Turn"	"print(\"PetBattle: Custom Turn Script Template\")

function TemplateCustomTurn(turn)
	print(\"PetBattle: Start Custom Turn Template\")

	for index, effectGroup in pairs(turn.effects) do

		-- process all the effects in this turn
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end

	end

	print(\"PetBattle: End Custom Turn Template\")
end
"	0	0
247	"PetBattle Template - Custom Effect"	"print(\"PetBattle: Custom Effect Script Template\")

function TemplateCustomEffect(effectGroup)
	print(\"PetBattle: Start Custom Effect Template\")

	for index, effectResult in pairs(effectGroup.results) do

		StartEffectProcessing(effectResult)
		
		ProcessRoundResult(effectResult)
		
		SignalEffectProcessed()

		if (effectResult.procGroup) then
			ProcessRoundTurnGroup(effectResult.procGroup)
		end

	end

	print(\"PetBattle: End Custom Effect Template\")
end
"	0	0
248	"Lorewalker Story - S1: Grummle - Scene 4 - stinkyPandaren - ZTO"	"-- Wait until called by GrummleMainBag
--WaitForTrigger(\"scene4Trigger\")

-- Fade in on command, beckon at little grummle
--FadeIn( stinkyPandaren1, 1)
--local actorAuraVisual = stinkyPandaren1:PlaySpellStateVisual(24803) --Cast Actor Visual
--local actorSmokeVisual = stinkyPandaren1:PlaySpellStateVisual(13960) --Cast Smoke Visual
--stinkyPandaren1:PlayLoopingFullBodyAnim(Animations.EmoteTalk)


-- Beckon grummle over
--WaitForTrigger(\"endScene4\")
--FadeOut( stinkyPandaren1, 1)
--stinkyPandaren1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
--stinkyPandaren1:ClearSpellStateVisual(13960, actorSmokeVisual) --Clear Actor Visual

--Wait(5)
--stinkyPandaren1: Despawn()
"	0	0
249	"Lorewalker Story - S1: Grummle - Scene 4 - richPandaren - ZTO"	"-- Wait until called by GrummleMainBag
WaitForTrigger(\"scene4Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( light_cl, 2 )
FadeIn( richPandaren1, 1)
local actorAuraVisual = richPandaren1:PlaySpellStateVisual(24803) --Cast Actor Visual
richPandaren1: PlayLoopingFullBodyAnim(Animations.EmoteTalkExclamation)


-- Beckon grummle over
WaitForTrigger(\"scene5Trigger\")
PlayOneShotSplitBodyAnim( grummleMain, Animations.EmotePoint )
Wait(3)

FadeOut(light_cl, 2)
FadeOut( richPandaren1, 1)
richPandaren1: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
richPandaren1: Despawn()"	0	0
250	"Stormstout Brewery - Cinematic Framework - Spawning"	"--
-- SpawnModelActor( modelFileName, pointsPathID, snapToGround [=true] )
--   Spawn an uninteractible actor
--
function SpawnModelActorsAtPoints( modelFileName, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.model = modelFileName
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	return actors

end
"	0	0
251	"Stormstout Brewery - Cinematic Framework"	"-- default all cinematics to non relative
scene:SetRelativeCoords(false) -- set to absolute worlld coords

function Wait( time )
	scene:WaitTimer( time )
end

--
-- SpawnActor( creatureID, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnActor( creatureID, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local spawnPos = Vector:New( x, y, z )
	local spawnTransform = Transform:New( spawnPos, facing )
	createData = ActorCreateData:New( creatureID, spawnTransform, scale )
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actor = scene:SpawnActor( createData )
	actor:SetInteractible( false )
	return actor

end

--
-- SpawnModelActor( modelFileName, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnModelActor( modelFileName, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local pos = Vector:New( x, y, z )
	local transform = Transform:New( pos, facing )
	createData = ActorCreateData:NewModel( \"dummy\", modelFileName, transform, scale )
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actor = scene:SpawnActor( createData )
	return actor

end


--
-- RunToLocation( actor, speed, x, y, z, facing [default = direction of travel] )
--   Run actor to location at speed
--
function RunToLocation( actor, speed, x, y, z, facing )

	local destPos = Vector:New(x, y, z)
	
	local currPos = actor:GetPosition()
	local offset = currPos - destPos
	local distance = offset:Magnitude()

	local travelTime = distance / speed
	
	actor:WaitMoveToAbs( destPos, travelTime )

	if facing then
		actor:SetFacing( facing )
	end

end


--
-- CastSpellAtActor( caster, target, spellID, faceTarget [default = false] )
--   Cast a spell at the target actor
--
function CastSpellAtActor( caster, target, spellID, faceTarget )

	-- turn to face the target if required
	if faceTarget and faceTarget == true then
		caster:SetFacingToTarget( target, Vector:New() )
		scene:WaitTimer( 0.75 )
	end

	caster:CastSpell( spellID, target )
	
	if faceTarget and faceTarget == true then
		caster:ClearFacing()
	end

end

--
-- PlayLoopingSplitBodyAnim( actor, anim )
--   Play a looping animation on the actor
--
function PlayLoopingSplitBodyAnim( actor, anim )

	actor:PlayLoopingSplitBodyAnim( anim )

end

--
-- StopLoopingSplitBodyAnim( actor )
--   Stop playing a looping animation on the actor
--
function StopLoopingSplitBodyAnim( actor )

	actor:PlayLoopingSplitBodyAnim( anim )

end

--
-- PlayOneShotSplitBodyAnim( actor, anim )
--   Play a looping animation on the actor
--
function PlayOneShotSplitBodyAnim( actor, anim )

	actor:PlayOneShotSplitBodyAnim( anim )

end

--
-- StopLoopingSplitBodyAnim( actor )
--   Stop the looping anim kit currently playing on the actor
--
function StopLoopingSplitBodyAnim( actor )

	actor:StopAnimKit( AnimKits.LoopingSplitBody )

end

--
-- FadeOut( actor, fadeTime [ default = 2 ] )
--   Fade the actor out over fadeTime seconds
--
function FadeOut( actor, fadeTime )

	if not fadeTime then
		fadeTime = 2
	end

	actor:Fade( 0, fadeTime )

end

--
-- FadeIn( actor, fadeTime [ default = 0.5 ] )
--   Fade the actor in over fadeTime seconds
--
function FadeIn( actor, fadeTime )

	if not fadeTime then
		fadeTime = 0.5
	end

	actor:Fade( 1, fadeTime )

end

Triggers = { }
function SendTrigger( triggerName )
	Triggers[triggerName] = true
end

function WaitForTrigger( triggerName )

	local waitCondition = function()
		return (Triggers[triggerName] == true)
	end
	scene:WaitCondition(waitCondition)
end
"	0	0
252	"Siege of Niuzao Temple - The Mantid Army - Init - SLG"	"-- spawn flyers 1
local flyerCreatureID = 62091
flyer00 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 168.81, 315.917, false )
flyer01 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 178.81, 315.917, false )
flyer02 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 188.81, 315.917, false )
flyer03 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 198.81, 315.917, false )
flyer04 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 208.81, 315.917, false )


flyer10 = SpawnActor( flyerCreatureID, 1851.98, 5284.56, 168.81, 315.917, false )
flyer11 = SpawnActor( flyerCreatureID, 1851.98, 5284.56, 178.81, 315.917, false )
flyer12 = SpawnActor( flyerCreatureID, 1851.98, 5284.56, 188.81, 315.917, false )
flyer13 = SpawnActor( flyerCreatureID, 1851.98, 5284.56, 198.81, 315.917, false )
flyer14 = SpawnActor( flyerCreatureID, 1851.98, 5284.56, 208.81, 315.917, false )

flyer20 = SpawnActor( flyerCreatureID, 1861.37, 5291.57, 168.81, 315.917, false )
flyer21 = SpawnActor( flyerCreatureID, 1861.37, 5291.57, 178.81, 315.917, false )
flyer22 = SpawnActor( flyerCreatureID, 1861.37, 5291.57, 188.81, 315.917, false )
flyer23 = SpawnActor( flyerCreatureID, 1861.37, 5291.57, 198.81, 315.917, false )
flyer24 = SpawnActor( flyerCreatureID, 1861.37, 5291.57, 208.81, 315.917, false )"	0	0
253	"Stormstout Brewery - Virmen Keg Scene - Init 1"	"-- spawn Virmen
local virmenCreatureID = 60205

virmen1 = SpawnActor( virmenCreatureID, -726, 1250, 165, 0, 1.0, false )
virmen2 = SpawnActor( virmenCreatureID, -728, 1250, 165, 10, 1.0, false )
virmen3 = SpawnActor( virmenCreatureID, -730, 1250, 165, 20, 1.0, false )
virmen4 = SpawnActor( virmenCreatureID, -732, 1250, 165, 30, 1.0, false )
virmen5 = SpawnActor( virmenCreatureID, -734, 1250, 165, 40, 1.0, false )
virmen6 = SpawnActor( virmenCreatureID, -736, 1250, 165, 50, 1.0, false )
virmen7 = SpawnActor( virmenCreatureID, -738, 1250, 165, 60, 1.0, false )
virmen8 = SpawnActor( virmenCreatureID, -724, 1250, 165, 70, 1.0, false )
virmen9 = SpawnActor( virmenCreatureID, -722, 1250, 165, 80, 1.0, false )
virmen10 = SpawnActor( virmenCreatureID, -720, 1250, 165, 90, 1.0, false )
virmen11 = SpawnActor( virmenCreatureID, -718, 1250, 165, 100, 1.0, false )

virmen12 = SpawnActor( virmenCreatureID, -727, 1252, 165, 110, 1.0, false )
virmen13 = SpawnActor( virmenCreatureID, -727, 1254, 165, 120, 1.0, false )
virmen14 = SpawnActor( virmenCreatureID, -727, 1256, 165, 130, 1.0, false )
virmen15 = SpawnActor( virmenCreatureID, -727, 1258, 165, 140, 1.0, false )
virmen16 = SpawnActor( virmenCreatureID, -727, 1260, 165, 150, 1.0, false )
virmen17 = SpawnActor( virmenCreatureID, -727, 1248, 165, 160, 1.0, false )
virmen18 = SpawnActor( virmenCreatureID, -727, 1246, 165, 170, 1.0, false )
virmen19 = SpawnActor( virmenCreatureID, -727, 1244, 165, 180, 1.0, false )
virmen20 = SpawnActor( virmenCreatureID, -727, 1242, 165, 190, 1.0, false )
virmen21 = SpawnActor( virmenCreatureID, -727, 1240, 165, 200, 1.0, false )

virmen22 = SpawnActor( virmenCreatureID, -729, 1252, 165, 210, 1.0, false )
virmen23 = SpawnActor( virmenCreatureID, -725, 1252, 165, 220, 1.0, false )
virmen24 = SpawnActor( virmenCreatureID, -723, 1252, 165, 230, 1.0, false )
virmen25 = SpawnActor( virmenCreatureID, -721, 1252, 165, 240, 1.0, false )
virmen26 = SpawnActor( virmenCreatureID, -731, 1252, 165, 250, 1.0, false )
virmen27 = SpawnActor( virmenCreatureID, -733, 1252, 165, 260, 1.0, false )
virmen28 = SpawnActor( virmenCreatureID, -735, 1252, 165, 270, 1.0, false )
virmen29 = SpawnActor( virmenCreatureID, -737, 1252, 165, 280, 1.0, false )
virmen30 = SpawnActor( virmenCreatureID, -719, 1252, 165, 290, 1.0, false )

virmen31 = SpawnActor( virmenCreatureID, -729, 1248, 165, 300, 1.0, false )
virmen32 = SpawnActor( virmenCreatureID, -725, 1248, 165, 310, 1.0, false )
virmen33 = SpawnActor( virmenCreatureID, -723, 1248, 165, 320, 1.0, false )
virmen34 = SpawnActor( virmenCreatureID, -721, 1248, 165, 330, 1.0, false )
virmen35 = SpawnActor( virmenCreatureID, -731, 1248, 165, 340, 1.0, false )
virmen36 = SpawnActor( virmenCreatureID, -733, 1248, 165, 350, 1.0, false )
virmen37 = SpawnActor( virmenCreatureID, -735, 1248, 165, 0, 1.0, false )
virmen38 = SpawnActor( virmenCreatureID, -737, 1248, 165, 10, 1.0, false )
virmen39 = SpawnActor( virmenCreatureID, -719, 1248, 165, 20, 1.0, false )

virmen40 = SpawnActor( virmenCreatureID, -728, 1246, 165, 30, 1.0, false )
virmen41 = SpawnActor( virmenCreatureID, -724, 1246, 165, 40, 1.0, false )
virmen42 = SpawnActor( virmenCreatureID, -722, 1246, 165, 50, 1.0, false )
virmen43 = SpawnActor( virmenCreatureID, -720, 1246, 165, 60, 1.0, false )
virmen44 = SpawnActor( virmenCreatureID, -730, 1246, 165, 70, 1.0, false )
virmen45 = SpawnActor( virmenCreatureID, -732, 1246, 165, 80, 1.0, false )
virmen46 = SpawnActor( virmenCreatureID, -734, 1246, 165, 90, 1.0, false )
virmen47 = SpawnActor( virmenCreatureID, -736, 1246, 165, 100, 1.0, false )
virmen48 = SpawnActor( virmenCreatureID, -718, 1246, 165, 120, 1.0, false )
"	0	0
254	"Jade Forest - Horde Intro Scene - Celebration - JSB"	"
WaitForTrigger( \"shipMove\" )

Wait( 4 )
nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)
Wait( 2.5 )
nazgrim:PlayOneShotFullBodyAnim(Animations.EmoteRoar)

shokia:StopLoopingFullBodyAnim()
shokia:PlayLoopingFullBodyAnim(Animations.Stand)

Wait( 0.5 )

shokia:PlayOneShotFullBodyAnim(Animations.EmoteCheer)
clone:PlayOneShotFullBodyAnim(Animations.EmoteCheer)
rivett:StopLoopingFullBodyAnim()
vanguard01:StopLoopingFullBodyAnim()
gorrok:StopLoopingFullBodyAnim()

Wait( 0.5 )

rivett:PlayOneShotFullBodyAnim(Animations.EmoteCheer)
vanguard01:PlayOneShotFullBodyAnim(Animations.EmoteApplaud)
gorrok:PlayOneShotFullBodyAnim(Animations.EmoteCheer)
snuff:PlayOneShotFullBodyAnim(Animations.EmoteDance)
vanguard02:StopLoopingFullBodyAnim()
vanguard03:StopLoopingFullBodyAnim()
kiryn:StopLoopingFullBodyAnim()
zinjun:StopLoopingFullBodyAnim()

Wait( 0.25 )
kiryn:PlayOneShotFullBodyAnim(Animations.EmoteCheer)
zinjun:PlayOneShotFullBodyAnim(Animations.EmotePoint)


-- more cheers

WaitForTrigger( \"crashMove\" )
kiryn:Despawn()
zinjun:Despawn()
vanguard01:Despawn()
vanguard02:Despawn()
vanguard03:Despawn()
snuff:Despawn()
gorrok:Despawn()
rivett:Despawn()
nazgrim:Despawn()
shokia:Despawn()

"	0	0
255	"Stormstout Brewery - Virmen Keg Scene - Init 2"	"-- spawn Virmen
local virmenCreatureID = 60205

virmen49 = SpawnActor( virmenCreatureID, -729, 1244, 165, 130, 1.0, false )
virmen50 = SpawnActor( virmenCreatureID, -725, 1244, 165, 140, 1.0, false )
virmen51 = SpawnActor( virmenCreatureID, -723, 1244, 165, 150, 1.0, false )
virmen52 = SpawnActor( virmenCreatureID, -721, 1244, 165, 160, 1.0, false )
virmen53 = SpawnActor( virmenCreatureID, -731, 1244, 165, 170, 1.0, false )
virmen54 = SpawnActor( virmenCreatureID, -733, 1244, 165, 180, 1.0, false )
virmen55 = SpawnActor( virmenCreatureID, -735, 1244, 165, 190, 1.0, false )
virmen56 = SpawnActor( virmenCreatureID, -737, 1244, 165, 200, 1.0, false )
virmen57 = SpawnActor( virmenCreatureID, -719, 1244, 165, 210, 1.0, false )

virmen58 = SpawnActor( virmenCreatureID, -728, 1242, 165, 210, 1.0, false )
virmen59 = SpawnActor( virmenCreatureID, -724, 1242, 165, 220, 1.0, false )
virmen60 = SpawnActor( virmenCreatureID, -722, 1242, 165, 230, 1.0, false )
virmen61 = SpawnActor( virmenCreatureID, -720, 1242, 165, 240, 1.0, false )
virmen62 = SpawnActor( virmenCreatureID, -730, 1242, 165, 250, 1.0, false )
virmen63 = SpawnActor( virmenCreatureID, -732, 1242, 165, 260, 1.0, false )
virmen64 = SpawnActor( virmenCreatureID, -734, 1242, 165, 270, 1.0, false )
virmen65 = SpawnActor( virmenCreatureID, -736, 1242, 165, 280, 1.0, false )

virmen66 = SpawnActor( virmenCreatureID, -729, 1240, 165, 290, 1.0, false )
virmen67 = SpawnActor( virmenCreatureID, -725, 1240, 165, 300, 1.0, false )
virmen68 = SpawnActor( virmenCreatureID, -731, 1240, 165, 310, 1.0, false )
virmen69 = SpawnActor( virmenCreatureID, -733, 1240, 165, 320, 1.0, false )
virmen70 = SpawnActor( virmenCreatureID, -735, 1240, 165, 330, 1.0, false )

virmen71 = SpawnActor( virmenCreatureID, -729, 1254, 165, 340, 1.0, false )
virmen72 = SpawnActor( virmenCreatureID, -725, 1254, 165, 350, 1.0, false )
virmen73 = SpawnActor( virmenCreatureID, -723, 1254, 165, 0, 1.0, false )
virmen74 = SpawnActor( virmenCreatureID, -721, 1254, 165, 10, 1.0, false )
virmen75 = SpawnActor( virmenCreatureID, -731, 1254, 165, 20, 1.0, false )
virmen76 = SpawnActor( virmenCreatureID, -733, 1254, 165, 30, 1.0, false )
virmen77 = SpawnActor( virmenCreatureID, -735, 1254, 165, 40, 1.0, false )
virmen78 = SpawnActor( virmenCreatureID, -737, 1254, 165, 50, 1.0, false )
virmen79 = SpawnActor( virmenCreatureID, -719, 1254, 165, 60, 1.0, false )

virmen80 = SpawnActor( virmenCreatureID, -728, 1256, 165, 70, 1.0, false )
virmen81 = SpawnActor( virmenCreatureID, -724, 1256, 165, 80, 1.0, false )
virmen82 = SpawnActor( virmenCreatureID, -722, 1256, 165, 90, 1.0, false )
virmen83 = SpawnActor( virmenCreatureID, -720, 1256, 165, 100, 1.0, false )
virmen84 = SpawnActor( virmenCreatureID, -730, 1256, 165, 110, 1.0, false )
virmen85 = SpawnActor( virmenCreatureID, -732, 1256, 165, 120, 1.0, false )
virmen86 = SpawnActor( virmenCreatureID, -734, 1256, 165, 130, 1.0, false )
virmen87 = SpawnActor( virmenCreatureID, -736, 1256, 165, 140, 1.0, false )
"	0	0
256	"Stormstout Brewery - Virmen Keg Scene - Init 3"	"local virmenCreatureID = 60205

virmen88 = SpawnActor( virmenCreatureID, -729, 1258, 165, 150, 1.0, false )
virmen89 = SpawnActor( virmenCreatureID, -725, 1258, 165, 160, 1.0, false )
virmen90 = SpawnActor( virmenCreatureID, -723, 1258, 165, 170, 1.0, false )

virmen91 = SpawnActor( virmenCreatureID, -731, 1258, 165, 180, 1.0, false )
virmen92 = SpawnActor( virmenCreatureID, -733, 1258, 165, 190, 1.0, false )
virmen93 = SpawnActor( virmenCreatureID, -735, 1258, 165, 200, 1.0, false )
virmen94 = SpawnActor( virmenCreatureID, -737, 1258, 165, 300, 1.0, false )

virmen95 = SpawnActor( virmenCreatureID, -728, 1260, 165, 210, 1.0, false )
virmen96 = SpawnActor( virmenCreatureID, -726, 1260, 165, 230, 1.0, false )
virmen97 = SpawnActor( virmenCreatureID, -730, 1260, 165, 250, 1.0, false )
virmen98 = SpawnActor( virmenCreatureID, -732, 1260, 165, 260, 1.0, false )
virmen99 = SpawnActor( virmenCreatureID, -734, 1260, 165, 270, 1.0, false )
virmen100 = SpawnActor( virmenCreatureID, -736, 1260, 165, 280, 1.0, false )
virmen101 = SpawnActor( virmenCreatureID, -724, 1258, 165, 240, 1.0, false )

Wait(604800)"	0	0
257	"Siege of Niuzao Temple - The Mantid Army - Master - SLG"	"-- Make the flyers play their flying anims
flyer00:PlayLoopingAnimKit(1380)
flyer01:PlayLoopingAnimKit(1380)
flyer02:PlayLoopingAnimKit(1380)
flyer03:PlayLoopingAnimKit(1380)
flyer04:PlayLoopingAnimKit(1380)

flyer10:PlayLoopingAnimKit(1380)
flyer11:PlayLoopingAnimKit(1380)
flyer12:PlayLoopingAnimKit(1380)
flyer13:PlayLoopingAnimKit(1380)
flyer14:PlayLoopingAnimKit(1380)

flyer20:PlayLoopingAnimKit(1380)
flyer21:PlayLoopingAnimKit(1380)
flyer22:PlayLoopingAnimKit(1380)
flyer23:PlayLoopingAnimKit(1380)
flyer24:PlayLoopingAnimKit(1380)

Wait( 10 )"	0	0
258	"Jade Forest - Horde Intro Scene - Zeppelin Fires - JSB"	"zeppelinFire:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))
zeppelinFire01:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))
zeppelinFire02:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))

WaitForTrigger( \"zeppelinMove\" )

Wait( 25 )


local instance = zeppelinFire:PlaySpellStateVisual(25195)
local instance = zeppelinFire01:PlaySpellStateVisual(25196)
local instance = zeppelinFire02:PlaySpellStateVisual(25196)

Wait( 6 )

local instance = zeppelinFire01:PlaySpellStateVisual(25195)

Wait( 2 )

local instance = zeppelinFire02:PlaySpellStateVisual(25195)


-- Wait( 5 )



WaitForTrigger( \"crashMove\" )
local instance = zeppelinFire:PlaySpellStateVisual(19335)
local instance = zeppelinFire03:PlaySpellStateVisual(9520)
local instance = zeppelinFire03:PlaySpellStateVisual(19335)

zeppelinFire:FollowPath( 3120, 10 )
zeppelinFire03:FollowPath( 3245, 10 )
"	0	0
259	"Jade Forest - Horde Intro Scene - CRASH - JSB"	"
WaitForTrigger( \"zeppelinCrash\" )

local instance = crashBunny:PlaySpellStateVisual(25201)

local shakeOrigin01 = Vector:New(3168.19, -429.932, 246.441)
shakeX = scene:AddCameraShake( 214, shakeOrigin01 )
shakeY = scene:AddCameraShake( 215, shakeOrigin01 )
shakeZ = scene:AddCameraShake( 216, shakeOrigin01 )
"	0	0
276	"Darren\'s Test 4000+"	"print(\"sub script 1!!\")
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
"	0	277
277	"[1] Darren\'s Test 4000+"	"--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

print(\"sub script 2 :(\")
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
"	276	278
278	"[2] Darren\'s Test 4000+"	"--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

print(\"sub script 3\")
"	276	0
281	"Lorewalker Story - S1: Grummle - Init - Pre-scene Actors - ZTO"	"-- Spawn huge mogu head!!
moguFaceID = 62170
moguFace = SpawnActor( moguFaceID, 1460.83, 362.878, 550.222, 131.721, .5 ) -- Mogu Main Character
moguFace: PlayLoopingAnimKit( 2340 )
FadeOut( moguFace, 0 )"	0	0
282	"Lorewalker Story - S1: Grummle - MoguFace - ZTO"	"-- Bring on the mighty mogu face!
WaitForTrigger( \"Spawn Face\" )
FadeIn( moguFace, 2 )


--FadeOut( moguFace, 2)
WaitForTrigger( \"Spawn Mogu\" )
FadeOut( moguFace, 2 )
moguFace: Despawn()"	0	0
283	"Lorewalker Story - Stage Lights and Cho Setup - Init - ZTO"	"-- Spawn Stage Light bunnies
bunnyID = 62026
light_ul = SpawnActor( bunnyID, 1449.33, 358.926, 550.221, 317.347 )  -- Upstage Left bunny
light_uc = SpawnActor( bunnyID, 1457.57, 365.7, 550.221, 221.947 )  -- Upstage Center bunny
light_ur = SpawnActor( bunnyID, 1464.86, 372.255, 550.221, 130.822 )  -- Upstage Right bunny
light_cl = SpawnActor( bunnyID, 1446.53, 362.14, 550.222, 317.347 )  -- Center Left bunny
light_cc = SpawnActor( bunnyID, 1454.55, 369.578, 550.222, 221.947 )  -- Center Stage bunny
light_cr = SpawnActor( bunnyID, 1461.54, 376.063, 550.222, 130.822 )  -- Center Right bunny

-- Spawn Lorewalker Cho
lorewalkerChoID = 61897
lorewalker = SpawnActor( lorewalkerChoID, 1447.18, 371.453, 550.221, 93.5645 )  -- Lorewalker Cho spawns where the normal NPC is
PlayLoopingSplitBodyAnim( lorewalker, Animations.EmoteReadLoop  ) -- Need to find Read anim

-- Setup light
local actorAuraVisual = light_ul:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual
local actorAuraVisual = light_uc:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual
local actorAuraVisual = light_ur:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual
local actorAuraVisual = light_cl:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual
local actorAuraVisual = light_cc:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual
local actorAuraVisual = light_cr:PlaySpellStateVisual(24841) --Cast Stage Dressing Visual

-- Fade Out until called
FadeOut( light_ul,0 )
FadeOut( light_uc,0 )
FadeOut( light_ur,0 )
FadeOut( light_cl,0 )
FadeOut( light_cc,0 )
FadeOut( light_cr,0 )"	0	0
284	"Lorewalker Story - Stage Lights - UL - ZTO"	"-- Light - Upstage Left - When Called
WaitForTrigger( \"cueLight_UL\" )
FadeIn(light_ul, 2)


-- Fade out when call sent
WaitForTrigger( \"blackLight_UL\" )
FadeOut(light_ul, 2)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_ul, 1)
light_ul: Despawn()
"	0	0
285	"Lorewalker Story - Stage Lights - UC - ZTO"	"-- Light - Upstage Center - When Called
WaitForTrigger( \"cueLight_UC\" )
FadeIn(light_uc, 2)


-- Fade out when call sent
WaitForTrigger( \"blackLight_UC\" )
FadeOut(light_uc, 2)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_uc, 1)
light_uc: Despawn()
"	0	0
286	"Lorewalker Story - Stage Lights - UR - ZTO"	"-- Light - Upstage Right - When Called
WaitForTrigger( \"cueLight_UR\" )
FadeIn(light_ur, 2)


-- Fade out when call sent
WaitForTrigger( \"blackLight_UR\" )
FadeOut(light_ur, 2)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_ur, 1)
light_ur: Despawn()
"	0	0
287	"Lorewalker Story - Stage Lights - CC - ZTO"	"-- Light - Upstage Right - When Called
WaitForTrigger( \"cueLight_CC\" )
FadeIn(light_cc, 1)


-- Fade out when call sent
WaitForTrigger( \"blackLight_CC\" )
FadeOut(light_cc, 1)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_cc, 1)
light_cc: Despawn()
"	0	0
288	"Lorewalker Story - Stage Lights - CL - ZTO"	"-- Light - Center Left - When Called
WaitForTrigger( \"cueLight_CL\" )
FadeIn(light_cl, 1)


-- Fade out when call sent
WaitForTrigger( \"blackLight_CL\" )
FadeOut(light_cl, 1)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_cl, 1)
light_cl: Despawn()"	0	0
289	"Lorewalker Story - Stage Lights - CR - ZTO"	"-- Light - Center Left - When Called
WaitForTrigger( \"cueLight_CR\" )
FadeIn(light_cr, 1)


-- Fade out when call sent
WaitForTrigger( \"blackLight_CR\" )
FadeOut(light_cr, 1)

WaitForTrigger( \"endScene\" ) -- On clean up, despawn bunnies
FadeOut(light_cr, 1)
light_cr: Despawn()"	0	0
290	"Lorewalker Story - S1: Grummle - Lorewalker Cho - ZTO"	"--OnScene start

Wait (2)
lorewalker: StopLoopingSplitBodyAnim( Animations.EmoteReadLoop )
PlayOneShotSplitBodyAnim( lorewalker, Animations.EmoteBow )
lorewalker:BroadcastText(BroadcastType.Say, 61462)
Wait (2)
SendTrigger( \"Spawn Face\" )
RunToLocation( lorewalker, 2, 1449.42, 358.265, 550.221, 36.9958 )

SendTrigger( \"Spawn Mogu\" ) -- Bring in the mogu
SendTrigger( \"Spawn Troggs\" ) -- Bring in the troggs

--Cross to Center Stage in time for Grummle transform
RunToLocation( lorewalker, 2, 1457.44, 365.731, 550.221, 130.144 ) 


--Wait for GrummleTransform to happen
WaitForTrigger( \"grummleTransform\" )
Wait (3)
RunToLocation( lorewalker, 2, 1463.12, 371.442, 550.221, 130.144 ) --Cross to Stage right

--Cross to Center Stage in time for Grummle transform
Wait (3)
SendTrigger( \"smokingGrummle\" )
RunToLocation( lorewalker, 2, 1457.44, 365.731, 550.221, 130.144 ) 

--On Treesmack
WaitForTrigger( \"treeSmack\" )
Wait (3)
RunToLocation( lorewalker, 2, 1451.2, 366.019, 550.221, 104.938 ) 
SendTrigger( \"scene3Trigger\" )
Wait (9)

-- Done with War, queue merchants
SendTrigger( \"endScene3\" )
Wait (1)
SendTrigger( \"scene4Trigger\" )

-- Let the talking happen then trigger scene 5
Wait (7)
SendTrigger( \"scene5Trigger\" )

-- Wait for things to play out and then clear scene 4 and queue scene 6
Wait (12)
SendTrigger( \"endScene4\" )
SendTrigger( \"endScene5\" )
RunToLocation( lorewalker, 2, 1456.04, 367.276, 550.222, 133.746 )
SendTrigger( \"scene6Trigger\" )


--Kill scene 6
Wait (15)
SendTrigger( \"endScene6\" )


-- Clean up
--WaitForTrigger( \"endScene\" )
Wait (2)
SendTrigger( \"endScene\" )
RunToLocation( lorewalker, 2, 1447.18, 371.453, 550.221, 93.5645 )
lorewalker: Despawn()
light_ul: Despawn()
light_ur: Despawn()"	0	0
292	"Orgrimmar - MoP Horde Intro Scene - Init - JSB"	"
-- spawn zeppelin
local zeppelinModel = \"world\\expansion03\\doodads\\generic\\flying_horde_zeppelin.m2\"
--zeppelin = SpawnModelActor( zeppelinModel, 3444.23, -278.363, 284.752, 249.2335, 1.0, false )
local zeppelins = SpawnModelActorsAtPoints( zeppelinModel, 3131, false )
zeppelin = zeppelins[1]

-- spawn nazgrim
local nazgrimCreatureID = 61682
nazgrim = SpawnActor( nazgrimCreatureID, 1840.65, -4419.42, 135.233, 41, 1.0, false )

-- spawn gorrok
local gorrokCreatureID = 61846
gorrok = SpawnActor( gorrokCreatureID, 1842.06, -4408.59, 135.232, 317.414, 1.0, false )

-- spawn zin\'jun
local zinjunCreatureID = 61868
zinjun = SpawnActor( zinjunCreatureID, 1840.35, -4412.36, 135.233, 334.341, 1.0, false )

-- spawn snuff
local snuffCreatureID = 61869
snuff = SpawnActor( snuffCreatureID, 1839.86, -4415.26, 135.233, 332.626, 1.0, false )
snuff:PlayLoopingFullBodyAnim(Animations.SitGround)

-- spawn rivett
local rivettCreatureID = 61844
rivett = SpawnActor( rivettCreatureID, 1843.93, -4420.85, 135.233, 104.292, 1.0, false )


-- spawn kiryn
local kirynCreatureID = 61867
kiryn = SpawnActor( kirynCreatureID, 1847.05, -4419.12, 135.233, 9.03616, 1.0, false )


-- spawn shokia
local shokiaCreatureID = 61866
shokia = SpawnActor( shokiaCreatureID, 1848.93, -4419, 135.233, 192.74, 1.0, false )

-- spawn Vanguard01
local vanguard01CreatureID = 61845
vanguard01 = SpawnActor( vanguard01CreatureID, 1851.74, -4417.59, 135.232, 144.925, 1.0, false )

-- spawn Vanguard02
local vanguard02CreatureID = 61845
vanguard02 = SpawnActor( vanguard02CreatureID, 1851.41, -4411.51, 135.065, 225.698, 1.0, false )

-- spawn Vanguard03
local vanguard03CreatureID = 61845
vanguard03 = SpawnActor( vanguard03CreatureID, 1847.81, -4408.08, 135.067, 225.665, 1.0, false )

-- spawn clone
local cloneCreatureID = 61833
clone = SpawnActor( cloneCreatureID, 1843.04, -4417.14, 135.232, 224.772, 1.0, false )
"	0	0
293	"Lorewalker Story - S1: Grummle - grummleIncenseSniffer - ZTO"	"-- Wait until called
WaitForTrigger(\"smokingGrummle\")

PlayLoopingSplitBodyAnim( grummleIncenseSniffer, Animations.SitGround )
SendTrigger(\"cueLight_CL\")
FadeIn( grummleIncenseSniffer, 1 )
local actorAuraVisual = grummleIncenseSniffer:PlaySpellStateVisual(24803) --Cast Actor Visual

--Wait (8)



-- Wait until tree hits lead grummle, then cross and exit stage right
WaitForTrigger(\"treeSmack\")
--RunToLocation( grummleIncenseSniffer, 7, 1443.38, 362.09, 550.221  )
SendTrigger(\"blackLight_CL\")
FadeOut( grummleIncenseSniffer, 1)
grummleIncenseSniffer:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummleIncenseSniffer: Despawn()"	0	0
294	"Lorewalker Story - S1: Grummle - incense - ZTO"	"-- Wait until called
WaitForTrigger(\"smokingGrummle\")

PlayLoopingSplitBodyAnim( grummleIncenseSniffer, Animations.SitGround )
FadeIn( incense1, 1 )
Wait(1)
FadeIn( incense2, 1 )
Wait(1)
FadeIn( incense3, 1 )
Wait(1)
FadeIn( incense4, 1 )
Wait(1)


-- Wait until tree hits lead grummle, then cross and exit stage right
WaitForTrigger(\"treeSmack\")
--RunToLocation( grummleIncenseSniffer, 7, 1443.38, 362.09, 550.221  )
FadeOut( incense1, 1)
FadeOut( incense2, 1)
FadeOut( incense3, 1)
FadeOut( incense4, 1)

Wait(5)
incense1: Despawn()
incense2: Despawn()
incense3: Despawn()
incense4: Despawn()"	0	0
295	"Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer1 - ZTO"	"-- Wait until scene 3 begins
WaitForTrigger(\"scene3Trigger\")

-- Cheer for the liberation
FadeIn( grummleCheer1, 1)
local actorAuraVisual = grummleCheer1:PlaySpellStateVisual(24803) --Cast Actor Visual
Wait(1)
PlayOneShotSplitBodyAnim( grummleCheer1, Animations.BattleRoar )
Wait(1)
PlayOneShotSplitBodyAnim( grummleCheer3, Animations.BattleRoar )
Wait(1)
PlayOneShotSplitBodyAnim( grummleCheer2, Animations.BattleRoar )
Wait(1)
PlayOneShotSplitBodyAnim( grummleCheer4, Animations.BattleRoar )

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( grummleCheer1, 1)
grummleCheer1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummleCheer1: Despawn()"	0	0
296	"Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer1 - ZTO"	"-- Wait until scene 3 begins
WaitForTrigger(\"scene3Trigger\")

-- Cheer for the liberation
FadeIn( grummleCheer2, 1)
local actorAuraVisual = grummleCheer2:PlaySpellStateVisual(24803) --Cast Actor Visual

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( grummleCheer2, 1)
grummleCheer2:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummleCheer2: Despawn()"	0	0
297	"Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer3 - ZTO"	"-- Wait until scene 3 begins
WaitForTrigger(\"scene3Trigger\")

-- Cheer for the liberation
FadeIn( grummleCheer3, 1)
local actorAuraVisual = grummleCheer3:PlaySpellStateVisual(24803) --Cast Actor Visual

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( grummleCheer3, 1)
grummleCheer3:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummleCheer3: Despawn()"	0	0
298	"Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer4 - ZTO"	"-- Wait until scene 3 begins
WaitForTrigger(\"scene3Trigger\")

-- Cheer for the liberation
FadeIn( grummleCheer4, 1)
local actorAuraVisual = grummleCheer4:PlaySpellStateVisual(24803) --Cast Actor Visual

--Clear when end scene command is heard
WaitForTrigger( \"endScene3\" )
FadeOut( grummleCheer4, 1)
grummleCheer4:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual

Wait(5)
grummleCheer4: Despawn()"	0	0
299	"Lorewalker Story - S1: Grummle - Scene 4 - grummleVendor1 - ZTO"	"-- Wait until called by GrummleMainBag
WaitForTrigger(\"scene4Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( grummleVendor1, 1)
local actorAuraVisual = grummleVendor1:PlaySpellStateVisual(24803) --Cast Actor Visual
grummleVendor1: PlayLoopingFullBodyAnim( Animations.EmoteTalk )


-- Wait for scene 5 trigger then cross stage right
WaitForTrigger(\"scene5Trigger\")
grummleVendor1: StopLoopingSplitBodyAnim( Animations.EmoteTalk )
RunToLocation( grummleVendor1, 2, 1460.35, 375.131, 550.221, 41.5002  )
SendTrigger(\"Scene5a\")
Wait (2)
PlayOneShotSplitBodyAnim( grummleVendor1, Animations.EmoteTalk )


-- Beckon grummle over
WaitForTrigger(\"endScene4\")
FadeOut( grummleVendor1, 1)
grummleVendor1: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
Wait(5)
grummleVendor1: Despawn()"	0	0
300	"Lorewalker Story - S1: Grummle - Init - Scene 5 Actors - ZTO"	"-- Spawn Pandaren group
shadopanID = 61908
shadopan01 = SpawnActor(shadopanID, 1462.94, 376.842, 550.221, 199.45 ) -- Spawns downstage left
FadeOut( shadopan01, 0 )

"	0	0
301	"Lorewalker Story - S1: Grummle - Scene 4 - grummleVendor2 - ZTO"	"-- Wait until called by GrummleMainBag
WaitForTrigger(\"scene4Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( grummleVendor2, 1)
local actorAuraVisual = grummleVendor2:PlaySpellStateVisual(24803) --Cast Actor Visual

-- Wait for scene 5 trigger then cross stage right
WaitForTrigger(\"scene5Trigger\")
RunToLocation( grummleVendor2, 2, 1460.58, 372.162, 550.221, 41.5002  )
Wait (3)
PlayOneShotSplitBodyAnim( grummleVendor2, Animations.EmoteTalk )

-- Beckon grummle over
WaitForTrigger(\"endScene4\")
FadeOut( grummleVendor2, 1)
grummleVendor2: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
Wait(5)
grummleVendor2: Despawn()"	0	0
302	"Lorewalker Story - S1: Grummle - Scene 4 - whiteyak - ZTO"	"-- Wait until called by GrummleMainBag
WaitForTrigger(\"scene4Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( whiteyak, 1)
local actorAuraVisual = whiteyak:PlaySpellStateVisual(23826) -- Incense Aura for Yak

-- Wait for scene 5 trigger then cross stage right
WaitForTrigger(\"scene5Trigger\")
RunToLocation( whiteyak, 2, 1457.78, 372.955, 550.222, 38.3463  )

-- Beckon grummle over
WaitForTrigger(\"endScene4\")
FadeOut( whiteyak, 1)
whiteyak: ClearSpellStateVisual(23826, actorAuraVisual) --Clear Incense Visual
Wait(5)
whiteyak: Despawn()"	0	0
303	"Lorewalker Story - S1: Grummle - Init - Scene 6 Actors - ZTO"	"-- Spawn Grummle Vendors
grummleVendor3 = SpawnActor(grummleID, 1454.06, 365.674, 550.222, 99.7705 ) -- Spawns downstage left
grummleVendor4 = SpawnActor(grummleBagID, 1457.42, 369.071, 550.222, 175.146) -- Spawn second vendor
grummleVendor5 = SpawnActor(grummleID, 1455.07, 368.678, 550.222, 133.071 ) -- Spawns downstage left
FadeOut( grummleVendor3, 0 )
FadeOut( grummleVendor4, 0 )
FadeOut( grummleVendor5, 0 )"	0	0
304	"Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor3 - ZTO"	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\"scene6Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( light_cc, 2 )
FadeIn( grummleVendor3, 2)
local actorAuraVisual = grummleVendor3:PlaySpellStateVisual(24803) --Cast Actor Visual
local fluteAura = grummleVendor3:PlaySpellStateVisual(24987) --Cast Flute Visual
--grummleVendor3: PlayLoopingFullBodyAnim(Animations.HoldRifle)


-- Beckon grummle over
WaitForTrigger(\"endScene6\")
FadeOut( grummleVendor3, 1)
grummleVendor3: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
grummleVendor3: ClearSpellStateVisual(24987, fluteAura) -- Clear Flute Visual
Wait(5)
grummleVendor3: Despawn()"	0	0
305	"Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor4 - ZTO"	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\"scene6Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( grummleVendor4, 2)
local actorAuraVisual = grummleVendor4:PlaySpellStateVisual(24803) --Cast Actor Visual
grummleVendor4: PlayLoopingFullBodyAnim(Animations.EmoteTalk)



-- Beckon grummle over
WaitForTrigger(\"endScene6\")
FadeOut( grummleVendor4, 1)
grummleVendor4: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
Wait(5)
grummleVendor4: Despawn()"	0	0
306	"Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor5 - ZTO"	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\"scene6Trigger\")

-- Fade in on command, beckon at little grummle
FadeIn( grummleVendor5, 2)
local actorAuraVisual = grummleVendor5:PlaySpellStateVisual(24803) --Cast Actor Visual
grummleVendor5: PlayLoopingFullBodyAnim(Animations.SitGround)



-- Beckon grummle over
WaitForTrigger(\"endScene6\")
FadeOut( grummleVendor5, 1)
grummleVendor5: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual
Wait(5)
grummleVendor5: Despawn()"	0	0
307	"Orgrimmar - MoP Horde Intro Scene - Master - JSB"	"
if (Scene.SetFadeRegion) then
	scene:SetFadeRegion(10, true) -- (radius, fadeActivePlayer)
end

Wait( 2 )

SetCameraFollowPath( 390, 0.0, 3155, nil, 43 )

Wait( 37 )

SendTrigger( \"zeppelinLeave\" )

Wait( 4 )

SetCameraFollowPath( 399, 6, 3165, 3166, 45 )

Wait( 20 )

-- scene:SetCamera(391, 25, nil, nil)
"	0	0
308	"Orgrimmar - MoP Horde Intro Scene - Zeppelin - JSB"	"
-- PlayLoopingSplitBodyAnim( zeppelin, Animations.ShipMoving )

zeppelin:PlayLoopingAnimKit(2272)


zeppelinDest1 = Vector:New(1825.42, -4432.02, 153.1)
zeppelinDest2 = Vector:New(1954.46, -4547.58, 170.281)

zeppelinMoveSpeed = 6
zeppelinMoveOffset = zeppelinDest2 - zeppelinDest1

-- force the ship to face a direction
zeppelin:SetFacingToAbs(Vector:New(1703.49, -4311.06, 136.569))

RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest1.x, zeppelinDest1.y, zeppelinDest1.z)

WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

zeppelinMoveSpeed = 4
RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest2.x, zeppelinDest2.y, zeppelinDest2.z)

"	0	0
309	"Orgrimmar - MoP Horde Intro Scene - Nazgrim - JSB"	"
Wait ( 4 )

nazgrim:SetFacing(150)

Wait ( 1 )

nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)

Wait( 14 )

SendTrigger( \"zeppelinReady\" )

RunToLocation( nazgrim, 4, 1835.71, -4421.69, 135.18, 210.603 )

RunToLocation( nazgrim, 4, 1829.62, -4425.06, 135.18, 316.353 )


-- COPY STARTS HERE
--
local relativeMover = nazgrim -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
310	"Orgrimmar - MoP Horde Intro Scene - Rivett - JSB"	"
WaitForTrigger( \"zeppelinReady\" )

Wait( 0.6 )

RunToLocation( rivett, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( rivett, 3.5, 1826.46, -4420.67, 135.3, 156.378)

RunToLocation( rivett, 3.5, 1824.86, -4419.68, 136.4, 147.603)

RunToLocation( rivett, 3.5, 1823.17, -4418.4, 136.4, 310.278)



-- COPY STARTS HERE
--
local relativeMover = rivett -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
311	"Townlong - Dread Shadow Fight - Camera"	"local rand = math.random(0,2)
local path


	if rand == 0 then
		path = 3159
	elseif rand == 1 then
		path = 3181
	else
		path = 3182
	end



scene:SetCamera(392, 0, nil, nil)
SetCameraFollowPath( 398, 0.0, path, nil, 1.8 )
Wait(1.5)





scene:SetCamera(0, 0, nil, nil) -- sets camera back to game-cam"	0	0
312	"Orgrimmar - MoP Horde Intro Scene - Kiryn - JSB"	"
WaitForTrigger( \"zeppelinReady\" )

Wait( 0.7 )

RunToLocation( kiryn, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( kiryn, 3.5, 1824.08, -4423.17, 135.3, 141.851)

RunToLocation( kiryn, 3.5, 1822.66, -4422.05, 136.4, 131.726)

RunToLocation( kiryn, 3.5, 1819.94, -4418.78, 136.4, 316.901)



-- COPY STARTS HERE
--
local relativeMover = kiryn -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
313	"Orgrimmar - MoP Horde Intro Scene - Snuff - JSB"	"
Wait( 2 )
snuff:StopLoopingFullBodyAnim()
Wait( 1 )
snuff:PlayLoopingFullBodyAnim(Animations.Stand)

-- board zepp

WaitForTrigger( \"zeppelinReady\" )

Wait( 4.2 )
snuff:StopLoopingFullBodyAnim()

RunToLocation( snuff, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( snuff, 3.5, 1828.71, -4418.81, 135.3, 135.326)

RunToLocation( snuff, 3.5, 1824.9, -4415.01, 136.4, 327.926)

RunToLocation( snuff, 3.5, 1824.9, -4415.01, 136.4, 327.926)
Wait( 2 )
snuff:PlayLoopingFullBodyAnim(Animations.Sleep)


-- COPY STARTS HERE
--
local relativeMover = snuff -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
-- relativeMover:StopLoopingFullBodyAnim()"	0	0
314	"Orgrimmar - MoP Horde Intro Scene - Zin\'jun - JSB"	"

-- board zepp

WaitForTrigger( \"zeppelinReady\" )

Wait( 5 )

RunToLocation( zinjun, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( zinjun, 3.5, 1827.17, -4420.16, 135.3, 139.151)

RunToLocation( zinjun, 3.5, 1825.77, -4418.44, 136.4, 139.826)

RunToLocation( zinjun, 3.5, 1823.17, -4415.84, 136.4, 321.401)

-- COPY STARTS HERE
--
local relativeMover = zinjun -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()"	0	0
315	"Orgrimmar - MoP Horde Intro Scene - Shokia - JSB"	"
WaitForTrigger( \"zeppelinReady\" )

Wait( 2 )

RunToLocation( shokia, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( shokia, 3.5, 1832.44, -4428.37, 135.586, 197.201)

RunToLocation( shokia, 3.5, 1823.88, -4425.88, 135.3, 336.476)



-- COPY STARTS HERE
--
local relativeMover = shokia -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
316	"Orgrimmar - MoP Horde Intro Scene - Gorrok - JSB"	"WaitForTrigger( \"zeppelinReady\" )

Wait( 5.7 )

RunToLocation( gorrok, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( gorrok, 3.5, 1836.41, -4426.74, 135.5, 300)

RunToLocation( gorrok, 3.5, 1838.25, -4433.68, 136.2, 316.901)



-- COPY STARTS HERE
--
local relativeMover = gorrok -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
317	"Orgrimmar - MoP Horde Intro Scene - Clone - JSB"	"WaitForTrigger( \"zeppelinReady\" )

Wait( 2 )

RunToLocation( clone, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( clone, 3.5, 1826.63, -4429.49, 135.18, 269.876)

-- COPY STARTS HERE
--
local relativeMover = clone -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
318	"Orgrimmar - MoP Horde Intro Scene - Vanguard01 - JSB"	"WaitForTrigger( \"zeppelinReady\" )

Wait( 6.5 )

RunToLocation( vanguard01, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( vanguard01, 3.5, 1831.54, -4422.2, 135.18, 122.9)

RunToLocation( vanguard01, 3.5, 1829.91, -4418.78, 135.18, 309.205)



-- COPY STARTS HERE
--
local relativeMover = vanguard01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()
"	0	0
319	"Orgrimmar - MoP Horde Intro Scene - Vanguard02 - JSB"	"WaitForTrigger( \"zeppelinReady\" )

Wait( 7 )

RunToLocation( vanguard02, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( vanguard02, 3.5, 1835.17, -4434.62, 136.2, 303.355)

RunToLocation( vanguard02, 3.5, 1839.62, -4439.6, 136.8, 281.081)

-- COPY STARTS HERE
--
local relativeMover = vanguard02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()"	0	0
320	"Orgrimmar - MoP Horde Intro Scene - Vanguard03 - JSB"	"WaitForTrigger( \"zeppelinReady\" )

Wait( 8 )

RunToLocation( vanguard03, 3.5, 1838.08, -4421.66, 135.234, 215.103)

RunToLocation( vanguard03, 3.5, 1840.15, -4430.83, 136.2, 306.956)

RunToLocation( vanguard03, 3.5, 1843.91, -4434.75, 136.8, 331.706)

-- COPY STARTS HERE
--
local relativeMover = vanguard03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"zeppelinLeave\" )

-- Wait ( 2 )

-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))

RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()"	0	0
330	"zzOld - PetBattle(fallback) - Constants"	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
playerRadius   = 5.0
idleRadius     = 2.0
readyRadius    = 1.25
rangedRadius   = 0.5
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.25

--------------------------------------------------------------------------------
-- pad
padModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
padAlpha = 1.0
padScale = 1.0

--------------------------------------------------------------------------------
-- arena
arenaRingModel = \"SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"
arenaRingAlpha = 0.5
arenaRingScale = 1.0
arenaFadeTime = 5.0

--------------------------------------------------------------------------------
-- camera
freelookZoomMin = 5
freelookZoomMax = 12
freelookZoomStart = 9.0
useFreelookCamera = true
if (not Scene.SetGameCameraTarget) then
	useFreelookCamera = false
end

battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand = 2267;
	Death = 2268;
	Dead  = 2269;
}
"	0	0
331	"zzOld - PetBattle(fallback) - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate, crit)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	local isCritical = false
	if (crit == true) then
		isCritical = true
	end

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) then
			pet.actor:AddDamageText(nil, -change, isCritical, false)
		elseif (change > 0) then
			pet.actor:AddHealingText(nil, change, isCritical, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged "	0	536
332	"zzOld - PetBattle(fallback) - Init Player"	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	padCreateData.interactible = false
	local padActor = nil
	if (PetBattleScene.SpawnPet) then
		padActor = battleScene:SpawnPet(playerID, PetBattlePetID.Pad, padCreateData)
	else
		padActor = scene:SpawnActor(padCreateData)
	end

	padActor:Fade(padAlpha, 0)

	-- spawn NPC character
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)
		local npcCreateData = ActorCreateData:Default()
		npcCreateData.creatureID = team.npcCreatureID
		npcCreateData.creatureDisplayID = team.npcDisplayID
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)
		npcCreateData.interactible = false
		team.npcActor = scene:SpawnActor(npcCreateData)
		team.playerDisplay = team.npcActor
	end

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }
		pet.playerID = playerID
		team.pets[id] = pet

		if (id == PetBattlePetID.Pad) then
			pet.isPad = true
			pet.actor = padActor
			team.pad = pet
		else			
			pet.isPad = false
			local radius = backlineRadius
			local offset = 0
			if id == team.activePet then
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
					radius = backlineRadius
				else
					radius = idleRadius
				end
			else
				offset = backLineOffset
				backLineOffset = backLineOffset + backlineSpacing
			end
			
			local pos = BuildVector(team.teamFacing, -radius, offset)
			local transform = Transform:New(pos, team.teamFacing)
			
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
			petCreateData.creatureDisplayID = petDesc.displayID or 0

			if (PetBattleScene.SpawnPet) then
				pet.actor = battleScene:SpawnPet(playerID, id, petCreateData)
			else
				pet.actor = scene:SpawnActor(petCreateData)
			end

			SetXP(pet, petDesc.xp, petDesc.level, true)
			SetHealth(pet, petDesc.health, true)

			pet.status = petDesc.status

			pet.currentRadius = radius
			pet.currentOffset = offset

			-- always face the opponent location (at idleRadius)
			LookAtOpposingTeam(pet)


			-- hide all pets until loaded
			pet.actor:SetInteractible(false)
			pet.actor:SetHidden(true)
			pet.actor:Fade(0, 0)
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
		end

		-- apply initial auras
		for auraIndex, auraData in pairs(petDesc.auras or { }) do
			local auraVisual = petAbilityVisuals[auraData.auraVisualID]
			if (auraVisual) then
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
			end
		end
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, "	0	551
333	"zzOld - PetBattle(fallback) - Event Processing"	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.abilityVisualID)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.newFrontPet)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected()
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\"WARNING: processing round result outside of RoundStart/End\")
		ProcessRoundResult(event)
	elseif (eventType == PetBattleEvent.RoundStart) then

		-- pull off all round effects
		local allEffects = { }
		local effectNum = 0
		local done = false
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do
			event = battleScene:GetPendingEffect()
			eventType = event.eventType
			if (eventType == PetBattleEvent.RoundComplete) then
				done = true
			else
				effectNum = effectNum + 1
				allEffects[effectNum] = event
			end
		end
		
		-- if we have at least one effect or we\'re done, make sure
		-- process the round start then batch process effects
		-- NOTE: the event we are left with will be RoundComplete
		if (done == true or #allEffects > 0) then
			SignalEffectProcessed()
			ProcessAllRoundResults(allEffects)

			-- switch to the next pendign event
			StartEffectProcessing(event)
		end
	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (eventType == PetBattleEvent.RoundComplete) then
		for playerID, player in pairs(teams) do
			ClearTrapPrecast(playerID)
		end
		ResetActivePets()
	end

	return true
end

function StartEffectProcessing(event)
	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID
end

function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(effects)
  local customFunc = function(effects)
    return %s
  end
  customFunc(effects)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString
	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\"ERROR: loading script on BattlePetVisual ID=\" .. abilityVisual.ID .. \" failed: \" .. createString)
			print(\"ERROR: \" .. result)
		end"	0	555
334	"zzOld - PetBattle(fallback) - Effect Cast"	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, readyRadius)
	end

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local attackRadius = GetAttackRadius(abilityVisual.range)
	
	-- move front pet to the correct radius, if it was the caster
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then
		WaitMoveToRadius(casterFrontPet, attackRadius)
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (casterCastingPet.actor ~= targetPet.actor) then
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(
				spellVisualID,
				abilityVisual.impactTime,
				true,
				{targetPet.actor})
		else
			-- self targeted
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
		end
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return casterCastingPet, spellVisualID
end
"	0	0
335	"zzOld - PetBattle(fallback) - Effect Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

--	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player point
	if (team.playerDisplay) then
		team.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		lastPet.actor:Fade(0, backlineFadeTime)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forward then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
336	"zzOld - PetBattle(fallback) - Effect Set Health"	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisualID = effect.abilityVisualID
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for SetHealth\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local playersWithDeaths = { }
	local playersWithKills = { }

	local isCritical = false
	if (effect.flags and effect.flags.crit) then
		isCritical = true
	end

	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (effect.flags and effect.flags.miss == true) then
			targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)
		else
			if (spellVisualID) then
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)
			end

			local oldHealth = targetPet.currentHealth
			local newHealth = targetData.newHealth

			SetHealth(targetPet, newHealth, false, isCritical)

			if (newHealth <= 0) and (oldHealth > 0) then
				playersWithDeaths[targetPet.playerID] = true
				if (casterCastingPet) then
					playersWithKills[casterCastingPet.playerID] = true
				end
			end
		end
	end

	-- feedback on players that lost pets
	for playerID, hasDeath in pairs(playersWithDeaths) do
		if (hasDeath) then
			playersWithKills[playerID] = nil
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)
			end
		end
	end

	-- feedback on players that killed pets
	for playerID, hasKill in pairs(playersWithKills) do
		if (hasKill) then
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)
			end
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		casterCastingPet.actor:WaitCastingComplete(true)
	end
end
"	0	0
337	"zzOld - PetBattle(fallback) - Effect Aura Apply"	"
--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisualID = effect.abilityVisualID
	-- print( \"Application Visual ID \" .. abilityVisualID )

	local auraVisualID = 0
	local auraVisual = nil
	local auraSpellVisualID = 0

	if (effect.targets[1]) then
		auraVisualID = effect.targets[1].auraVisualID
		auraVisual = petAbilityVisuals[auraVisualID]
		if (auraVisual) then
			auraSpellVisualID = auraVisual.spellVisualID
		end
	end

	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no auraVisual for aura\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
			targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)
		else
			if (spellVisualID) then
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)
			end

			-- apply an aura, tracked by instance ID
			ApplyAura(targetPet, targetData.auraInstanceID, targetData.turnsRemaining, auraSpellVisualID)
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		casterCastingPet.actor:WaitCastingComplete(true)
	end
end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	if (aura.spellVisualID) then
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	else
		aura.spellVisualInstanceID = nil
	end
	aura.turnsRemaining = turnsRemaining
end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end
"	0	0
338	"zzOld - PetBattle(fallback) - Effect Aura Change"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	for index, target in pairs(effect.targets) do
		local petPlayerID = target.playerID
		local petSlot = target.petSlot

		local player = GetTeamByIndex(petPlayerID)
		local pet = player.pets[petSlot]

		if not petSlot then
			return
		end

		local auraInstanceID = target.auraInstanceID
		local aura = pet.auras[auraInstanceID]
		if not aura then
			print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
			return
		end

		if (cancel == true) or (target.turnsRemaining < 1) then
			RemoveAura(pet, auraInstanceID)
		else
			aura.turnsRemaining = target.turnsRemaining
		end
	end

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil

end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end
"	0	0
341	"zzOld - PetBattle(fallback) - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \"arenaCameraBunny\"
	cameraBunnyCreate.model = padModel
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()
	cameraBunnyCreate.transform.facing = player.teamFacing
	cameraBunnyCreate.interactible = false

	cameraBunny = scene:SpawnActor(cameraBunnyCreate)
	cameraBunny:SetFacingToAbs(BuildVector(player.teamFacing, playerRadius, 0.0))
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)
	
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)
end

function StopCameraBunny(transitionTime)
	if ( not cameraBunny ) or ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	-- return to the player
	local player = teams[observingPlayerIndex]
	scene:ResetGameCameraZoom()

	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)
	scene:WaitTimer(transitionTime)
	scene:SetGameCameraTarget(nil, 0.0, 0.0)
end

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 2.0, observedTeam.pad.actor, otherTeam.pad.actor)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
342	"zzOld - PetBattle(fallback) - Intro"	"
local cameraBunny

--------------------------------------------------------------------------------
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(1.5)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(1.6)
		scene:SetCamera(0, 0.75, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
343	"zzOld - PetBattle(fallback) - Main"	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[0].teamFacing = 0
initialBattleState.players[1].teamFacing = 0
initialBattleState.players[2].teamFacing = 180

teams = { }
teams[0] = initialBattleState.players[0]
teams[1] = initialBattleState.players[1]
teams[2] = initialBattleState.players[2]

if (PetBattleScene.GetActivePlayerDisplay) then
	if (teams[1]) then
		teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
	end
	if (teams[2]) then
		teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
	end
end

if (teams[2].isNPC == true) and (#teams[2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(0, teams[0])
InitTeam(1, teams[1])
InitTeam(2, teams[2])

-- wait for teams to load
battleScene:PlayPetBattleMusic(6077)
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		if (useFreelookCamera) then
			StartCameraBunny(0)
		else
			SetCamera(3)
		end
	end
	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle, winnerID = ProcessEvent(event)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
			-- move backline up to celebrate
			pet.actor:Fade(1.0, backlineFadeTime)
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.25)
	else
		SetCamera(4)
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0
345	"zzOld - PetBattle(fallback) - Arena"	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \"arenaRing\"
arenaCreateData.model = arenaRingModel
arenaCreateData.scale = arenaRingScale
arenaCreateData.interactible = false
arenaRing = scene:SpawnActor(arenaCreateData)
arenaRing:Fade(0, 0)
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)

scene:WaitTimer(0.25)
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)
"	0	0
346	"Lorewalker Story - S2: Saurok - Init - Pre-scene Actors - ZTO"	"-- Spawn huge mogu head!!
moguFaceID = 62170
moguFace = SpawnActor( moguFaceID, 1460.83, 362.878, 550.222, 131.721, .5 ) -- Mogu Main Character
moguFace: PlayLoopingAnimKit( 2340 )
FadeOut( moguFace, 0 )"	0	0
347	"Lorewalker Story - S2: Saurok - MASTER - Lorewalker Cho - ZTO"	"--OnScene start

--Wait (2)
lorewalker: StopLoopingSplitBodyAnim( Animations.EmoteReadLoop )
--PlayOneShotSplitBodyAnim( lorewalker, Animations.EmoteBow )
Wait (2)
SendTrigger( \"Spawn Face\" )
RunToLocation( lorewalker, 2, 1465.6, 368.785, 550.221, 205.073 ) -- Cross UR


SendTrigger( \"cueLight_UC\" ) -- Cue upstage center light
Wait(1)
SendTrigger( \"cueMogu\" ) -- Cue Mogu
WaitForTrigger(\"eggBreak\") --Wait for egg break to play out
Wait(1)
RunToLocation( lorewalker, 2, 1455.54, 372.492, 550.222, 139.374) --Cross to Center
SendTrigger( \"killMogu\" ) -- kill Mogu
Wait(4)
SendTrigger( \"blackLight_UC\" )
Wait(1)
SendTrigger( \"hack\" ) -- Cue saurok hack
Wait(1)
SendTrigger( \"heal\" ) -- Cue saurok hack
Wait(1)
SendTrigger( \"tank\" ) -- Cue saurok hack
Wait(5)
SendTrigger( \"killSaurok\" ) --Clear Scene 2
Wait(2)
FadeIn(light_cl, 2)
SendTrigger( \"scene3\" ) -- Cue scene 3
Wait(8)
SendTrigger( \"endScene3\" ) -- clear scene 3
FadeOut(light_cl, 2)
Wait(2)
FadeIn(light_cr, 2)
SendTrigger( \"scene4\" ) -- Cue scene 4
Wait(10)
SendTrigger( \"endScene4\" ) -- kill scene 4
FadeOut(light_cr, 2)
Wait(2)
FadeIn(light_cl, 2)
SendTrigger( \"scene5\" ) -- Cue scene 5

--Wait for saurok to be killed
WaitForTrigger( \"kill_saurok_hack6\" )
SendTrigger( \"endScene5\" ) -- kill scene 5
FadeOut(light_cl, 2)
RunToLocation(lorewalker, 2, 1452.46, 357.498, 550.221, 129.194, true)
SendTrigger( \"scene6\" ) -- cue scene 6
FadeIn(light_cc, 2)

RunToLocation( lorewalker, 2, 1453.76, 373.314, 550.221, 155.518, true)
SendTrigger( \"endScene6\" ) -- kill scene 6
Wait(5)
SendTrigger( \"endScene\" )
RunToLocation( lorewalker, 2, 1447.35, 371.28, 550.221, 96.3434, true)
Wait(1)
lorewalker: Despawn()"	0	0
348	"Lorewalker Story - S2: Saurok - End - Clean Up - ZTO"	"WaitForTrigger( \"endScene\" )

-- Despawn all actors in scene
moguFace: Despawn()

-- MoguDespawn
moguPoleArm1: Despawn()
moguMace1: Despawn()
moguFist1: Despawn()
tian: Despawn()

-- Despawn lights
FadeOut(light_cl, 1)
FadeOut(light_cc, 1)
FadeOut(light_cr, 1)
FadeOut(light_ul, 1)
FadeOut(light_uc, 1)
FadeOut(light_ur, 1)
light_cc: Despawn()
light_cc: Despawn()
light_cc: Despawn()
light_cc: Despawn()
light_cc: Despawn()
light_cc: Despawn()"	0	0
349	"Lorewalker Story - S2: Saurok - Init - Scene 1 Actors - ZTO"	"-- Spell preloads
TransformSpellID = 120566
TransformEffectSpellID = 120704

--Spawn and hide Mogu
moguID1 = 62426
moguID2 = 62427
moguID3 = 62428
moguBoss = 62169

moguPoleArm1 = SpawnActor( moguID1, 1461.08, 361.964, 550.222, 129.022 ) -- Mogu grunt with polearm
moguMace1 = SpawnActor( moguID2, 1461.08, 361.964, 550.222, 129.022 ) -- Mogu grunt with mace
moguFist1 = SpawnActor( moguID3, 1461.08, 361.964, 550.222, 129.022 ) -- Mogu grunt with fist
tian = SpawnActor( moguBoss, 1461.08, 361.964, 550.222, 129.022)

-- Fade out until needed
FadeOut( moguPoleArm1, 0 )
FadeOut( moguMace1, 0 )
FadeOut( moguFist1, 0 )
FadeOut( tian, 0 )

-- Spawn and hide lizards
lizardID = 61936
lizard1 = SpawnActor( lizardID, 1452.1, 372.201, 550.222, 219.019, .5 ) -- Lizard center stage
lizard2 = SpawnActor( lizardID, 1446.68, 363.408, 550.221, 317.117, .5 ) -- Lizard stage right
lizard3 = SpawnActor( lizardID, 1459.67, 375.32, 550.221, 340.068, .5 ) -- Lizard stage left

-- Fade out until called
FadeOut( lizard1, 0 )
FadeOut( lizard2, 0 )
FadeOut( lizard3, 0 )

-- Eggs
eggID = 61988
egg1 = SpawnActor( eggID, 1452.31, 371.112, 550.222, 352.44, 1 ) -- Lizard center stage
egg2 = SpawnActor( eggID, 1456.35, 372.659, 550.222, 284.715, 1 ) -- Lizard stage right
egg3 = SpawnActor( eggID, 1452.27, 368.597, 550.222, 350.865, 1 ) -- Lizard stage left

-- Fade out until called
FadeOut( egg1, 0 )
FadeOut( egg2, 0 )
FadeOut( egg3, 0 )

-- First Saurok
saurokID = 62433
littlesaurok = SpawnActor( saurokID, 1452.31, 371.112, 550.222, 131.265, .5 ) -- Lizard center stage

-- Fade out until called
FadeOut( littlesaurok, 0 )
"	0	0
350	"Lorewalker Story - S2: Saurok - MoguFace - ZTO"	"-- Bring on the mighty mogu face!
WaitForTrigger( \"Spawn Face\" )
FadeIn( moguFace, 2 )


--FadeOut( moguFace, 2)
WaitForTrigger( \"cueMogu\" )
FadeOut( moguFace, 2 )
moguFace: Despawn()"	0	0
351	"Lorewalker Story - S2: Saurok - Scene 1 - MoguMace1 - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
FadeIn(moguMace1, 1)
local actorAuraVisual = moguMace1:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(moguMace1, 2, 1462.35, 368.695, 550.223, 132.17)
PlayLoopingSplitBodyAnim( moguMace1, Animations.Ready2HL )

-- Clear scene 1, setup for scene 4
WaitForTrigger( \"killMogu\" )
FadeOut(moguMace1, 1)
Wait(2)
RunToLocation( moguMace1, 5,1462.19, 377.953, 550.221, 195.386)
PlayLoopingSplitBodyAnim( moguMace1, Animations.Attack2H )

-- Wait for Scene 4
WaitForTrigger( \"scene4\" )
FadeIn(moguMace1, 1)

WaitForTrigger( \"endScene4\" )
FadeOut(moguMace1, 1)

-- Wait until dismissed
WaitForTrigger( \"endMogu\" )
moguMace1: Despawn()"	0	0
352	"Lorewalker Story - S2: Saurok - Scene 1 - MoguPolearm1 - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(1)
FadeIn(moguPoleArm1, 1)
local actorAuraVisual = moguPoleArm1:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(moguPoleArm1, 2, 1452.2, 359.916, 550.221, 127.444)
PlayLoopingSplitBodyAnim( moguPoleArm1, Animations.Ready2H )

-- Wait until dismissed
WaitForTrigger( \"killMogu\" )
FadeOut(moguPoleArm1, 1)
Wait(2)
RunToLocation( moguPoleArm1, 5,1463.83, 375.459, 550.221, 236.786)
--PlayLoopingSplitBodyAnim( moguPoleArm1, Animations.Attack2H )

-- Wait for Scene 4
WaitForTrigger( \"scene4\" )
FadeIn(moguPoleArm1, 1)

-- Wait for Scene 4 ending
WaitForTrigger( \"endScene4\" )
FadeOut(moguPoleArm1, 1)
Wait(3)
RunToLocation( moguPoleArm1, 5, 1467.08, 374.867, 550.221, 225.045) -- setup for scene 6
StopLoopingSplitBodyAnim( moguPoleArm1, Animations.Attack2H )

--Wait for Scene 6
WaitForTrigger( \"scene6\" )
FadeIn(moguPoleArm1, 1)
RunToLocation( moguPoleArm1, 2, 1464.2, 372.466, 550.221, 219.87)
PlayOneShotSplitBodyAnim( moguPoleArm1, Animations.EmotePoint )
Wait(2)
PlayOneShotSplitBodyAnim( moguPoleArm1, Animations.Attack2HL )
SendTrigger( \"eggBreak2\" )

--Wait to be dismissed
WaitForTrigger( \"endScene6\" )
FadeOut( moguPoleArm1, 1)

-- Wait for scene end
WaitForTrigger( \"endScene\" )
moguPoleArm1: Despawn()"	0	0
353	"Lorewalker Story - S2: Saurok - Scene 1 - Tian - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(3)
FadeIn(tian, 1)
local actorAuraVisual = tian:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(tian, 2, 1457.29, 366.243, 550.222, 129.022)
CastSpellAtActor( tian, egg1, TransformSpellID )
Wait(1)
SendTrigger( \"eggBreak\" )

Wait(3)


-- Wait until dismissed
WaitForTrigger( \"killMogu\" )
FadeOut(tian, 1)
Wait(1)
RunToLocation(tian, 5, 1449.02, 362.493, 550.222, 69.1598)
Wait(1)

-- Wait for Scene 5
WaitForTrigger( \"scene5\" )
FadeIn(tian, 1)
PlayLoopingSplitBodyAnim( tian, Animations.EmoteTalkExclamation )

--Wait for saurok_hack4 to arrive
WaitForTrigger( \"attackTian\" )
tian: StopLoopingSplitBodyAnim( Animations.EmoteTalkExclamation )
tian: SetFacing(326.124)
Wait(1)
CastSpellAtActor( tian, saurok_hack4, TransformSpellID )
Wait(1)
SendTrigger( \"throttle\" )
tian: SetFacing(29.9705)
Wait(1)
CastSpellAtActor( tian, saurok_hack5, TransformSpellID )
Wait(1)
SendTrigger( \"throttle2\" )
Wait(2)
PlayLoopingSplitBodyAnim( tian, Animations.EmoteLaugh )
FadeOut(tian, 1)


-- Wait for end of Scene 5
WaitForTrigger( \"endScene5\" )

-- Wait until despawned
WaitForTrigger( \"endScene\" )
tian: Despawn()"	0	0
354	"Lorewalker Story - S2: Saurok - Scene 1 - lizard1 - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(2)
FadeIn(lizard1, 1)
local actorAuraVisual = lizard1:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)
--RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)
--RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)
--RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)
--lizard1: Despawn()

-- Wait until dismissed
WaitForTrigger( \"eggBreak\" )
FadeOut(lizard1, 1)
lizard1: Despawn()"	0	0
355	"Lorewalker Story - S2: Saurok - Scene 1 - lizard2 - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(2)
FadeIn(lizard2, 1)
local actorAuraVisual = lizard2:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)
--lizard2: Despawn()

-- Wait until dismissed
WaitForTrigger( \"eggBreak\" )
FadeOut(lizard2, 1)
lizard2: Despawn()"	0	0
356	"Lorewalker Story - S2: Saurok - Scene 1 - lizard3 - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(2)
FadeIn(lizard3, 1)
local actorAuraVisual = lizard3:PlaySpellStateVisual(24803) --Cast Actor Visual
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)
--lizard3: Despawn()

-- Wait until dismissed
WaitForTrigger( \"eggBreak\" )
FadeOut(lizard3, 1)
lizard3: Despawn()"	0	0
357	"Lorewalker Story - S2: Saurok - Scene 1 - egg - ZTO"	"-- Wait until called
WaitForTrigger( \"cueMogu\" )
Wait(2)
FadeIn(egg1, 1)
FadeIn(egg2, 1)
FadeIn(egg3, 1)

-- Wait until dismissed
WaitForTrigger( \"eggBreak\" )
FadeOut(egg1, 1)
FadeOut(egg2, 1)
FadeOut(egg3, 1)
Wait(3)
RunToLocation( egg1, 5, 1463.12, 366.547, 550.221)
RunToLocation( egg2, 5, 1459.96, 365.049, 550.221)
RunToLocation( egg3, 5, 1451.5, 371.934, 550.222)

--Wait for Scene 6
WaitForTrigger( \"scene6\" )
FadeIn(egg1, 1)
FadeIn(egg2, 1)
FadeIn(egg3, 1)

--Wait for second egg break
WaitForTrigger( \"eggBreak2\" )
CastSpellAtActor( egg1, egg1, bloodyExplosionSpellID )
CastSpellAtActor( egg2, egg2, bloodyExplosionSpellID )
FadeOut(egg1, 1)
FadeOut(egg2, 1)

-- Wait for end scene
WaitForTrigger( \"endScene\" )
egg1: Despawn()
egg2: Despawn()
egg3: Despawn()"	0	0
358	"Lorewalker Story - S2: Saurok - Scene 1 - littlesaurok - ZTO"	"-- Wait until called
WaitForTrigger( \"eggBreak\" )
--Wait(2)
CastSpellAtActor( littlesaurok, littlesaurok, TransformEffectSpellID )
FadeIn(littlesaurok , 1)
Wait(2)
PlayOneShotSplitBodyAnim( littlesaurok, Animations.BattleRoar )

-- Wait until dismissed
WaitForTrigger( \"killMogu\" )
Wait(4)
FadeOut(littlesaurok, 1)
littlesaurok: Despawn()"	0	0
359	"Lorewalker Story - S2: Saurok - Init - Scene 2 Actors - ZTO"	"--Spawn and hide saurok
hackID = 61935
healID = 61934
tankID = 61933

saurok_hack = SpawnActor( hackID, 1463.6, 372.819, 550.221, 129.915 ) -- Hacky saurok
saurok_heal = SpawnActor( healID, 1449.86, 361.5, 550.221, 129.915 ) -- Healy saurok
saurok_tank = SpawnActor( tankID, 1456.69, 367.043, 550.221, 129.915 ) -- Tank saurok

--Fade out until needed
FadeOut(saurok_hack, 0)
FadeOut(saurok_heal, 0)
FadeOut(saurok_tank, 0)"	0	0
360	"Lorewalker Story - S2: Saurok - Scene 2 - saurok_hack - ZTO"	"-- Wait until called
WaitForTrigger( \"hack\" )
--Wait(2)
FadeIn(light_cr, 1)
FadeIn(saurok_hack , 1)
Wait(1)
PlayOneShotSplitBodyAnim( saurok_hack, Animations.BattleRoar )

-- Wait until dismissed and setup for scene 6
WaitForTrigger( \"killSaurok\" )
FadeOut(light_cr, 1)
FadeOut(saurok_hack, 1)
Wait(2)
RunToLocation(saurok_hack, 5, 1448.76, 358.391, 550.221, 54.2689)

-- Scene 6
WaitForTrigger( \"scene6\" )
FadeIn(saurok_hack, 1)
RunToLocation(saurok_hack, 4, 1453.68, 365.862, 550.221, 51.5689)
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Ready1H )

-- Die on command
WaitForTrigger( \"kill_2\" )
saurok_hack4: PlayOneShotFullBodyAnim( Animations.Death )
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Dead )
Wait(2)
FadeOut(saurok_hack, 1)

-- EndScene
WaitForTrigger( \"endScene\" )
saurok_hack: Despawn()"	0	0
361	"Lorewalker Story - S2: Saurok - Scene 2 - saurok_heal - ZTO"	"-- Wait until called
WaitForTrigger( \"heal\" )
--Wait(2)
FadeIn(light_cl, 1)
FadeIn(saurok_heal , 1)
Wait(1)
PlayOneShotSplitBodyAnim( saurok_heal, Animations.BattleRoar )

-- Wait until dismissed
WaitForTrigger( \"killSaurok\" )
FadeOut(light_cl, 1)
FadeOut(saurok_heal, 1)
Wait(4)
RunToLocation(saurok_heal, 5, 1449.89, 369.873, 550.222, 67.5435)
PlayLoopingSplitBodyAnim( saurok_heal, Animations.MountSelfIdle )

--Wait for Scene 6
WaitForTrigger( \"scene6\" )
FadeIn(saurok_heal, 1)


--Wait for End Scene
WaitForTrigger( \"endScene\" )
saurok_heal: Despawn()"	0	0
362	"Lorewalker Story - S2: Saurok - Scene 2 - saurok_tank - ZTO"	"-- Wait until called
WaitForTrigger( \"tank\" )
--Wait(2)
FadeIn(light_cc, 1)
FadeIn(saurok_tank , 1)
Wait(1)
saurok_tank: PlayOneShotFullBodyAnim( Animations.BattleRoar )

-- Wait until dismissed
WaitForTrigger( \"killSaurok\" )
FadeOut(light_cc, 1)
FadeOut(saurok_tank, 1)
saurok_tank: Despawn()"	0	0
363	"Lorewalker Story - S2: Saurok - Init - Scene 3 Actors - ZTO"	"--Spawn and hide saurok
--hackID = 61935
--healID = 61934
--tankID = 61933

saurok_hack2 = SpawnActor( hackID, 1447.03, 364.472, 550.221, 246.69 ) -- Hacky saurok
saurok_heal2 = SpawnActor( healID, 1453.51, 361.922, 550.221, 195.84 ) -- Healy saurok
saurok_tank2 = SpawnActor( tankID, 1449.89, 363.63, 550.221, 221.265 ) -- Tank saurok

--Fade out until needed
FadeOut(saurok_hack2, 0)
FadeOut(saurok_heal2, 0)
FadeOut(saurok_tank2, 0)

--Spawn Yaungol
yaungolID = 62437

yaungol1 = SpawnActor( yaungolID, 1445.54, 361.697, 550.221, 54.0878 ) -- Yaungol footsoldier
yaungol2 = SpawnActor( yaungolID, 1448.2, 358.863, 550.221, 25.7378 ) -- Yaungol footsoldier

--fade out until called.
FadeOut(yaungol1, 0)
FadeOut(yaungol2, 0)
"	0	0
364	"Lorewalker Story - S2: Saurok - Scene 3 - saurok_tank2 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene3\" )
--Wait(2)
FadeIn(saurok_tank2, 1)
saurok_tank2: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )

-- Wait until dismissed
WaitForTrigger( \"endScene3\" )
FadeOut(saurok_tank2, 1)
saurok_tank2: Despawn()"	0	0
365	"Lorewalker Story - S2: Saurok - Scene 3 - saurok_heal2 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene3\" )
--Wait(2)
FadeIn(saurok_heal2, 1)
saurok_heal2: PlayLoopingFullBodyAnim( Animations.ReadySpellOmni )

-- Wait until dismissed
WaitForTrigger( \"endScene3\" )
FadeOut(saurok_heal2, 1)
saurok_heal2: Despawn()"	0	0
366	"Lorewalker Story - S2: Saurok - Scene 3 - saurok_hack2 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene3\" )
--Wait(2)
FadeIn(saurok_hack2, 1)
saurok_hack2: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )

-- Wait until dismissed
WaitForTrigger( \"endScene3\" )
FadeOut(saurok_hack2, 1)
saurok_hack2: Despawn()"	0	0
367	"Lorewalker Story - S2: Saurok - Scene 3 - yaungols - ZTO"	"-- Wait until called
WaitForTrigger( \"scene3\" )
yaungol1: PlayLoopingFullBodyAnim( Animations.Attack2H )
Wait(1)
yaungol2: PlayLoopingFullBodyAnim( Animations.Attack2H )

--Wait(2)
FadeIn(yaungol1, 1)
FadeIn(yaungol2, 1)

-- Wait until dismissed
WaitForTrigger( \"endScene3\" )
FadeOut(yaungol1, 1)
FadeOut(yaungol2, 1)
yaungol2: Despawn()
yaungol1: Despawn()"	0	0
368	"Lorewalker Story - S2: Saurok - Init - Scene 4 Actors - ZTO"	"--Spawn in saurok
saurok_hack3 = SpawnActor( hackID, 1456.74, 376.654, 550.221, 12.9099 ) -- Hacky saurok
saurok_heal3 = SpawnActor( healID, 1461.95, 369.217, 550.221, 62.8614 ) -- Healy saurok
saurok_tank3 = SpawnActor( tankID, 1458.37, 371.162, 550.221, 41.935 ) -- Tank saurok

--Fade out until needed
FadeOut(saurok_hack3, 0)
FadeOut(saurok_heal3, 0)
FadeOut(saurok_tank3, 0)

"	0	0
369	"Lorewalker Story - S2: Saurok - Scene 4 - saurok_hack3 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene4\" )
--Wait(2)
FadeIn(saurok_hack3, 1)
saurok_hack3: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )

-- Wait until dismissed
WaitForTrigger( \"endScene4\" )
FadeOut(saurok_hack3, 1)
saurok_hack3: Despawn()"	0	0
370	"Lorewalker Story - S2: Saurok - Scene 4 - saurok_heal3 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene4\" )
--Wait(2)
FadeIn(saurok_heal3, 1)
saurok_heal3: PlayLoopingFullBodyAnim( Animations.ReadySpellOmni )

-- Wait until dismissed
WaitForTrigger( \"endScene4\" )
FadeOut(saurok_heal3, 1)
saurok_heal3: Despawn()"	0	0
371	"Lorewalker Story - S2: Saurok - Scene 4 - saurok_tank3 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene4\" )
--Wait(2)
FadeIn(saurok_tank3, 1)
saurok_tank3: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )

-- Wait until dismissed
WaitForTrigger( \"endScene4\" )
FadeOut(saurok_tank3, 1)
saurok_tank3: Despawn()"	0	0
372	"Lorewalker Story - S2: Saurok - Init - Scene 5 Actors - ZTO"	"--Spell Effects
fieryExplosionSpellID = 99977
trollExplosionSpellID = 52565
bloodyExplosionSpellID = 3240

--Spawn in saurok
saurok_hack4 = SpawnActor( hackID, 1457.85, 356.834, 550.222, 133.284, 1, false ) -- Hacky saurok
saurok_hack5 = SpawnActor( hackID, 1466.6, 361.989, 550.222, 130.584, 1, false ) -- Healy saurok
saurok_hack6 = SpawnActor( hackID, 1470.56, 365.079, 550.222, 130.584, 1, false ) -- Tank saurok

--Spawn Terrorcotta Warriors
terrorcottaID = 62639
terrorcotta1 = SpawnActor( terrorcottaID, 1469.18, 378.943, 550.221, 218.297, 2, true ) -- Terrorcotta Warrior
terrorcotta2 = SpawnActor( terrorcottaID, 1448.26, 357.204, 550.221, 36.0522, 2, true ) -- Terrorcotta Warrior


--Fade out until needed
FadeOut(saurok_hack4, 0)
FadeOut(saurok_hack5, 0)
FadeOut(saurok_hack6, 0)

FadeOut(terrorcotta1, 0)
FadeOut(terrorcotta2, 0)"	0	0
373	"Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack4 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene5\" )
Wait(2)
saurok_hack4: PlayLoopingFullBodyAnim( Animations.SitGround )
FadeIn(saurok_hack4, 1)
RunToLocation(saurok_hack4, 2, 1456.78, 356.96, 551.863, 133.284, false)
saurok_hack4: StopLoopingFullBodyAnim( Animations.SitGround )
--Wait(1)
saurok_hack4: PlayOneShotFullBodyAnim( Animations.SitGroundUp )
Wait(1)
saurok_hack4: PlayOneShotFullBodyAnim( Animations.MountSelfStart )
Wait(1)
saurok_hack4: PlayLoopingFullBodyAnim( Animations.MountSelfRun )
RunToLocation(saurok_hack4, 4, 1454.27, 361.229, 550.222, 124.734, true) --Run to Tian
saurok_hack4: StopLoopingFullBodyAnim( Animations.MountSelfRun )
SendTrigger( \"attackTian\" ) --Let Tian know i\'m here

--OnThrottle
WaitForTrigger( \"throttle\" )
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Strangulate ) --Start to get strangled
RunToLocation(saurok_hack4, 1, 1454.27, 361.229, 560.222, 124.734, false) --Float in air
CastSpellAtActor( saurok_hack4, saurok_hack4, fieryExplosionSpellID ) --Explode
FadeOut(saurok_hack4, 0)

-- Wait until dismissed
WaitForTrigger( \"endScene5\" )
FadeOut(saurok_hack4, 1)
saurok_hack4: Despawn()"	0	0
374	"Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack5 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene5\" )
Wait(4)
saurok_hack5: PlayLoopingFullBodyAnim( Animations.SitGround )
FadeIn(saurok_hack5, 1)
RunToLocation(saurok_hack5, 2, 1464.62, 364.296, 551.862, 130.584, false)
saurok_hack5: StopLoopingFullBodyAnim( Animations.SitGround )
--Wait(1)
saurok_hack5: PlayOneShotFullBodyAnim( Animations.SitGroundUp )
Wait(1)
saurok_hack5: PlayOneShotFullBodyAnim( Animations.MountSelfStart )
Wait(1)
saurok_hack5: PlayLoopingFullBodyAnim( Animations.MountSelfRun )
RunToLocation(saurok_hack5, 4, 1456.3, 365.106, 550.222, 168.609, true)
saurok_hack5: StopLoopingFullBodyAnim( Animations.MountSelfRun )

--OnThrottle
WaitForTrigger( \"throttle2\" )
CastSpellAtActor( saurok_hack5, saurok_hack5, fieryExplosionSpellID ) --Explode
saurok_hack5: PlayOneShotFullBodyAnim( Animations.Death ) --Start to get strangled
saurok_hack5: PlayLoopingFullBodyAnim( Animations.Dead ) --Start to get strangled

-- Wait until dismissed
WaitForTrigger( \"endScene5\" )
FadeOut(saurok_hack5, 1)
saurok_hack5: Despawn()"	0	0
375	"Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack6 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene5\" )
Wait(3)
saurok_hack6: PlayLoopingFullBodyAnim( Animations.SitGround )
FadeIn(saurok_hack6, 1)
RunToLocation(saurok_hack6, 2, 1468.44, 367.551, 551.862, 130.584, false)
saurok_hack6: StopLoopingFullBodyAnim( Animations.SitGround )
--Wait(1)
saurok_hack6: PlayOneShotFullBodyAnim( Animations.SitGroundUp )
Wait(1)
saurok_hack6: PlayOneShotFullBodyAnim( Animations.MountSelfStart )
Wait(1)
saurok_hack6: PlayLoopingFullBodyAnim( Animations.MountSelfRun )
RunToLocation(saurok_hack6, 4, 1458.96, 371.655, 550.222, 208.884, true)
saurok_hack6: StopLoopingFullBodyAnim( Animations.MountSelfRun )

--Wait to be killed
WaitForTrigger( \"kill_saurok_hack6\" )
saurok_hack6: PlayOneShotFullBodyAnim( Animations.Death )
saurok_hack6: PlayLoopingFullBodyAnim( Animations.Dead )


-- Wait until dismissed
WaitForTrigger( \"endScene5\" )
FadeOut(saurok_hack6, 1)
saurok_hack6: Despawn()"	0	0
376	"Shen-zin Su - Healing Cinematic - Init"	"
FlashHealModel = \"Spells\FlashHeal_Base.mdx\"

FlashHeal01 = SpawnModelActor( FlashHealModel, 292.12, 4007.6, 76.0999, 0 )"	0	0
377	"Shen-zin Su - Healing Cinematic - Bunny 01"	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( FlashHeal01, 1 )"	0	0
378	"Shen-zin Su - Healing Cinematic - Camera"	"
scene:WaitTimer(2)

scene:SetCamera(316,8,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(2)
scene:SetCamera(328,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(329,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(330,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(331,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(332,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(333,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(0,4,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(4)"	0	0
379	"Jade Forest - Horde Intro Scene - Alliance Crewman01 - JSB"	"allianceCrewman01:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 3.9 )

allianceCrewman01:PlayOneShotFullBodyAnim(Animations.EmoteKneel)

Wait( 6.2 )

allianceCrewman01:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )
allianceCrewman01:PlayLoopingFullBodyAnim(Animations.FlyFall)
local actorAuraVisual = allianceCrewman01:PlaySpellStateVisual(9628) --Cast Actor Visual

allianceCrewman01:FollowPath( 3233, 2 )

Wait( 3 )

allianceCrewman01:Despawn()
"	0	0
380	"Jade Forest - Horde Intro Scene - Alliance Crewman02 - JSB"	"allianceCrewman02:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 4.1 )

allianceCrewman02:PlayOneShotFullBodyAnim(Animations.EmoteKneel)

Wait( 6 )

allianceCrewman02:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )
allianceCrewman02:PlayLoopingFullBodyAnim(Animations.FlyFall)
local actorAuraVisual = allianceCrewman02:PlaySpellStateVisual(9628) --Cast Actor Visual

allianceCrewman02:FollowPath( 3234, 2 )


Wait( 3 )

allianceCrewman02:Despawn()
"	0	0
381	"Jade Forest - Horde Intro Scene - Alliance Crewman03 - JSB"	"allianceCrewman03:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 4.3 )

allianceCrewman03:PlayOneShotFullBodyAnim(Animations.EmoteKneel)

Wait( 5.8 )

allianceCrewman03:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )
allianceCrewman03:PlayLoopingFullBodyAnim(Animations.FlyFall)
local actorAuraVisual = allianceCrewman02:PlaySpellStateVisual(9628) --Cast Actor Visual

allianceCrewman03:FollowPath( 3232, 2 )

Wait( 3 )

allianceCrewman03:Despawn()"	0	0
382	"Jade Forest - Horde Intro Scene - Alliance Crewman04 - JSB"	"allianceCrewman04:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 3 )

allianceCrewman04:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)

Wait( 7.1 )

allianceCrewman04:PlayOneShotFullBodyAnim(Animations.Knockdown)


Wait( 5 )

allianceCrewman04:Despawn()"	0	0
383	"Jade Forest - Horde Intro Scene - Alliance Crewman05 - JSB"	"allianceCrewman05:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman05 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \"allianceShip\" )
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )
relativeMover:StopLoopingFullBodyAnim()

--
-- COPY STOPS HERE
--

-- Tell allianceCaptain what to do

WaitForTrigger( \"zeppelinMove\" )

Wait( 2 )
allianceCrewman05:SetFacingToAbs ( Vector:New (3457.83, -923.965, 0) )
Wait( 1 )

allianceCrewman05:PlayOneShotFullBodyAnim(Animations.EmoteShout)

Wait( 7.1 )
allianceCrewman05:PlayOneShotFullBodyAnim(Animations.Knockdown)

Wait( 5 )

allianceCrewman05:Despawn()"	0	0
384	"Lorewalker Story - S2: Saurok - Scene 5 - terrorcotta1 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene5\" )
Wait(1)


--Wait for command to attack
--OnThrottle
WaitForTrigger( \"throttle\" )
FadeIn(terrorcotta1, 1)
Wait(1)
RunToLocation(terrorcotta1, 2, 1462.21, 374.621, 550.221, 220.322, true)
terrorcotta1: PlayOneShotFullBodyAnim( Animations.Attack2H )
SendTrigger( \"kill_saurok_hack6\" )

--Wait for Scene 6
WaitForTrigger( \"scene6\" )
RunToLocation(terrorcotta1, 2, 1458.17, 371.436, 550.221, 219.419, true)
terrorcotta1: PlayOneShotFullBodyAnim( Animations.Attack2H )
SendTrigger( \"kill_2\" )
RunToLocation(terrorcotta1, 2, 1448.2, 361.327, 550.222, 222.344, true)
FadeOut(terrorcotta1, 1)

-- Wait until dismissed
WaitForTrigger( \"endScene\" )
FadeOut(terrorcotta1, 1)
terrorcotta1: Despawn()"	0	0
385	"Lorewalker Story - S2: Saurok - Scene 5 - terrorcotta2 - ZTO"	"-- Wait until called
WaitForTrigger( \"scene5\" )
terrorcotta2: PlayLoopingAnimKit( 1551 )
Wait(1)

FadeIn(terrorcotta2, 1)

--Wait for command to attack



-- Wait until dismissed
WaitForTrigger( \"endScene5\" )
FadeOut(terrorcotta2, 1)
terrorcotta2: Despawn()"	0	0
386	"Townlong Steppes - Finale Spyglass Intro - Init"	"
local Boss1ID = 62579
local Boss2ID = 62580
local Boss3ID = 62581
Boss1 = SpawnActor( Boss1ID, 1369.76, 4394.86, 211.106, 263, 1.0, false )
Boss2 = SpawnActor( Boss2ID, 1594.94, 4500.88, 148.093, 11, 1.0, false )
Boss3 = SpawnActor( Boss3ID, 1648.42, 4800.84, 150.908, 60, 1.0, false )"	0	0
387	"Townlong Steppes - Finale Spyglass Intro - Bunny 01"	"
Wait(1)
FadeIn( Boss1, 1 )
FadeIn( Boss2, 1 )
FadeIn( Boss3, 1 )"	0	0
388	"Townlong Steppes - Finale Spyglass Intro - Camera"	"
scene:WaitTimer(1)

scene:SetCamera(403,1,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(7)
scene:SetCamera(404,4,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(405,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(406,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(407,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(408,5,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(0,1,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(1)"	0	0
389	"zzOld - PetBattle(fallback) - Event Reward"	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = GetTeamByIndex(reward.playerID)
			local playerPet = player.pets[reward.petSlot]
			if (playerPet) then
				local rewardedPet =
				{
					pet = playerPet;
					newXP = reward.newXP;
					newLevel = reward.newLevel;
				}
				rewardedPets[rewardIndex] = rewardedPet

				-- resurrect and move this pet up
				if (playerPet.deathAnimKit) then
					playerPet.deathAnimKit:Stop()
					playerPet.deathAnimKit = nil		
				end

				playerPet.actor:Fade(1.0, backlineFadeTime)
				MoveToRadius(playerPet, idleRadius, playerPet.currentOffset)
			end
		end
	end

	-- wait until all pets have stopped moving
	local waitCondition = function()
		-- all actors must be renderable
		for prewardIndex,rewardedPet in pairs(rewardedPets) do
			if rewardedPet.pet.actor:IsMoving() then
				return false
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

	-- apply the rewards
	for rewardIndex,rewardedPet in pairs(rewardedPets) do
		SetXP(rewardedPet.pet, rewardedPet.newXP, rewardedPet.newLevel, false)
	end
end
"	0	0
390	"zzOld - PetBattle(fallback) - Event Move Ability Selected"	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)

	-- print(\"Move Selected: Ability Visual ID: \" .. abilityVisualID)
	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if (not abilityVisual) then
		return
	end

	local player = nil
	local pet = nil
	if (observingPlayerIndex > 0) then
		player = GetTeamByIndex(observingPlayerIndex)
		if (player) then
			pet = player.pets[player.activePet]
		end
	end

	if (not pet) then
		return
	end

	local radius = readyRadius --GetAttackRadius(abilityVisual.range)
	WaitMoveToRadius(pet, radius)

end
"	0	0
391	"zzOld - PetBattle(fallback) - Event Move Pet Swap Selected"	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\"Move Selected: Pet Swap Slot: \" .. petSlot)

end"	0	0
414	"zzOld - PetBattle(fallback) - Placeholder Players"	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \"placeHolder\" .. playerID
					createData.interactible = false
					createData.floatingTooltip = false

					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)
					local transform = Transform:New(pos, player.teamFacing)
					createData.transform = transform

					placeHolderActor = scene:SpawnActor(createData)
					placeHolderActors[playerID] = placeHolderActor
				end

				-- keep using the placeholder
				player.playerDisplay = placeHolderActor
			else
				-- done with this placeholder, despawn it
				local placeHolderActor = placeHolderActors[playerID]
				if (placeHolderActor) then
					placeHolderActor:Despawn()
				end

				placeHolderActors[playerID] = nil
			end
		end
	end
end

placeHolderActors = nil
"	0	0
426	"zzOld - PetBattle(fallback) - Effect Status Change"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	for targetIndex, target in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(target.playerID)
		local targetPet = targetPlayer.pets[target.petSlot]

		if (target and target.newStatus) then
			targetPet.status = target.newStatus
		end
	end

	-- check if we need to perform a special trap visual
	local player = nil
	if (effect.casterPlayerID > 0) then
		player = GetTeamByIndex(effect.casterPlayerID)
	end

	if (player) then
		if (effect.abilityVisualID == player.trapVisualID) then
			TrapCast(effect)
		end
	end
end
"	0	0
427	"zzOld - PetBattle(fallback) - Event Move Trap Selected"	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected()

	-- print(\"Move Selected: Trap\")
	StartTrapPrecast(observingPlayerIndex)

end

function GetTrapVisuals(playerID)

	local player = nil
	local playerDisplay = nil
	if (playerID and (playerID > 0)) then
		player = GetTeamByIndex(playerID)
		if (player) then
			playerDisplay = player.playerDisplay
		end
	end
	
	if (not playerDisplay) then
		return
	end

	if (not player.trapVisualID) then
		return
	end

	local trapVisual = petAbilityVisuals[player.trapVisualID]
	local trapSpellVisualID = nil
	if (trapVisual) then
		trapSpellVisualID = trapVisual.spellVisualID
	end

	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then
		return
	end

	return player, playerDisplay, trapVisual, trapSpellVisualID
end

function StartTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (playerDisplay) then
		if (not player.trapPrecastID) then
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID )
		end
	end

end

function ClearTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (player.trapPrecastID) then
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)
		player.trapPrecastID = nil
	end

end

function TrapCast(effect)

	local playerID = effect.casterPlayerID

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)

	if (not player) then
		return
	end

--	print(\"Casting Trap...\")

	StartTrapPrecast(playerID)
	scene:WaitTimer(trapVisual.castTime)
	ClearTrapPrecast()

	for targetIndex, target in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(target.playerID)
		local targetPet = targetPlayer.pets[target.petSlot]

		if (targetPet) then
			local trapSuccess = false
			if (targetPet.status) then
				trapSuccess = targetPet.status.isTrapped
			end

			castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})
			scene:WaitTimer(trapVisual.impactTime)

			local waitCondition = function()
				return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)
			end
			scene:WaitCondition(waitCondition)

			if (trapSuccess) then
				--print(\"Succesful Trap\")
				targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)
			else
				print(\"Failed Trap\")
			end
		end
	end

end
"	0	0
535	"zzOld - PetBattle(fallback) - Effect Processing"	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false

function ProcessAllRoundResults(allEffects)

	if (debugOn == true) then
		print(\"== Round Result Grouping ==\")
	end

	-- group on (turnInstanceID, effectID, stackDepth)

	-- build an effect tree, taking into account procs
	local turnGroups = { }
	local effectGroups = { }
	
	-- top level turns that we will process
	local topLevelTurnGroups = { }
	
	-- generate groups, and a  mapping from effectIndex
	local lastEffect = nil
	for effectIndex, effect in pairs(allEffects) do
		local turnKey
		local effectKey
		turnKey, effectKey = GenerateUniqueGroupKeys(effect)

		-- find or build a turn group as necessary
		local turnGroup = turnGroups[turnKey]
		if (not turnGroup) then
			turnGroup =
			{
				key = turnKey;
				firstEffect = effect;
				effects = { };
			}
			turnGroups[turnKey] = turnGroup
			
			if (effect.stackDepth <= 1) or (not lastEffect) then
				if (not table) then
					topLevelTurnGroups[#topLevelTurnGroups + 1] = turnGroup
				else
					table.insert(topLevelTurnGroups, turnGroup)
				end
			else
				-- this is a proc off of the last effect, and should be attached as a child
				lastEffect.procGroup = turnGroup
			end

			if (debugOn == true) then
				print(\"+ New Turn Group, turnID = \" .. effect.turnInstanceID .. \", depth = \" .. effect.stackDepth)
			end
		end
		
		-- find or build an effect group as necessary
		local effectGroup = effectGroups[effectKey]
		if (not effectGroup) then
			effectGroup =
			{
				key = efffectKey;
				firstEffect = effect;
				results = { };
			}
			effectGroups[effectKey] = effectGroup
			
			-- this is a new effect group, link it to the end of our parent turn group
			if (not table) then
				turnGroup.effects[#turnGroup.effects + 1] = effectGroup
			else
				table.insert(turnGroup.effects, effectGroup)
			end

			if (debugOn == true) then
				print(\"+   New Effect Group, effectID = \" .. effect.abilityEffectID)
			end
		end
		
		-- add this effect to the end of the group list
		if (not table) then
			effectGroup.results[#effectGroup.results + 1] = effect
		else
			table.insert(effectGroup.results, effect)
		end

		if (debugOn == true) then
			print(\"+     New Result, instanceID = \" .. effect.instanceID)
		end
		
		lastEffect = effect
	end

	if (debugOn == true) then
		print(\"  \")
		print(\"== Start Round Playback ==\")
	end
	
	-- process top level turns in order
	for index, turnGroup in pairs(topLevelTurnGroups) do
		ProcessRoundTurnGroup(turnGroup)
	end

	if (debugOn == true) then
		print(\"== End Round Playback ==\")
		print(\"  \")
	end

end

--------------------------------------------------------------------------------
function ProcessRoundTurnGroup(turnGroup)
	if (debugOn == true) then
		print(\"- Processing Turn \" .. turnGroup.firstEffect.turnInstanceID)
	end

	-- use a custom script handler if we have one
	local turnVisual = nil
	if (turnGroup.firstEffect.turnVisualID) then
		turnVisual = petAbilityVisuals[turnGroup.firstEffect.turnVisualID]
	end
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		if ( turnVisual.scriptFunction( turnGroup ) ) then
			processed = true
		end
	end

	-- fallback processing
	if (processed ~= true) then
		for index, effectGroup in pairs(turnGroup.effects) do
			ProcessRoundEffectGroup(effectGroup)
		end
	end
end

--------------------------------------------------------------------------------
function ProcessRoundEffectGroup(effectGroup)
	if (debugOn == true) then
		print(\"-   Processing Effect \" .. effectGroup.firstEffect.abilityEffectID)
	end

	-- use a custom script handler if we have one
	local effectVisual = nil
	if "	0	554
536	"[1] zzOld - PetBattle(fallback) - Functions"	"then
		attackRadius = rangedRadius
	end
	return attackRadius
end

"	331	0
538	"Jade Forest - Stay a While Scene - Init - JSB"	"
-- spawn cho
local choCreatureID = 55768
cho = SpawnActor( choCreatureID, 2130.74, -474.679, 392.885, 29, 1.0, false )
cho:PlayLoopingFullBodyAnim(Animations.SitGround)

-- spawn Mist
local mistModel = \"world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"
mist = SpawnModelActor( mistModel, 2127.5, -476.5, 398, 27.4498, 2.0, false )
FadeOut( mist, 0 )

-- spawn mogu
local moguCreatureID = 63143
mogu = SpawnActor( moguCreatureID, 2128.1, -475.986, 395, 354, 1.5, false )
mogu:PlayLoopingAnimKit(2442)
FadeOut( mogu, 0 )
"	0	0
539	"Jade Forest - Stay a While Scene - Cho - JSB"	"
Wait( 5 )
cho:StopLoopingFullBodyAnim()
cho:PlayOneShotFullBodyAnim(Animations.SitGroundUp)

Wait( 2 )
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)
-- say \"Thanks to your actions, the Hozen fear your people. Indulge me a moment...\"
Wait( 4 )

RunToLocation( cho, 2, 2141.74, -476.905, 392.37, 330.525 )
Wait( 1 )

cho:PlayLoopingFullBodyAnim(Animations.EmoteUseStanding)
Wait( 2 )
cho:StopLoopingFullBodyAnim()
Wait( 0.5 )
cho:SetFacing(128)

cho:PlayLoopingFullBodyAnim(Animations.EmoteReadLoop)
-- say \"Ah! Here we are. Over 14,000 years ago, this entire land was ruled by a terrible race of warlords called \'The mogu\'.\"

SendTrigger( \"moguAppear\" )
Wait( 12 )

-- say \"The mogu ruled through FEAR. And fear kept them in power - until the first Pandaren monks taught my people COURAGE. And the mogu were overthrown.\"
cho:StopLoopingFullBodyAnim()
RunToLocation( cho, 2, 2135.42, -476.072, 392.935, 205.425 )
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)
Wait( 6 )
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)

SendTrigger( \"moguDisappear\" )

Wait( 3 )

cho:SetFacing(66)

-- say \"You see, those who lead through fear only stay in power while those they govern lack courage.\"
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)
Wait( 5 )

RunToLocation( cho, 2, 2130.74, -474.679, 392.885, 29 )
-- say \"The hozen are many things, but they are not cowards - not for long. To lead them, you must inspire them!\"
cho:PlayOneShotFullBodyAnim(Animations.EmoteNo)
Wait( 5 )
cho:PlayOneShotFullBodyAnim(Animations.SitGroundDown)
Wait( 3.27 )
cho:PlayLoopingFullBodyAnim(Animations.SitGround)

Wait( 5 )
cho:Despawn()

"	0	0
540	"Jade Forest - Stay a While Scene - Mist - JSB"	"
WaitForTrigger( \"moguAppear\" )

FadeIn( mist, 3 )

-- Wait( 4 )

-- FadeOut( mist, 5)


WaitForTrigger( \"moguDisappear\" )

FadeIn( mist, 3 )

Wait( 4 )

FadeOut( mist, 3)"	0	0
541	"Jade Forest - Stay a While Scene - Mogu - JSB"	"
WaitForTrigger( \"moguAppear\" )
Wait( 2 )
FadeIn( mogu, 7 )


WaitForTrigger( \"moguDisappear\" )

Wait( 3 )

FadeOut( mogu, 3)"	0	0
542	"Great Wall - Mantid Army - Init 1"	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213



mantid1 = SpawnActor( mantidCreatureID, 1106.48, 2541.46, 325.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 1116.48, 2541.46, 325.392, 270.609, 1.0, true )
mantid3 = SpawnActor( mantidCreatureID, 1126.48, 2541.46, 325.392, 270.609, 1.0, true )
mantid4 = SpawnActor( mantidCreatureID, 1106.48, 2531.46, 328.746, 261.158, 1.0, true )
mantid5 = SpawnActor( mantidCreatureID, 1116.48, 2531.46, 326.737, 266.243, 1.0, true )
mantid6 = SpawnActor( mantidCreatureID2, 1126.48, 2531.46, 325.609, 266.243, 1.0, true )
mantid7 = SpawnActor( mantidCreatureID, 1106.48, 2521.46, 327.364, 266.243, 1.0, true )
mantid8 = SpawnActor( mantidCreatureID, 1116.48, 2521.46, 328.796, 266.243, 1.0, true )
mantid9 = SpawnActor( mantidCreatureID, 1126.48, 2521.46, 329.763, 266.243, 1.0, true )
mantid10 = SpawnActor( mantidCreatureID, 1106.48, 2511.46, 329.416, 266.243, 1.0, true )
mantid11 = SpawnActor( mantidCreatureID, 1116.48, 2511.46, 328.912, 266.243, 1.0, true )

mantid12 = SpawnActor( mantidCreatureID, 1126.48, 2511.46, 328.912, 266.243, 1.0, true )
mantid13 = SpawnActor( mantidCreatureID, 1106.48, 2501.46, 327.876, 266.243, 1.0, true )
mantid14 = SpawnActor( mantidCreatureID2, 1116.48, 2501.46, 327.079, 266.243, 1.0, true )
mantid15 = SpawnActor( mantidCreatureID, 1126.48, 2501.46, 326.181, 266.243, 1.0, true )
mantid16 = SpawnActor( mantidCreatureID, 1106.48, 2491.46, 326.373, 266.243, 1.0, true )
mantid17 = SpawnActor( mantidCreatureID, 1116.48, 2491.46, 328.377, 266.243, 1.0, true )
mantid18 = SpawnActor( mantidCreatureID, 1126.48, 2491.46, 328.589, 266.243, 1.0, true )
mantid19 = SpawnActor( mantidCreatureID, 1106.48, 2481.46, 328.993, 266.243, 1.0, true )
mantid20 = SpawnActor( mantidCreatureID, 1116.48, 2481.46, 329.241, 266.243, 1.0, true )
mantid21 = SpawnActor( mantidCreatureID, 1126.48, 2481.46, 329.595, 266.243, 1.0, true )

mantid22 = SpawnActor( mantidCreatureID2, 1106.48, 2471.46, 330.094, 266.243, 1.0, true )
mantid23 = SpawnActor( mantidCreatureID, 1116.48, 2471.46, 330.459, 264.668, 1.0, true )
mantid24 = SpawnActor( mantidCreatureID, 1126.48, 2471.46, 330.761, 264.668, 1.0, true )
mantid25 = SpawnActor( mantidCreatureID, 1106.48, 2461.46, 331.059, 264.668, 1.0, true )
mantid26 = SpawnActor( mantidCreatureID, 1116.48, 2461.46, 330.907, 264.668, 1.0, true )
mantid27 = SpawnActor( mantidCreatureID, 1126.48, 2461.46, 329.844, 264.668, 1.0, true )
mantid28 = SpawnActor( mantidCreatureID, 1106.48, 2451.46, 327.626, 265.568, 1.0, true )
mantid29 = SpawnActor( mantidCreatureID, 1116.48, 2451.46, 326.966, 264.443, 1.0, true )
mantid30 = SpawnActor( mantidCreatureID, 1126.48, 2451.46, 326.434, 272.093, 1.0, true )

mantid31 = SpawnActor( mantidCreatureID, 1106.48, 2441.46, 326.216, 272.093, 1.0, true )
mantid32 = SpawnActor( mantidCreatureID, 1116.48, 2441.46, 326.166, 272.093, 1.0, true )
mantid33 = SpawnActor( mantidCreatureID, 1126.48, 2441.46, 325.404, 272.093, 1.0, true )
mantid34 = SpawnActor( mantidCreatureID, 1106.48, 2431.46, 326.117, 272.093, 1.0, true )
mantid35 = SpawnActor( mantidCreatureID, 1116.48, 2431.46, 326.701, 272.093, 1.0, true )
mantid36 = SpawnActor( mantidCreatureID2, 1126.48, 2431.46, 326.742, 272.093, 1.0, true )
mantid37 = SpawnActor( mantidCreatureID, 1106.48, 2421.46, 326.924, 272.093, 1.0, true )
mantid38 = SpawnActor( mantidCreatureID, 1116.48, 2421.46, 327.336, 272.093, 1.0, true )
mantid39 = SpawnActor( mantidCreatureID, 1126.48, 2421.46, 327.936, 272.093, 1.0, true )

mantid40 = SpawnActor( mantidCreatureID, 1106.48, 2411.46, 328.895, 272.093, 1.0, true )
mantid41 = SpawnActor( mantidCreatureID, 1116.48, 2411.46, 329.115, 279.294, 1.0, true )
mantid42 = SpawnActor( mantidCreatureID, 1126.48, 2411.46, 328.474, 279.294, 1.0, true )
mantid43 = SpawnActor( "	0	545
543	"Great Wall - Mantid Army - Init 2"	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 1061.51, 2554.46, 305.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 1051.51, 2554.46, 305.392, 270.609, 1.0, true )
mantid3 = SpawnActor( mantidCreatureID, 1041.51, 2554.46, 305.392, 270.609, 1.0, true )
mantid4 = SpawnActor( mantidCreatureID2, 1061.51, 2544.46, 305.746, 261.158, 1.0, true )
mantid5 = SpawnActor( mantidCreatureID, 1051.51, 2544.46, 305.737, 266.243, 1.0, true )
mantid6 = SpawnActor( mantidCreatureID, 1041.51, 2544.46, 305.609, 266.243, 1.0, true )
mantid7 = SpawnActor( mantidCreatureID, 1061.51, 2521.46, 305.364, 266.243, 1.0, true )
mantid8 = SpawnActor( mantidCreatureID, 1051.51, 2521.46, 305.796, 266.243, 1.0, true )
mantid9 = SpawnActor( mantidCreatureID, 1041.51, 2521.46, 305.763, 266.243, 1.0, true )
mantid10 = SpawnActor( mantidCreatureID, 1061.51, 2511.46, 305.416, 266.243, 1.0, true )
mantid11 = SpawnActor( mantidCreatureID, 1051.51, 2511.46, 305.912, 266.243, 1.0, true )

mantid12 = SpawnActor( mantidCreatureID, 1041.51, 2511.46, 305.912, 266.243, 1.0, true )
mantid13 = SpawnActor( mantidCreatureID, 1061.51, 2501.46, 305.876, 266.243, 1.0, true )
mantid14 = SpawnActor( mantidCreatureID, 1051.51, 2501.46, 305.079, 266.243, 1.0, true )
mantid15 = SpawnActor( mantidCreatureID, 1041.51, 2501.46, 305.181, 266.243, 1.0, true )
mantid16 = SpawnActor( mantidCreatureID, 1061.51, 2491.46, 305.373, 266.243, 1.0, true )
mantid17 = SpawnActor( mantidCreatureID, 1051.51, 2491.46, 305.377, 266.243, 1.0, true )
mantid18 = SpawnActor( mantidCreatureID, 1041.51, 2491.46, 305.589, 266.243, 1.0, true )
mantid19 = SpawnActor( mantidCreatureID2, 1061.51, 2481.46, 305.993, 266.243, 1.0, true )
mantid20 = SpawnActor( mantidCreatureID, 1051.51, 2481.46, 305.241, 266.243, 1.0, true )
mantid21 = SpawnActor( mantidCreatureID, 1041.51, 2481.46, 305.595, 266.243, 1.0, true )

mantid22 = SpawnActor( mantidCreatureID, 1061.51, 2471.46, 305.094, 266.243, 1.0, true )
mantid23 = SpawnActor( mantidCreatureID, 1051.51, 2471.46, 305.459, 264.668, 1.0, true )
mantid24 = SpawnActor( mantidCreatureID, 1041.51, 2471.46, 305.761, 264.668, 1.0, true )
mantid25 = SpawnActor( mantidCreatureID, 1061.51, 2461.46, 305.059, 264.668, 1.0, true )
mantid26 = SpawnActor( mantidCreatureID, 1051.51, 2461.46, 305.907, 264.668, 1.0, true )
mantid27 = SpawnActor( mantidCreatureID, 1041.51, 2461.46, 305.844, 264.668, 1.0, true )
mantid28 = SpawnActor( mantidCreatureID, 1061.51, 2451.46, 305.626, 265.568, 1.0, true )
mantid29 = SpawnActor( mantidCreatureID, 1051.51, 2451.46, 305.966, 264.443, 1.0, true )
mantid30 = SpawnActor( mantidCreatureID, 1041.51, 2451.46, 305.434, 272.093, 1.0, true )

mantid31 = SpawnActor( mantidCreatureID, 1061.51, 2441.46, 305.216, 272.093, 1.0, true )
mantid32 = SpawnActor( mantidCreatureID, 1051.51, 2441.46, 305.166, 272.093, 1.0, true )
mantid33 = SpawnActor( mantidCreatureID, 1041.51, 2441.46, 305.404, 272.093, 1.0, true )
mantid34 = SpawnActor( mantidCreatureID, 1061.51, 2431.46, 305.117, 272.093, 1.0, true )
mantid35 = SpawnActor( mantidCreatureID2, 1051.51, 2431.46, 305.701, 272.093, 1.0, true )
mantid36 = SpawnActor( mantidCreatureID, 1041.51, 2431.46, 305.742, 272.093, 1.0, true )
mantid37 = SpawnActor( mantidCreatureID, 1061.51, 2421.46, 305.924, 272.093, 1.0, true )
mantid38 = SpawnActor( mantidCreatureID2, 1051.51, 2421.46, 305.336, 272.093, 1.0, true )
mantid39 = SpawnActor( mantidCreatureID, 1041.51, 2421.46, 305.936, 272.093, 1.0, true )

mantid40 = SpawnActor( mantidCreatureID, 1061.51, 2411.46, 305.895, 272.093, 1.0, true )
mantid41 = SpawnActor( mantidCreatureID, 1051.51, 2411.46, 305.115, 279.294, 1.0, true )
mantid42 = SpawnActor( mantidCreatureID, 1041.51, 2411.46, 305.474, 279.294, 1.0, true )
mantid43 = SpawnActor( "	0	546
544	"Great Wall - Mantid Army - Init 3"	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 995.17, 2554.46, 300.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 980.17, 2554.46, 300.392, 270.609, 1.0, true )
mantid3 = SpawnActor( mantidCreatureID2, 965.17, 2554.46, 300.392, 270.609, 1.0, true )
mantid4 = SpawnActor( mantidCreatureID, 950.17, 2554.46, 300.746, 261.158, 1.0, true )
mantid5 = SpawnActor( mantidCreatureID, 995.17, 2544.46, 300.737, 266.243, 1.0, true )
mantid6 = SpawnActor( mantidCreatureID, 980.17, 2544.46, 300.609, 266.243, 1.0, true )
mantid7 = SpawnActor( mantidCreatureID, 965.17, 2544.46, 300.364, 266.243, 1.0, true )
mantid8 = SpawnActor( mantidCreatureID, 950.17, 2544.46, 300.796, 266.243, 1.0, true )
mantid9 = SpawnActor( mantidCreatureID, 995.17, 2534.46, 300.737, 266.243, 1.0, true )
mantid10 = SpawnActor( mantidCreatureID2, 980.17, 2534.46, 300.609, 266.243, 1.0, true )
mantid11 = SpawnActor( mantidCreatureID, 965.17, 2534.46, 300.364, 266.243, 1.0, true )
mantid12 = SpawnActor( mantidCreatureID, 950.17, 2534.46, 300.796, 266.243, 1.0, true )

mantid13 = SpawnActor( mantidCreatureID, 995.17, 2524.46, 300.737, 266.243, 1.0, true )
mantid14 = SpawnActor( mantidCreatureID, 980.17, 2524.46, 300.609, 266.243, 1.0, true )
mantid15 = SpawnActor( mantidCreatureID, 965.17, 2524.46, 300.364, 266.243, 1.0, true )
mantid16 = SpawnActor( mantidCreatureID, 950.17, 2524.46, 300.796, 266.243, 1.0, true )
mantid17 = SpawnActor( mantidCreatureID, 995.17, 2514.46, 300.737, 266.243, 1.0, true )
mantid18 = SpawnActor( mantidCreatureID, 980.17, 2514.46, 300.609, 266.243, 1.0, true )
mantid19 = SpawnActor( mantidCreatureID, 965.17, 2514.46, 300.364, 266.243, 1.0, true )
mantid20 = SpawnActor( mantidCreatureID, 950.17, 2514.46, 300.796, 266.243, 1.0, true )
mantid21 = SpawnActor( mantidCreatureID2, 995.17, 2504.46, 300737, 266.243, 1.0, true )
mantid22 = SpawnActor( mantidCreatureID, 980.17, 2504.46, 300.609, 266.243, 1.0, true )
mantid23 = SpawnActor( mantidCreatureID, 965.17, 2504.46, 300.364, 266.243, 1.0, true )
mantid24 = SpawnActor( mantidCreatureID, 950.17, 2504.46, 300.796, 266.243, 1.0, true )

mantid25 = SpawnActor( mantidCreatureID, 995.17, 2494.46, 300.737, 266.243, 1.0, true )
mantid26 = SpawnActor( mantidCreatureID, 980.17, 2494.46, 300.609, 266.243, 1.0, true )
mantid27 = SpawnActor( mantidCreatureID2, 965.17, 2494.46, 300.364, 266.243, 1.0, true )
mantid28 = SpawnActor( mantidCreatureID, 950.17, 2494.46, 300.796, 266.243, 1.0, true )
"	0	0
545	"[1] Great Wall - Mantid Army - Init 1"	"mantidCreatureID, 1106.48, 2401.46, 328.244, 279.294, 1.0, true )
mantid44 = SpawnActor( mantidCreatureID, 1116.48, 2401.46, 328.198, 279.294, 1.0, true )
mantid45 = SpawnActor( mantidCreatureID, 1126.48, 2401.46, 328.108, 279.294, 1.0, true )
mantid46 = SpawnActor( mantidCreatureID, 1106.48, 2391.46, 327.811, 279.294, 1.0, true )
mantid47 = SpawnActor( mantidCreatureID2, 1116.48, 2391.46, 327.493, 279.294, 1.0, true )
mantid48 = SpawnActor( mantidCreatureID, 1126.48, 2391.46, 327.196, 279.294, 1.0, true )"	542	0
546	"[1] Great Wall - Mantid Army - Init 2"	"mantidCreatureID, 1061.51, 2401.46, 305.244, 279.294, 1.0, true )
mantid44 = SpawnActor( mantidCreatureID, 1051.51, 2401.46, 305.198, 279.294, 1.0, true )
mantid45 = SpawnActor( mantidCreatureID, 1041.51, 2401.46, 305.108, 279.294, 1.0, true )
mantid46 = SpawnActor( mantidCreatureID, 1061.51, 2391.46, 305.811, 279.294, 1.0, true )
mantid47 = SpawnActor( mantidCreatureID2, 1051.51, 2391.46, 305.493, 279.294, 1.0, true )
mantid48 = SpawnActor( mantidCreatureID, 1041.51, 2391.46, 305.196, 279.294, 1.0, true )
"	543	0
548	"Great Wall - Mantid Army - Init 4"	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 876.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID2, 856.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid3 = SpawnActor( mantidCreatureID, 836.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid4 = SpawnActor( mantidCreatureID, 816.724, 2554.46, 311, 261.158, 1.0, true )
mantid5 = SpawnActor( mantidCreatureID, 876.724, 2544.46, 311.737, 266.243, 1.0, true )
mantid6 = SpawnActor( mantidCreatureID, 856.724, 2544.46, 311.609, 266.243, 1.0, true )
mantid7 = SpawnActor( mantidCreatureID, 836.724, 2544.46, 311.364, 266.243, 1.0, true )
mantid8 = SpawnActor( mantidCreatureID, 816.724, 2544.46, 311.796, 266.243, 1.0, true )
mantid9 = SpawnActor( mantidCreatureID, 876.724, 2534.46, 311.737, 266.243, 1.0, true )
mantid10 = SpawnActor( mantidCreatureID, 856.724, 2534.46, 311.609, 266.243, 1.0, true )
mantid11 = SpawnActor( mantidCreatureID2, 836.724, 2534.46, 311.364, 266.243, 1.0, true )
mantid12 = SpawnActor( mantidCreatureID, 816.724, 2534.46, 311.796, 266.243, 1.0, true )

mantid13 = SpawnActor( mantidCreatureID, 876.724, 2524.46, 311.737, 266.243, 1.0, true )
mantid14 = SpawnActor( mantidCreatureID2, 856.724, 2524.46, 311.609, 266.243, 1.0, true )
mantid15 = SpawnActor( mantidCreatureID, 836.724, 2524.46, 311.364, 266.243, 1.0, true )
mantid16 = SpawnActor( mantidCreatureID, 816.724, 2524.46, 311.796, 266.243, 1.0, true )
mantid17 = SpawnActor( mantidCreatureID, 876.724, 2514.46, 311.737, 266.243, 1.0, true )
mantid18 = SpawnActor( mantidCreatureID, 856.724, 2514.46, 311.609, 266.243, 1.0, true )
mantid19 = SpawnActor( mantidCreatureID, 836.724, 2514.46, 311.364, 266.243, 1.0, true )
mantid20 = SpawnActor( mantidCreatureID2, 816.724, 2514.46, 311.796, 266.243, 1.0, true )
mantid21 = SpawnActor( mantidCreatureID, 876.724, 2504.46, 311.737, 266.243, 1.0, true )
mantid22 = SpawnActor( mantidCreatureID, 856.724, 2504.46, 311.609, 266.243, 1.0, true )
mantid23 = SpawnActor( mantidCreatureID, 836.724, 2504.46, 311.364, 266.243, 1.0, true )
mantid24 = SpawnActor( mantidCreatureID, 816.724, 2504.46, 311.796, 266.243, 1.0, true )

mantid25 = SpawnActor( mantidCreatureID, 876.724, 2494.46, 311.737, 266.243, 1.0, true )
mantid26 = SpawnActor( mantidCreatureID2, 856.724, 2494.46, 311.609, 266.243, 1.0, true )
mantid27 = SpawnActor( mantidCreatureID, 836.724, 2494.46, 311.364, 266.243, 1.0, true )
mantid28 = SpawnActor( mantidCreatureID, 816.724, 2494.46, 311.796, 266.243, 1.0, true )
mantid29 = SpawnActor( mantidCreatureID, 876.724, 2484.46, 311.737, 266.243, 1.0, true )
mantid30 = SpawnActor( mantidCreatureID, 856.724, 2484.46, 311.609, 266.243, 1.0, true )
mantid31 = SpawnActor( mantidCreatureID, 836.724, 2484.46, 311.364, 266.243, 1.0, true )
mantid32 = SpawnActor( mantidCreatureID2, 816.724, 2484.46, 311.796, 266.243, 1.0, true )
mantid33 = SpawnActor( mantidCreatureID, 876.724, 2474.46, 311.737, 266.243, 1.0, true )
mantid34 = SpawnActor( mantidCreatureID, 856.724, 2474.46, 311.609, 266.243, 1.0, true )
mantid35 = SpawnActor( mantidCreatureID, 836.724, 2474.46, 311.364, 266.243, 1.0, true )
mantid36 = SpawnActor( mantidCreatureID, 816.724, 2474.46, 311.796, 266.243, 1.0, true )
"	0	0
550	"Great Wall - Mantid Army - Init 5"	"-- spawn mantid
local mantidCreatureID = 63560
local mantidCreatureID2 = 63561

mantid1 = SpawnActor( mantidCreatureID, 776.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID2, 756.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid3 = SpawnActor( mantidCreatureID, 736.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid4 = SpawnActor( mantidCreatureID, 716.724, 2554.46, 311, 261.158, 1.0, true )
mantid5 = SpawnActor( mantidCreatureID, 776.724, 2544.46, 311.737, 266.243, 1.0, true )
mantid6 = SpawnActor( mantidCreatureID2, 756.724, 2544.46, 311.609, 266.243, 1.0, true )
mantid7 = SpawnActor( mantidCreatureID, 736.724, 2544.46, 311.364, 266.243, 1.0, true )
mantid8 = SpawnActor( mantidCreatureID, 716.724, 2544.46, 311.796, 266.243, 1.0, true )
mantid9 = SpawnActor( mantidCreatureID2, 776.724, 2534.46, 311.737, 266.243, 1.0, true )
mantid10 = SpawnActor( mantidCreatureID, 756.724, 2534.46, 311.609, 266.243, 1.0, true )
mantid11 = SpawnActor( mantidCreatureID, 736.724, 2534.46, 311.364, 266.243, 1.0, true )
mantid12 = SpawnActor( mantidCreatureID, 716.724, 2534.46, 311.796, 266.243, 1.0, true )

mantid13 = SpawnActor( mantidCreatureID, 776.724, 2524.46, 311.737, 266.243, 1.0, true )
mantid14 = SpawnActor( mantidCreatureID, 756.724, 2524.46, 311.609, 266.243, 1.0, true )
mantid15 = SpawnActor( mantidCreatureID2, 736.724, 2524.46, 311.364, 266.243, 1.0, true )
mantid16 = SpawnActor( mantidCreatureID, 716.724, 2524.46, 311.796, 266.243, 1.0, true )
mantid17 = SpawnActor( mantidCreatureID, 776.724, 2514.46, 311.737, 266.243, 1.0, true )
mantid18 = SpawnActor( mantidCreatureID, 756.724, 2514.46, 311.609, 266.243, 1.0, true )
mantid19 = SpawnActor( mantidCreatureID, 736.724, 2514.46, 311.364, 266.243, 1.0, true )
mantid20 = SpawnActor( mantidCreatureID2, 716.724, 2514.46, 311.796, 266.243, 1.0, true )
mantid21 = SpawnActor( mantidCreatureID, 776.724, 2504.46, 311.737, 266.243, 1.0, true )
mantid22 = SpawnActor( mantidCreatureID, 756.724, 2504.46, 311.609, 266.243, 1.0, true )
mantid23 = SpawnActor( mantidCreatureID, 736.724, 2504.46, 311.364, 266.243, 1.0, true )
mantid24 = SpawnActor( mantidCreatureID, 716.724, 2504.46, 311.796, 266.243, 1.0, true )

mantid25 = SpawnActor( mantidCreatureID2, 776.724, 2494.46, 311.737, 266.243, 1.0, true )
mantid26 = SpawnActor( mantidCreatureID, 756.724, 2494.46, 311.609, 266.243, 1.0, true )
mantid27 = SpawnActor( mantidCreatureID, 736.724, 2494.46, 311.364, 266.243, 1.0, true )
mantid28 = SpawnActor( mantidCreatureID, 716.724, 2494.46, 311.796, 266.243, 1.0, true )
mantid29 = SpawnActor( mantidCreatureID, 776.724, 2484.46, 311.737, 266.243, 1.0, true )
mantid30 = SpawnActor( mantidCreatureID, 756.724, 2484.46, 311.609, 266.243, 1.0, true )
mantid31 = SpawnActor( mantidCreatureID2, 736.724, 2484.46, 311.364, 266.243, 1.0, true )
mantid32 = SpawnActor( mantidCreatureID, 716.724, 2484.46, 311.796, 266.243, 1.0, true )
mantid33 = SpawnActor( mantidCreatureID, 776.724, 2474.46, 311.737, 266.243, 1.0, true )
mantid34 = SpawnActor( mantidCreatureID2, 756.724, 2474.46, 311.609, 266.243, 1.0, true )
mantid35 = SpawnActor( mantidCreatureID, 736.724, 2474.46, 311.364, 266.243, 1.0, true )
mantid36 = SpawnActor( mantidCreatureID, 716.724, 2474.46, 311.796, 266.243, 1.0, true )
"	0	0
551	"[1] zzOld - PetBattle(fallback) - Init Player"	"pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetHidden(false)

					local targetAlpha = backlineAlpha
					if slot == player.activePet then
						-- use the front alpha if it is the active pet
						targetAlpha = GetAlpha(pet)
					end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	332	0
554	"[1] zzOld - PetBattle(fallback) - Effect Processing"	"(effectGroup.firstEffect.abilityVisualID) then
		effectVisual = petAbilityVisuals[effectGroup.firstEffect.abilityVisualID]
	end
	local processed = false
	if (effectVisual and effectVisual.scriptFunction) then
		if ( effectVisual.scriptFunction( effectGroup ) ) then
			processed = true
		end
	end

	-- fallback handling
	if (processed ~= true) then
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Process an individula Round Effect Result
function ProcessRoundResult(event)

	local eventType = event.eventType
	local effectType = event.effectType

	if not (eventType == PetBattleEvent.RoundEffect) then
		return
	end

	if (debugOn == true) then
		print(\"-     Processing Result \" .. event.instanceID)
	end

	-- battle round effects
	if (effectType == PetBattleEffect.SetHealth) then
		EffectSetHealth(event)
	elseif (effectType == PetBattleEffect.AuraApply) then
		EffectAuraApply(event)
	elseif (effectType == PetBattleEffect.AuraCancel) then
		EffectAuraChange(event, true)
	elseif (effectType == PetBattleEffect.AuraChange) then
		EffectAuraChange(event, false)
	elseif (effectType == PetBattleEffect.PetSwap) then
		if(#event.targets > 0) then
			EffectSwap(event.targets[1].playerID, event.newFrontPet)
		else 
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		end
	elseif (effectType == PetBattleEffect.StatusChange) then
		EffectStatusChange(event)
	elseif (effectType == PetBattleEffect.SetState) then
		EffectSetState(event)
	end

end

--------------------------------------------------------------------------------
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn

--------------------------------------------------------------------------------
function GenerateUniqueGroupKeys(effect)	
	local stackDepth = effect.stackDepth or 0
	local turnInstanceID = effect.turnInstanceID or 0
	local effectID = effect.abilityEffectID or 0
	if (stackDepth > maxStackDepth) then
		print (\"WARNING: stack depth exceeded \" .. maxStackDepth)
	end
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then
		print (\"WARNING: max turn instanceIDs exceeded \" .. maxTurnInstanceIDs)
	end
	
	local turnKey = turnInstanceID*maxStackDepth + stackDepth
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey
	return turnKey, effectKey
end

"	535	0
555	"[1] zzOld - PetBattle(fallback) - Event Processing"	"
	end

end

"	333	0
556	"Valley of the Four Winds - Stoneplow Finale - Init Friends - PRK"	"paradeSpeed = 6

-- wall cap
local wallModel = \"WORLD\\EXPANSION04\\DOODADS\\VALEOFETERNALBLOSSOMS\\GREATWALL_CAP\\PA_GreatWall_Cap_01.M2\"
local walls = SpawnModelActorsAtPoints( wallModel, 3389, false )
wall = walls[1]

-- loon mai
loon = SpawnActorAtPoint( 63374, 3368, false )
-- leven dawnblade
leven = SpawnActorAtPoint( 63377, 3369, false )

-- fo sho knucklebump
fosho = SpawnActorAtPoint( 63378, 3370, false )
fosho:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
-- ko-yan na
koyan = SpawnActorAtPoint( 63379, 3371, false )
koyan:PlayLoopingSplitBodyAnim(Animations.Ready1H)
-- jooru
jooru = SpawnActorAtPoint( 63380, 3372, false )
jooru:PlayLoopingSplitBodyAnim(Animations.ReadySpellDirected)

--farmers, kids
farmerA = SpawnActorAtPoint(63409, 3391, false)
farmerB = SpawnActorAtPoint(63412, 3392, false)
farmerC = SpawnActorAtPoint(63410, 3393, false)
kidA = SpawnActorAtPoint(63405, 3394, false)
kidB = SpawnActorAtPoint(63406, 3395, false)
kidC = SpawnActorAtPoint(63407, 3396, false)
kidD = SpawnActorAtPoint(63408, 3397, false)
kidE = SpawnActorAtPoint(63411, 3398, false)



-- hidden master
hiddenmaster = SpawnFadedActorAtPoint( 63385, 3377, false)
-- lin tenderpaw
lin = SpawnFadedActorAtPoint( 63386, 3378, false)
-- xiao
xiao = SpawnFadedActorAtPoint( 63387, 3379, false)
-- kang bramblestaff
kang = SpawnFadedActorAtPoint( 63388, 3380, false)
-- ken-ken
kenken = SpawnFadedActorAtPoint( 63389, 3381, false)
-- clever ashyo
ashyo = SpawnFadedActorAtPoint( 63390, 3382, false )

-- chen
chen = SpawnFadedActorAtPoint( 63381, 3373, false )
-- li li
lili = SpawnFadedActorAtPoint( 63382, 3374, false )
-- mudmug
mudmug = SpawnFadedActorAtPoint( 63383, 3375, false )

-- dezco
dezco = SpawnFadedActorAtPoint( 63394, 3385, false )
braveA = SpawnFadedActorAtPoint( 63398, 3399, false )
braveB = SpawnFadedActorAtPoint( 63398, 3400, false )
braveC = SpawnFadedActorAtPoint( 63398, 3401, false )
braveD = SpawnFadedActorAtPoint( 63398, 3407, false )

-- lyalia
lyalia = SpawnFadedActorAtPoint( 63395, 3386, false )
sentinelA = SpawnFadedActorAtPoint( 63399, 3402, false )
sentinelB = SpawnFadedActorAtPoint( 63399, 3403, false )
sentinelC = SpawnFadedActorAtPoint( 63399, 3404, false )
sentinelD = SpawnFadedActorAtPoint( 63399, 3408, false )

-- koro
koro = SpawnFadedActorAtPoint( 63384, 3376, false )
monkA = SpawnFadedActorAtPoint( 63397, 3413, false )
monkB = SpawnFadedActorAtPoint( 63397, 3414, false )
monkC = SpawnFadedActorAtPoint( 63397, 3415, false )
monkD = SpawnFadedActorAtPoint( 63397, 3416, false )
priestA = SpawnFadedActorAtPoint( 63451, 3417, false )
priestB = SpawnFadedActorAtPoint( 63451, 3418, false )
priestC = SpawnFadedActorAtPoint( 63451, 3419, false )
priestD = SpawnFadedActorAtPoint( 63451, 3420, false )


-- yi-mo
yimo = SpawnFadedActorAtPoint( 63396, 3387, false )
wardenA = SpawnFadedActorAtPoint( 63400, 3405, false )
wardenB = SpawnFadedActorAtPoint( 63400, 3406, false )
wardenC = SpawnFadedActorAtPoint( 63400, 3409, false )
wardenD = SpawnFadedActorAtPoint( 63400, 3410, false )
wardenE = SpawnFadedActorAtPoint( 63400, 3411, false )
wardenF = SpawnFadedActorAtPoint( 63400, 3412, false )


-- miss fanny
missfanny = SpawnFadedActorAtPoint( 63392, 3384, false)
-- pang
pang = SpawnFadedActorAtPoint( 63391, 3383, false)

"	0	0
557	"PetBattle - Constants"	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
playerRadius   = 5.0
idleRadius     = 2.0
readyRadius    = 1.25
rangedRadius   = 0.5
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.25

--------------------------------------------------------------------------------
-- pad
padModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
padAlpha = 1.0
padScale = 1.0

--------------------------------------------------------------------------------
-- arena
arenaRingModel = \"SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"
arenaRingAlpha = 0.5
arenaRingScale = 1.0
arenaFadeTime = 5.0

--------------------------------------------------------------------------------
-- camera
freelookZoomMin = 5
freelookZoomMax = 12
freelookZoomStart = 9.0
useFreelookCamera = true
if (not Scene.SetGameCameraTarget) then
	useFreelookCamera = false
end

battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand 			= 2267;
	Death 			= 2268;
	Dead  			= 2269;
	StandHoldDecay 	= 2133;
}
"	0	0
558	"PetBattle - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end


function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector( (pet.teamFacing or 0.0), idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	return attackRadius
end
"	0	0
560	"PetBattle - Init Player"	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	padCreateData.interactible = false
	if (PetBattleScene.SpawnPet) then
		padActor = battleScene:SpawnPet(playerID, PetBattlePetID.Pad, padCreateData)
	else
		padActor = scene:SpawnActor(padCreateData)
	end
	padActor:Fade(padAlpha, 0)

	-- spawn NPC character
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)
		local npcCreateData = ActorCreateData:Default()
		npcCreateData.creatureID = team.npcCreatureID
		npcCreateData.creatureDisplayID = team.npcDisplayID
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)
		npcCreateData.interactible = false
		team.npcActor = scene:SpawnActor(npcCreateData)
		team.playerDisplay = team.npcActor
	end

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }
		pet.playerID = playerID
		team.pets[id] = pet

		if (id == PetBattlePetID.Pad) then
			pet.isPad = true
			pet.actor = padActor
			team.pad = pet
		else			
			pet.isPad = false
			local radius = backlineRadius
			local offset = 0
			if id == team.activePet then
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
					radius = backlineRadius
				else
					radius = idleRadius
				end
			else
				offset = backLineOffset
				backLineOffset = backLineOffset + backlineSpacing
			end
			
			local pos = BuildVector(team.teamFacing, -radius, offset)
			local transform = Transform:New(pos, team.teamFacing)
			
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
			petCreateData.creatureDisplayID = petDesc.displayID or 0

			pet.actor = scene:SpawnActor(petCreateData)

			SetXP(pet, petDesc.xp, petDesc.level, true)
			SetHealth(pet, petDesc.health, true)

			pet.status = petDesc.status

			pet.currentRadius = radius
			pet.currentOffset = offset

			-- always face the opponent location (at idleRadius)
			LookAtOpposingTeam(pet)


			-- hide all pets until loaded
			pet.actor:SetInteractible(false)
			pet.actor:SetHidden(true)
			pet.actor:Fade(0, 0)
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
		end

		-- apply initial auras
		for auraIndex, auraData in pairs(petDesc.auras or { }) do
			local auraVisual = petAbilityVisuals[auraData.auraVisualID]
			if (auraVisual) then
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
			end
		end
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			if ( player.pets ) then 
				for slot, pet in pairs ( player.pets ) do
					if not pet.actor:IsReadyToDisplay() then
						return false
					end
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetHidden(false)

				"	0	561
561	"[1] PetBattle - Init Player"	"	local targetAlpha = backlineAlpha
					if slot == player.activePet then
						-- use the front alpha if it is the active pet
						targetAlpha = GetAlpha(pet)
					end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	560	0
562	"PetBattle - Play Spell Effect"	"
--------------------------------------------------------------------------------
function SpellEffectPlayShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]

	local targetPlayerID = targetData.playerID;
	local targetPlayer = GetTeamByIndex(targetPlayerID)
	local targetPet = targetPlayer.pets[targetData.petSlot]

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local casterCastingPet, spellVisualID = PerformSpellVisual(casterCastingPet, abilityVisualID, targetPet)

	return casterCastingPet, spellVisualID 
end

--------------------------------------------------------------------------------
function MovePetToFrontLines(pet, opponent, range )
--[[
	-- Move pet if its the current pet
	if ( (casterPlayer.activePet == effect.casterPetSlot) and (not casterFrontPet.deathAnimKit) ) then 
		MovePetToFrontLines(casterFrontPet, opponentFrontPet, abilityVisual.range )
	end

	-- Wait for opponent
	WaitForOpponentPet(opponentFrontPet)
]]--
	PetMoveToAttackPosition(pet, opponent, range );
end

function WaitForOpponentPet(opponent)
	-- make sure the opponent pet is at the correct radius
	if not opponent.deathAnimKit then
		WaitMoveToRadius(opponent, readyRadius)
	end
end

-- Remapping his function to be more genericl
function PerformSpellVisual(casterCastingPet, abilityVisualID, targetPet)
	PerformSpellVisualManyTargets(casterCastingPet, abilityVisualID, {targetPet})
end

function PerformSpellVisualManyTargets(casterCastingPet, abilityVisualID, targetList)
	--
	-- Actually cast
	--	

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end
	local spellVisualID = abilityVisual.spellVisualID

	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for PerformSpellVisual\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	local targetActors = {};
	for k, v in pairs(targetList) do
		table.insert(targetActors, v.actor);
	end

	if ( #targetActors > 1 or casterCastingPet.actor ~= targetActors[1] ) then
		casterCastingPet.actor:PlaySpellCastVisualAtTargets(
			spellVisualID,
			abilityVisual.impactTime,
			true,
			targetActors)
	else
		-- self targeted
		casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return casterCastingPet, spellVisualID

end"	0	0
563	"PetBattle - Result - Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

--	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player point
	if (team.playerDisplay) then
		team.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		lastPet.actor:Fade(0, backlineFadeTime)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forward then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
564	"PetBattle - Result - Set Health"	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect, dontWait)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for SetHealth\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local playersWithDeaths = { }
	local playersWithKills = { }

	local isCritical = false
	if (effect.flags and effect.flags.crit) then
		isCritical = true
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.flags and effect.flags.miss == true) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)	
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		local oldHealth = targetPet.currentHealth
		local newHealth = effect.value	-- actual health change is stored in the value field

		SetHealth(targetPet, newHealth, false, isCritical)

		if (newHealth <= 0) and (oldHealth > 0) then
			playersWithDeaths[effect.casterPlayerID] = true
			if (effectSourcePet) then
				playersWithKills[effect.casterPlayerID] = true
			end
		end
	end

	-- feedback on players that lost pets
	for playerID, hasDeath in pairs(playersWithDeaths) do
		if (hasDeath) then
			playersWithKills[playerID] = nil
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)
			end
		end
	end

	-- feedback on players that killed pets
	for playerID, hasKill in pairs(playersWithKills) do
		if (hasKill) then
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)
			end
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) and (effectSourceActor) then
		effectSourceActor:WaitCastingComplete(true)
	end
end"	0	0
565	"PetBattle - Result - Aura Apply"	"
-- store a mapping of all active auras to the pet they\'re on
local activeAuraPets = { }

--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	local auraSpellVisualID = 0
	local auraVisual = GetAuraAbilityVisual(effect.auraAbilityID)
	if (auraVisual) then
		auraSpellVisualID = auraVisual.spellVisualID
	end

	local casterCastingPet
	local spellVisualID
	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no auraVisual for aura\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		-- apply an aura, tracked by instance ID
		ApplyAura(targetPet, effect.auraInstanceID, effect.auraTurnsRemaining, auraSpellVisualID)
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		effectSourceActor:WaitCastingComplete(true)
	end
end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	activeAuraPets[auraInstanceID] = pet

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	if (aura.spellVisualID) then
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	else
		aura.spellVisualInstanceID = nil
	end
	aura.turnsRemaining = turnsRemaining

	return aura;
end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil
	activeAuraPets[auraInstanceID] = nil
end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end

"	0	777
566	"PetBattle - Result - Aura Change"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	target = effect.target
	local petPlayerID = target.playerID
	local petSlot = target.petSlot

	local player = GetTeamByIndex(petPlayerID)
	local pet = player.pets[petSlot]

	if not petSlot then
		return
	end

	local auraInstanceID = target.auraInstanceID
	local aura = pet.auras[auraInstanceID]
	if not aura then
		print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
		return
	end

	if (cancel == true) or (target.turnsRemaining < 1) then
		RemoveAura(pet, auraInstanceID)
	else
		aura.turnsRemaining = target.turnsRemaining
	end

end
"	0	0
567	"PetBattle - Result - Status Change"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	target = effect.target
	local targetPlayer = GetTeamByIndex(target.playerID)
	local targetPet = targetPlayer.pets[target.petSlot]

	if (target and target.newStatus) then
		targetPet.status = target.newStatus
	end

	-- check if we need to perform a special trap visual
	local player = nil
	if (effect.casterPlayerID > 0) then
		player = GetTeamByIndex(effect.casterPlayerID)
	end

	if (player) then
		if (effect.abilityVisualID == player.trapVisualID) then
			TrapCast(effect)
		end
	end
end
"	0	0
568	"PetBattle - 2. Pre-Playback Processing"	"--------------------------------------------------------------------------------
-- Group and process all round effects

local processDebug = false;

function ProcessAllRoundResults(allEvents)

	if ( processDebug ) then 
		DebugPrint(\"== Round Result Grouping ==\")
	end

	-- group on (turnInstanceID, effectID, stackDepth)

	-- build an effect tree, taking into account procs
	local turnGroups = { }
	local effectGroups = { }
	
	-- top level turns that we will process
	local topLevelTurnGroups = { }
	
	-- generate groups, and a  mapping from effectIndex
	local lastEffect = nil
	for eventIndex, event in pairs(allEvents) do
		local turnKey
		local effectKey
		turnKey, effectKey = GenerateUniqueGroupKeys(event)

		local abilityEffect 	
		local abilityEffectType 
		local abilityTurn 		
		local ability 			

		local abilityID
		local abilityVisualID 			
		local turnVisualID				
		local effectVisualID 			
		local effectFallbackVisualID	

		-- Load up the relevant spell data
		abilityEffect 	= GetAbilityEffect(event.effectID);
		if ( abilityEffect ) then 
			abilityEffectType 	= GetAbilityEffectType(abilityEffect.effectType)
			abilityTurn 		= GetAbilityTurn(abilityEffect.turnID)
			ability 			= GetAbility(abilityTurn.abilityID)

			abilityID 				= ability.ID;
			abilityVisualID 		= ability.visualID
			turnVisualID			= abilityTurn.visualID
			effectVisualID 			= abilityEffect.visualID
			effectFallbackVisualID	= abilityEffectType.visualID
		end

		-- find or build a turn group as necessary
		local turnGroup = turnGroups[turnKey]
		if (not turnGroup) then
			turnGroup =
			{
				key = turnKey;
				turnInstanceID = event.turnInstanceID;
				firstEvent = FilterResultEventsByType(event);
				effects = { };

				turnVisualID = turnVisualID;
				abilityID = abilityID;
				playerID = event.casterPlayerID or event.targetPlayerID;
				petSlot = event.casterPetSlot or event.targetPetSlot;
			}
			turnGroup = FilteredEventMetaTable( turnGroup )
			turnGroups[turnKey] = turnGroup
			
			if (event.stackDepth <= 1) or (not lastEffect) then
				table.insert(topLevelTurnGroups, turnGroup)
			else
				-- this is a proc off of the last effect, and should be attached as a child
				lastEffect.procGroup = turnGroup
			end
		
			if ( processDebug ) then 
				DebugPrint(\"+ New Turn Group, turnID = \" .. event.turnInstanceID .. \", depth = \" .. event.stackDepth
					..\", ability: \"..event.abilityID..\", turn = \"..event.abilityTurnID);
			end
		end
		
		-- find or build an effect group as necessary
		local effectGroup = effectGroups[effectKey]
		if (not effectGroup) then
			effectGroup =
			{
				key = effectKey;
				firstEvent = FilterResultEventsByType(event);
				results = { };
				
				effectID				= event.effectID;
				effectVisualID 			= effectVisualID;
				effectFallbackVisualID 	= effectFallbackVisualID;
				targetPlayerID 			= event.targetPlayerID;
				targetPetSlot 			= event.targetPetSlot;
			}
			--effectGroup = FilteredEventMetaTable( effectGroup )

			effectGroups[effectKey] = effectGroup

		
			-- this is a new effect group, link it to the end of our parent turn group
			table.insert(turnGroup.effects, effectGroup)

			if ( processDebug ) then
				local effectName = \"Unknown\";

				for k,v in pairs(PetBattleEffect) do 
					if ( v == effect.effectType ) then
						effectName = k;
					end
				end

				DebugPrint(\"+   New Effect Group, effectID = \" .. effect.abilityEffectID..\" effectType: \"..effectName)
			end
		end


		-- add this effect to the end of the group list
		local filteredEvent = FilterResultEventsByType(event)
		table.insert(effectGroup.results, filteredEvent)

		if ( processDebug ) then

			local effectName = \"Unknown\";

			for k,v in pairs(PetBattleEffect) do 
				if ( v == event.effectType ) then
					"	0	614
570	"PetBattle - Reward XP and Level"	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = GetTeamByIndex(reward.playerID)
			local playerPet = player.pets[reward.petSlot]
			if (playerPet) then
				local rewardedPet =
				{
					pet = playerPet;
					newXP = reward.newXP;
					newLevel = reward.newLevel;
				}
				rewardedPets[rewardIndex] = rewardedPet

				-- resurrect and move this pet up
				if (playerPet.deathAnimKit) then
					playerPet.deathAnimKit:Stop()
					playerPet.deathAnimKit = nil		
				end

				playerPet.actor:Fade(1.0, backlineFadeTime)
				MoveToVictoryLocation(playerPet);
			end
		end
	end

	-- wait until all pets have stopped moving
	local waitCondition = function()
		-- all actors must be renderable
		for prewardIndex,rewardedPet in pairs(rewardedPets) do
			if rewardedPet.pet.actor:IsMoving() then
				return false
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

	-- apply the rewards
	for rewardIndex,rewardedPet in pairs(rewardedPets) do
		SetXP(rewardedPet.pet, rewardedPet.newXP, rewardedPet.newLevel, false)
	end
end

function MoveToVictoryLocation(pet)
	MoveToRadius(playerPet, idleRadius, playerPet.currentOffset)
end
"	0	0
571	"PetBattle - Selected - Ability Selected Movement"	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)

	-- print(\"Move Selected: Ability Visual ID: \" .. abilityVisualID)
	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if (not abilityVisual) then
		return
	end

	local player = nil
	local pet = nil
	if (observingPlayerIndex > 0) then
		player = GetTeamByIndex(observingPlayerIndex)
		if (player) then
			pet = player.pets[player.activePet]
		end
	end

	if (not pet) then
		return
	end

	local casterPlayer = GetTeamByIndex(observingPlayerIndex)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - observingPlayerIndex)

	PetMoveToAttackPosition(pet, opponentFrontPet, \"ready\" );
	
end
"	0	0
572	"PetBattle - Selected - Pet Swap Selected Movement"	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\"Move Selected: Pet Swap Slot: \" .. petSlot)

end"	0	0
573	"PetBattle - Selected - Trap Selected Movement"	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected()

	-- print(\"Move Selected: Trap\")
	StartTrapPrecast(observingPlayerIndex)

end

function GetTrapVisuals(playerID)

	local player = nil
	local playerDisplay = nil
	if (playerID and (playerID > 0)) then
		player = GetTeamByIndex(playerID)
		if (player) then
			playerDisplay = player.playerDisplay
		end
	end
	
	if (not playerDisplay) then
		return
	end

	if (not player.trapVisualID) then
		return
	end

	local trapVisual = petAbilityVisuals[player.trapVisualID]
	local trapSpellVisualID = nil
	if (trapVisual) then
		trapSpellVisualID = trapVisual.spellVisualID
	end

	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then
		return
	end

	return player, playerDisplay, trapVisual, trapSpellVisualID
end

function StartTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (playerDisplay) then
		if (not player.trapPrecastID) then
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID )
		end
	end

end

function ClearTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (player.trapPrecastID) then
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)
		player.trapPrecastID = nil
	end

end

function TrapCast(effect)

	local playerID = effect.casterPlayerID

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)

	if (not player) then
		return
	end

--	print(\"Casting Trap...\")

	StartTrapPrecast(playerID)
	scene:WaitTimer(trapVisual.castTime)
	ClearTrapPrecast()

	for targetIndex, target in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(target.playerID)
		local targetPet = targetPlayer.pets[target.petSlot]

		if (targetPet) then
			local trapSuccess = false
			if (targetPet.status) then
				trapSuccess = targetPet.status.isTrapped
			end

			castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})
			scene:WaitTimer(trapVisual.impactTime)

			local waitCondition = function()
				return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)
			end
			scene:WaitCondition(waitCondition)

			if (trapSuccess) then
				--print(\"Succesful Trap\")
				targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)
			else
				print(\"Failed Trap\")
			end
		end
	end

end
"	0	0
574	"PetBattle - 1. Handle Event"	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.abilityVisualID)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.newFrontPet)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected()
print(\"Trap Selected\");
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\"WARNING: processing round result outside of RoundStart/End\")
		ProcessRoundResult(event)
	elseif (eventType == PetBattleEvent.RoundStart) then

		-- pull off all round effects
		local allEffects = { }
		local effectNum = 0
		local done = false
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do
			event = battleScene:GetPendingEffect()
			eventType = event.eventType
			if (eventType == PetBattleEvent.RoundComplete) then
				done = true
			else
				effectNum = effectNum + 1
				allEffects[effectNum] = event
			end
		end
		
		-- if we have at least one effect or we\'re done, make sure
		-- process the round start then batch process effects
		-- NOTE: the event we are left with will be RoundComplete
		if (done == true or #allEffects > 0) then
			SignalEffectProcessed()
			ProcessAllRoundResults(allEffects)

			-- switch to the next pendign event
			StartEffectProcessing(event)
		end
	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (eventType == PetBattleEvent.RoundComplete) then
		for playerID, player in pairs(teams) do
			ClearTrapPrecast(playerID)
		end
		--ResetActivePets()
	end

	return true
end

function StartEffectProcessing(event)
	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID
end

function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(...)
  local customFunc = function(...)
    return %s
  end
  customFunc(...)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString

	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\"ERROR: loading script on BattlePetVisual ID=\" .. abilityVisual.ID .. \" failed: \" .. createString)
			print(\"ERROR: \" "	0	575
575	"[1] PetBattle - 1. Handle Event"	".. result)
		end
	end

end

"	574	0
576	"PetBattle - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \"arenaCameraBunny\"
	cameraBunnyCreate.model = padModel
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()
	cameraBunnyCreate.transform.facing = player.teamFacing
	cameraBunnyCreate.interactible = false

	cameraBunny = scene:SpawnActor(cameraBunnyCreate)
	cameraBunny:SetFacingToAbs(BuildVector(player.teamFacing, playerRadius, 0.0))
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)
	
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)
end

function StopCameraBunny(transitionTime)
	if ( not cameraBunny ) or ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	-- return to the player
	local player = teams[observingPlayerIndex]
	scene:ResetGameCameraZoom()

	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)
	scene:WaitTimer(transitionTime)
	scene:SetGameCameraTarget(nil, 0.0, 0.0)
end

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]
	local observedPadActor = observedTeam.pad.actor
	if (not observedPadActor) then
		observedPadActor = observedTeam.pad
	end

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 2.0, observedPadActor, arenaRing)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.0, observedPadActor, arenaRing)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedPadActor, arenaRing)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
577	"PetBattle - Intro"	"
local cameraBunny

--------------------------------------------------------------------------------
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(1.5)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(1.6)
		scene:SetCamera(0, 0.75, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
578	"PetBattle - Arena"	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \"arenaRing\"
arenaCreateData.model = arenaRingModel
arenaCreateData.scale = arenaRingScale
arenaCreateData.interactible = false
arenaRing = scene:SpawnActor(arenaCreateData)
arenaRing:Fade(0, 0)
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)

scene:WaitTimer(0.25)
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)

local debugScale = false

if ( debugScale ) then
	local scaleCreateData = ActorCreateData:Default()
	scaleCreateData.name = \"scaleAxis\"
	scaleCreateData.model = \"SPELLS\\AxisTestObject.m2\"
	scaleCreateData.scale = 2.0
	scaleCreateData.interactible = false
	axis = scene:SpawnActor(scaleCreateData)
end"	0	0
579	"PetBattle - Placeholder Players"	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \"placeHolder\" .. playerID
					createData.interactible = false
					createData.floatingTooltip = false

					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)
					local transform = Transform:New(pos, player.teamFacing)
					createData.transform = transform

					placeHolderActor = scene:SpawnActor(createData)
					placeHolderActors[playerID] = placeHolderActor
				end

				-- keep using the placeholder
				player.playerDisplay = placeHolderActor
			else
				-- done with this placeholder, despawn it
				local placeHolderActor = placeHolderActors[playerID]
				if (placeHolderActor) then
					placeHolderActor:Despawn()
				end

				placeHolderActors[playerID] = nil
			end
		end
	end
end

placeHolderActors = nil
"	0	0
580	"PetBattle - Main"	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

InitStaticData(initialBattleState)

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[PetBattlePlayerID.Weather].teamFacing = 0
initialBattleState.players[PetBattlePlayerID.Player1].teamFacing = 0
initialBattleState.players[PetBattlePlayerID.Player2].teamFacing = 180

teams = { }
teams[PetBattlePlayerID.Weather] = initialBattleState.players[PetBattlePlayerID.Weather]
teams[PetBattlePlayerID.Player1] = initialBattleState.players[PetBattlePlayerID.Player1]
teams[PetBattlePlayerID.Player2] = initialBattleState.players[PetBattlePlayerID.Player2]

if (PetBattleScene.GetActivePlayerDisplay) then
	if (teams[1]) then
		teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
	end
	if (teams[2]) then
		teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
	end
end

if (teams[PetBattlePlayerID.Player2].isNPC == true) and (#teams[PetBattlePlayerID.Player2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(PetBattlePlayerID.Weather, teams[PetBattlePlayerID.Weather])
InitTeam(PetBattlePlayerID.Player1, teams[PetBattlePlayerID.Player1])
InitTeam(PetBattlePlayerID.Player2, teams[PetBattlePlayerID.Player2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		if (useFreelookCamera) then
			StartCameraBunny(0)
		else
			SetCamera(3)
		end
	end
	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle, winnerID = ProcessEvent(event)
end

VictoryCeremony(winnerID)

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.25)
	else
		SetCamera(4)
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0
581	"Valley of the Four Winds - Stoneplow Finale - Camera - PRK"	"--Wall shot
local genericFOV90 = 368
SetCameraFollowPath( genericFOV90, 0, 3421, 3422, 10)
Wait(2)

--Loon looks at wall
SendTrigger(\"LoonShot1\")
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)
Wait(7)

--Over Loon\'s shoulder
SetCameraFollowPath( genericFOV90, 0, 3430, 3431, 10)
Wait(5)

--Back at their faces
SendTrigger(\"LoonShot3\")
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)
Wait(6)

--Wall shot again
SetCameraFollowPath( genericFOV90, 0, 3423, 3422, 10)
Wait(2)

--Loon, close
SendTrigger(\"LoonShot4\")
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)
Wait(9)

--Break Wall
SetCameraFollowPath( genericFOV90, 0, 3424, 3422, 10)
SendTrigger(\"BreakWall\")
Wait(5)

--Back on Loon, camera on a spline
SendTrigger(\"LoonShot5\")
SetCameraFollowPath( genericFOV90, 0, 3443, 3429, 25)
Wait(19)

--Kids Pan
SendTrigger(\"KidsShot\")
SetCameraFollowPath( genericFOV90, 0, 3451, 3452, 9)
Wait(9)

--Chen Shot
SendTrigger(\"ChenEnters\")
SetCameraFollowPath( genericFOV90, 0, 3461, 3462, 9)
Wait(9)

--Kung Fu Shot
SendTrigger(\"KungFuEnters\")
SetCameraFollowPath( genericFOV90, 0, 3552, 3553, 9)
Wait(8)
SendTrigger(\"TriggerParade\")
Wait(1)

--Wide Parade Shot
SetCameraFollowPath( genericFOV90, 0, 3554, 3555, 32)
Wait(35)

--Set camera back to game-cam
scene:SetCamera(0, 1, nil, nil)"	0	0
582	"Global Functions - Actor Sound"	"--
-- Sound Helper Functions
--
function Actor:WaitSoundKitComplete(soundKit)
	if not soundKit then
		return
	end
	local waitCondition = function()
		return soundKit:IsStopped()
	end
	self:WaitCondition(waitCondition)
end
"	0	0
583	"Valley of the Four Winds - Stoneplow Finale - Wall - PRK"	"WaitForTrigger(\"BreakWall\")
Wait(1)
wall:PlayOneShotAnimKit(2474)"	0	0
584	"Valley of the Four Winds - Stoneplow Finale - Loon Mai - PRK"	"WaitForTrigger(\"LoonShot1\")
Wait(0.3)
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalkExclamation)
Wait(2.5)
loon:FollowPath(3426, 2)
Wait(2)
loon:SetFacing(84)
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
SendTrigger(\"TriggerLeven01\")

WaitForTrigger(\"LoonShot3\")
Wait(1)
loon:SetFacing(303)
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalkExclamation)
Wait(3)
loon:SetFacing(84)

WaitForTrigger(\"LoonShot4\")
Wait(0.3)
loon:PlayOneShotSplitBodyAnim(Animations.EmoteNo)
Wait(3)
loon:PlayOneShotSplitBodyAnim(Animations.EmoteShout)
SendTrigger(\"FarmersAssemble\")

WaitForTrigger(\"LoonShot5\")
Wait(1)
loon:SetFacing(75)
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
SendTrigger(\"DeployShadoPan\")
Wait(5)
loon:SetFacing(111)
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
SendTrigger(\"DeployFarmers\")
Wait(5)
loon:SetFacing(300)
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
SendTrigger(\"DeployLeven\")
Wait(5)
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalk)
Wait(2)
loon:SetFacing(175)
"	0	0
585	"Valley of the Four Winds - Stoneplow Finale - Leven - PRK"	"WaitForTrigger(\"TriggerLeven01\")
Wait(1)
leven:FollowPathAtSpeed(3427, 3)
Wait(3)
leven:PlayOneShotSplitBodyAnim(Animations.EmoteTalk)
Wait(3)
leven:SetFacing(84)

WaitForTrigger(\"DeployLeven\")
Wait(2)
leven:SetFacing(120)
leven:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)
Wait(3)
leven:FollowPath(3447, 8)
leven:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
586	"Valley of the Four Winds - Stoneplow Finale - Farmers/Kids - PRK"	"WaitForTrigger(\"FarmersAssemble\")
Wait(1)
farmerA:FollowPath(3432, 6)
Wait(0.7)
farmerB:FollowPath(3433, 9)
Wait(0.7)
farmerC:FollowPath(3434, 7)

kidA:FollowPath(3435, 4)
Wait(0.1)
kidB:FollowPath(3436, 5)
Wait(0.4)
kidC:FollowPath(3437, 5)
Wait(0.2)
kidD:FollowPath(3438, 6)
Wait(0.2)
kidE:FollowPath(3439, 5)

WaitForTrigger(\"DeployFarmers\")
Wait(2)
farmerA:PlayOneShotSplitBodyAnim(Animations.EmoteYes)
Wait(0.5)
farmerB:PlayOneShotSplitBodyAnim(Animations.EmoteCheer)
Wait(3)
farmerA:FollowPath(3448, 8)
Wait(0.5)
farmerB:FollowPath(3449, 8)

WaitForTrigger(\"TriggerParade\")
Wait(1)
farmerC:FollowPathAtSpeed( 3557, 3 )
Wait(0.5)
kidA:FollowPathAtSpeed( 3558, 5 )
kidB:FollowPathAtSpeed( 3559, 6 )
Wait(0.5)
kidC:FollowPathAtSpeed( 3560, 3 )
Wait(0.5)
kidD:FollowPathAtSpeed( 3561, 4 )
kidE:FollowPathAtSpeed( 3562, 5 )
Wait(5)
farmerC:SetFacing(333)
kidA:SetFacing(333)
kidB:SetFacing(333)
kidC:SetFacing(333)
kidD:SetFacing(333)
kidE:SetFacing(333)"	0	0
587	"Valley of the Four Winds - Stoneplow Finale - Shado-Pan - PRK"	"WaitForTrigger(\"FarmersAssemble\")
fosho:StopLoopingSplitBodyAnim(Animations.ReadyUnarmed)
jooru:StopLoopingSplitBodyAnim(Animations.ReadySpellDirected)
koyan:StopLoopingSplitBodyAnim(Animations.Ready1H)
Wait(0.5)
fosho:FollowPath(3440, 4)
jooru:FollowPath(3441, 4)
koyan:FollowPath(3442, 4)


WaitForTrigger(\"DeployShadoPan\")
Wait(2)
fosho:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)
Wait(0.2)
jooru:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)
Wait(0.1)
koyan:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)
Wait(3)
fosho:FollowPath(3444, 6)
jooru:FollowPath(3445, 6)
koyan:FollowPath(3446, 6)"	0	0
588	"Valley of the Four Winds - Stoneplow Finale - Init Enemies - PRK"	"-- mantid - leven
mantidLeven01 = SpawnFadedActorAtPoint( 63402, 3453, false )
mantidLeven02 = SpawnFadedActorAtPoint( 63402, 3454, false )
mantidLeven03 = SpawnFadedActorAtPoint( 63403, 3455, false )
mantidLeven04 = SpawnFadedActorAtPoint( 63402, 3456, false )


-- mantid - farmers
mantidFarmers01 = SpawnFadedActorAtPoint( 63402, 3457, false )
mantidFarmers02 = SpawnFadedActorAtPoint( 63403, 3458, false )
mantidFarmers03 = SpawnFadedActorAtPoint( 63402, 3459, false )"	0	0
589	"Valley of the Four Winds - Stoneplow Finale - Chen - PRK"	"local kickSpell = 124002

--Fade in
WaitForTrigger(\"KidsShot\")
Wait(1)
FadeIn(chen, 0)

--Run in, jumpkick fool
WaitForTrigger(\"ChenEnters\")
chen:FollowPath(3460, 5)
Wait(5)
CastSpellAtActor(chen, mantidLeven01, kickSpell)
Wait(4)
chen:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)"	0	0
590	"Valley of the Four Winds - Stoneplow Finale - Mantid (Flankers) - PRK"	"WaitForTrigger(\"KidsShot\")
Wait(1)
FadeIn(mantidLeven01, 0)
FadeIn(mantidLeven02, 0)
FadeIn(mantidLeven03, 0)
FadeIn(mantidLeven04, 0)
mantidLeven01:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)
Wait(0.2)
mantidLeven04:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)
Wait(0.15)
mantidLeven02:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
Wait(0.2)
mantidLeven03:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)


WaitForTrigger(\"ChenEnters\")
FadeIn(mantidFarmers01, 0)
FadeIn(mantidFarmers02, 0)
FadeIn(mantidFarmers03, 0)
"	0	0
592	"Brazie\'s PetBattle - Init Pad"	"--------------------------------------------------------------------------------
-- pad
padModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
padAlpha = 1.0
padScale = 1.0


function InitPad(transform)
	-- spawn a pad for this team
	local padCreateData = ActorCreateData:Default();
	padCreateData.name = \"pad\";
	padCreateData.model = padModel;
	padCreateData.transform = transform;
	padCreateData.scale = padScale*battleScale;

	pad = scene:SpawnActor(padCreateData)
	pad:Fade(padAlpha, 0.5)
	pad:SetInteractible(false);

	return pad;
end"	0	0
593	"Brazie\'s PetBattle - Init Player"	"
function InitTeam(playerID, team)

-- HUGE HACK
-- This needs to be fixed in code.
	if ( not team.activePet ) then 
		team.activePet = 0;
print ( \"Init TEAM!!!\", team.activePet );
	end

	-- Save the team
	allPlayers[playerID] = team;
	team.playerID = playerID;

	-- Spawn a Pad
	local homeTransform = HOME_LIST[playerID];
	team.pad = InitPad(homeTransform);

	-- Save the home loc
	team.home = homeTransform.position;

	-- Weather is neutral, so set it up then eject
	if (playerID == PetBattlePlayerID.Weather) then
		team.isWeather = true
--print(\"Weather\'s Pets: \",#team.petDescs);

		local padPet = { 
			isPad = true;
			actor = team.pad;
			auras = {}; 
			slot = petIndex; 
			team = team.playerID; 
			playerID = team.playerID;
			moveSpeed = 1000;
		};
		team.pets = {};
		team.pets[PetBattlePetID.Weather] = padPet;
		team.pets[PetBattlePetID.Weather].actor = team.pad;

		return;
	else
		team.isWeather = false
	end

	-- Create the Master
	local masterTransform = MASTER_SPOTS[playerID];
	local masterLoc = masterTransform.position;
	local master
	
	-- Spawn an NPC if needed
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then
		local npcCreateData = ActorCreateData:Default();
		npcCreateData.creatureID = team.npcCreatureID;
		npcCreateData.creatureDisplayID = team.npcDisplayID;
		npcCreateData.interactible = false;
		npcCreateData.transform = masterTransform;
		npcCreateData.scale = battleScale;

		master = scene:SpawnActor( npcCreateData );

		master:SetFacingToAbs(Vector:New());

		-- Assign the master to his team

		-- Darren\'s scripts required these two
		team.npcActor = master;
		team.playerDisplay = master;

		-- Mine is generic
		team.master = master;
	end


	-- Assign Pets to temporary data
	team.pets = {};

	mainPetLoc = homeTransform;
	
	local backLineCount = 0;

	for id,v in pairs( team.petDescs ) do 
		-- If its your pad object
		if (id == PetBattlePetID.Pad) then
			local padPet = { 
				isPad = true;
				actor = team.pad;
				auras = {}; 
				slot = petIndex; 
				team = team.playerID; 
				playerID = team.playerID;
			};
			team.pets[id] =  padPet;

		-- Spawn the appropriate pet in front if the game is mid-session
		elseif ( id == team.activePet and initialBattleState.battleState ~= PetBattleState.WaitingPreBattle ) then 
			team.pets[id] = InitPet(team, id, mainPetLoc);
		else
			backLineCount = backLineCount + 1;

			-- Placed in master-relative coordinates
			local offset = FastLocalFacingCoordinates ( masterTransform.position, Vector:New(), BACKROW_PET_OFFSETS[backLineCount] );
			team.pets[id] =  InitPet(team, id, Transform:New( offset, masterTransform.yaw ) );
		end
	end

--[[ FUTURE NOTE: Initialize all pets facing 0,0,0 ]]--

	-- If the battle has already started
	-- Make them all face the guy in the center
	if ( initialBattleState.battleState ~= PetBattleState.WaitingPreBattle ) then 
		for k,v in pairs(team.pets) do
			if ( k ~= team.activePet ) then 
				v.actor:SetFacingToTarget(team.pets[team.activePet].actor, Vector:New());
			else
				local enemyTeam = teams [3-playerID];
				if ( enemyTeam.pets ) then 
					v.actor:SetFacingToTarget(enemyTeam.pets[enemyTeam.activePet].actor, Vector:New());
				end
			end
		end
	else
		for k,v in pairs(team.pets) do
			if ( k ~= team.activePet ) then 
				v.actor:SetFacingToAbs(Vector:New());
			end
		end
	end
end


function InitPet(team, petIndex, transform)
	local petData = team.petDescs[petIndex];
	local petActor = scene:SpawnActor(ActorCreateData:New(petData.creatureID, transform, battleScale))

	local pet = { 
		actor = petActor; 
		moveSpeed = 5; 
		auras = {}; 
		slot = petIndex; 
		playerID = team.playerID; 
		team = team.playerID;
		creatureID = petData.creatureID;
		teamFacing = "	0	594
594	"[1] Brazie\'s PetBattle - Init Player"	"team.teamFacing; -- Needed for Darren compat only
		health = petData.health;
	};

	-- For Darren Compatibility only
	pet.currentRadius = backlineRadius
	pet.currentOffset = 0

	-- Initialize stuff
	SetXP(pet, petData.xp, petData.level, true)
	SetHealth(pet, petData.health, true)

	pet.status = petData.status

	-- Initially invisible?
	petActor:SetInteractible(false);
	--petActor:SetHidden(true);
	--petActor:Fade(0, 0);
	pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)


	-- apply initial auras
	for auraIndex, auraData in pairs(petData.auras or { }) do
		local auraVisual = petAbilityVisuals[auraData.auraVisualID]
		if (auraVisual) then
			ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
		end
	end

	return pet;
end"	593	0
595	"PetBattle - Victory Ceremony"	"function VictoryCeremony(winnerID)
	if (winnerID == 1) or (winnerID == 2) then
		local winnerTeam = teams[winnerID]
		for petIndex, pet in pairs(winnerTeam.pets) do
			if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
				-- move backline up to celebrate
				pet.actor:Fade(1.0, backlineFadeTime)
				MoveToRadius(pet, idleRadius, pet.currentOffset)
			end
		end
		scene:WaitTimer(1.0)
	end
end"	0	0
596	"Brazie\'s PetBattle - Turn - Swap"	"function EffectSwap(teamId, petIndex)
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player or npc point
	if (team.master) then
		team.master:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	local nextTeam = math.fmod(teamId,2)+1;
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]

	-- Handle the cosmetic swap
	PerformSwap( lastPet, nextPet, opponent );

	print(\"NEW PET INDEX: \"..petIndex);
	team.activePet = petIndex
end

function PerformSwap ( pet, newPet, opponent )

	local currentPetLoc = pet.actor:GetPosition();
	local currentBacklineLoc = newPet.actor:GetPosition();

print(\"Swapping \",pet.slot,\" with \",newPet.slot);
	-- New guy faces the enemy
	newPet.actor:SetFacingToAbs(opponent.actor:GetPosition())

	local movePet = true;

	-- If pet picked was your pad, dont move it
	if ( pet.isPad ) then
		currentPetLoc = HOME_LIST[pet.playerID].position;
		movePet = true;

	elseif ( pet.currentHealth <= 0 ) then
		-- Send the pet into the ring, not to the corpse
		currentPetLoc = HOME_LIST[pet.playerID].position;

		pet.actor:Fade(0, 0.5);
		scene:WaitTimer(0.5)
	end

	-- Swap Locations
	if ( movePet ) then
		pet.actor:ClearFacing();
		local distance = pet.actor:GetPosition():Dist(currentBacklineLoc);
		pet.actor:MoveToAbs(currentBacklineLoc, distance/pet.moveSpeed)
	end

	local distance = newPet.actor:GetPosition():Dist(currentPetLoc);
	newPet.actor:MoveToAbs(currentPetLoc, distance/newPet.moveSpeed)

	-- If dead, fade corpse in
	if ( pet.currentHealth <= 0 ) then 
		pet.actor:MoveToAbs(currentBacklineLoc, 0)
		pet.actor:Fade(backlineAlpha, backlineFadeTime)
	-- If alive wait for it to move to the end
	else
		pet.actor:WaitMovementComplete()
	end

	newPet.actor:WaitMovementComplete()

	ReturnOrResetCheck( newPet, opponent );

	-- Make all of your pets look at their teammate
	for k,v in pairs( allPlayers[pet.team].pets ) do 
		if ( k ~= allPlayers[pet.team].activePet and (not v.currentHealth or v.currentHealth > 0 ) ) then 
			v.actor:SetFacingToTarget(newPet.actor, Vector:New());
		end
	end
end "	0	0
597	"Brazie\'s PetBattle - Victory Ceremony - Rewards"	"function MoveToVictoryLocation(pet)

	-- XP Visual - 14302
	
	local team = GetTeamByIndex(pet.playerID)
	local spot = team.home + BACKROW_PET_OFFSETS[pet.slot] + Vector:New(1,0,0);
	local distance = pet.actor:GetPosition():Dist(spot);

	pet.actor:MoveToAbs(spot, distance/pet.moveSpeed)
end

function EventReward(rewards)
	--print(\"rewards for you!\");
--[[
	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = GetTeamByIndex(reward.playerID)
			local playerPet = player.pets[reward.petSlot]
			if (playerPet) then
				local rewardedPet =
				{
					pet = playerPet;
					newXP = reward.newXP;
					newLevel = reward.newLevel;
				}
				rewardedPets[rewardIndex] = rewardedPet

				-- resurrect and move this pet up
				--
				if (playerPet.deathAnimKit) then
					playerPet.deathAnimKit:Stop()
					playerPet.deathAnimKit = nil		
				end
				--

				playerPet.actor:Fade(1.0, backlineFadeTime)
			end
		end
	end
]]--
	local player = GetTeamByIndex(rewards[1].playerID)
	--local playerPet = player.pets[reward.petSlot]

	for i=1,3 do 
		if ( player.pets[i] ) then 
			local playerPet = player.pets[i] 

			if ( playerPet.currentHealth > 0 ) then 
				playerPet.actor:Fade(1.0, 0.5)
				MoveToVictoryLocation(playerPet);
			end
		end
	end

	-- wait until all pets have stopped moving
	local waitCondition = function()
		-- all actors must be renderable
		for i=1,3 do
			local pet = player.pets[i] 
			if pet and pet.actor:IsMoving() then
				return false
			end
		end
		return true
	end

	scene:WaitCondition(waitCondition)
	if ( player.playerDisplay ) then 
		for i=1,3 do
			local pet = player.pets[i] 
			pet.actor:ClearFacing();
			--pet.actor:SetFacingToTarget(player.pets[0].actor, Vector:New());
		end
	end

	--VictoryCeremony_PerformDance(player)

	-- apply the rewards
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local rewardedPet =
			{
				pet = ROIDTOPET( GETROIDFROMPLAYERIDANDSLOT( reward.playerID, reward.petSlot )  );
				newXP = reward.newXP;
				newLevel = reward.newLevel;
			}
			rewardedPet.pet.actor:PlaySpellCastVisual(26429);
			SetXP(rewardedPet.pet, rewardedPet.newXP, rewardedPet.newLevel, false)
		end
	end
end"	0	0
598	"PetBattle - Pet Movement Stuff"	"

function PetMoveToAttackPosition(pet, opponent, attackType)
	if ( not attackType or attackType == PetBattleRange.InPlace ) then 
		local radius = GetAttackRadius(attackType);
		WaitMoveToRadius(pet, radius);

	elseif (attackType == PetBattleRange.Melee or attackType == PetBattleRange.Ranged ) then 
		local attackRadius = GetAttackRadius(attackType);
		WaitMoveToRadius(pet, attackRadius);
	end

	LookAtOpposingTeam(pet)
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector( (pet.teamFacing or 0.0) , -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	return attackRadius
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end"	0	0
599	"[1] Cinematic Framework"	"scene:WaitCondition(waitCondition)
end

function Actor:FollowPathAtSpeed( pathID, speed )
	local path = scene:LoadPath( pathID )
	local totalDist = 0
	local currentVector = Vector:New()
	local i

	for i = 1, (#path.nodes)-1 do
		local v1 = path.nodes[i].pos
		local v2 = path.nodes[i+1].pos
		currentVector = v1 - v2 -- Vector.Sub( v1 , v2 )
		totalDist = totalDist + Vector.Magnitude(currentVector)
	end

	self:FollowPath( pathID, totalDist/speed )
end
"	41	0
600	"PetBattle - 3. Playback Turn"	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false
function PlaybackAllTurns(topLevelTurnGroups)

	if (debugOn == true) then
		print(\"  \")
		print(\"== Start Round Playback ==\")
	end 
	
	-- process top level turns in order
	for index, turn in pairs(topLevelTurnGroups) do
		ProcessRoundTurnGroup( turn )
	end

	if (debugOn == true) then
		print(\"== End Round Playback ==\")
		print(\"  \")
	end

end

--------------------------------------------------------------------------------
function ProcessRoundTurnGroup(turnGroup)
	
	if (debugOn == true) then
		print(\"- Processing Turn \" .. turnGroup.firstEffect.turnInstanceID)
	end

	-- use a custom script handler if we have one
	local turnVisual = nil
	if (turnGroup.firstEffect.turnVisualID) then
		turnVisual = petAbilityVisuals[turnGroup.firstEffect.turnVisualID]
	end
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		if ( turnVisual.scriptFunction( turnGroup ) ) then
			processed = true
		end
	end

	-- fallback processing
	if (processed ~= true) then
		for index, effectGroup in pairs(turnGroup.effects) do
			ProcessRoundEffectGroup(effectGroup)
		end
	end
end

--------------------------------------------------------------------------------
function ProcessRoundEffectGroup(effectGroup)
	if (debugOn == true) then
		print(\"-   Processing Effect \" .. effectGroup.firstEffect.abilityEffectID)
	end

	-- use a custom script handler if we have one
	local effectVisual = nil
	if (effectGroup.firstEffect.abilityVisualID) then
		effectVisual = petAbilityVisuals[effectGroup.firstEffect.abilityVisualID]
	end
	local processed = false
	if (effectVisual and effectVisual.scriptFunction) then
		if ( effectVisual.scriptFunction( effectGroup ) ) then
			processed = true
		end
	end

	-- fallback handling
	if (processed ~= true) then
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Process an individula Round Effect Result
function ProcessRoundResult(event)

	local eventType = event.eventType
	local effectType = event.effectType

	if not (eventType == PetBattleEvent.RoundEffect) then
		return
	end

	if (debugOn == true) then
		print(\"-     Processing Result \" .. event.instanceID)
	end

	-- battle round effects
	if (effectType == PetBattleEffect.SetHealth) then
		EffectSetHealth(event)
	elseif (effectType == PetBattleEffect.AuraApply) then
		EffectAuraApply(event)
	elseif (effectType == PetBattleEffect.AuraCancel) then
		EffectAuraChange(event, true)
	elseif (effectType == PetBattleEffect.AuraChange) then
		EffectAuraChange(event, false)
	elseif (effectType == PetBattleEffect.PetSwap) then
		EffectSwap(event.casterPlayerID, event.newFrontPet)
	elseif (effectType == PetBattleEffect.StatusChange) then
		EffectStatusChange(event)
	end

end

--------------------------------------------------------------------------------
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn

--------------------------------------------------------------------------------
function GenerateUniqueGroupKeys(effect)	
	local stackDepth = effect.stackDepth or 0
	local turnInstanceID = effect.turnInstanceID or 0
	local effectID = effect.effectID or 0
	if (stackDepth > maxStackDepth) then
		print (\"WARNING: stack depth exceeded \" .. maxStackDepth)
	"	0	643
602	"Brazie\'s PetBattle - Pet Movement - Core Library"	"

function PerformRelativeSlide( opponent, pet, front, left, up ) 
	local newDrift = CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 

	local opponentDriftPoint = newDrift;
	local driftDistance = opponentDriftPoint:Dist( opponent.actor:GetPosition() )

	local moveTime = 0 ;
	if ( opponent.moveSpeed ) then 
		moveTime = driftDistance/opponent.moveSpeed
	end

	opponent.actor:MoveToAbs(opponentDriftPoint, moveTime );

end

function BuildKnockbackSpline(petStartPosition, petFinalPoint, duration)
	local gravity = -9.8/2; -- M / sec / sec
	local points = 10;  

	local dx = petFinalPoint.x - petStartPosition.x;
	local dy = petFinalPoint.y - petStartPosition.y;
	local xVelocity = dx / duration;  -- M / sec
	local yVelocity = dy / duration;  -- M / sec

	local zVelocity = ( gravity * duration * duration ) * -2;

	local list = {};
	local timeStep = duration / points

	for i=0, points do 
		local time = timeStep * i; 
		local x = time * xVelocity;
		local y = time * yVelocity;
		local u = gravity*time*time + zVelocity*time;
--print(\"t: \",time,\" x: \",x,\"u: \",u);
		table.insert(list, 
			petStartPosition + Vector:New(x,y,u) 
			);
	end
	table.insert(list, petFinalPoint);
	table.remove(list, 1);

	return list;
end


function CalculateLocationFacingRelativeOffset(pet, location, front, left, up)
	--FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );

	return FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );
end

function CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 
	local opponentLocation = opponent.actor:GetPosition();

	return CalculateLocationFacingRelativeOffset(opponent, pet.actor:GetPosition(), front, left, up);
end"	0	0
603	"Valley of the Four Winds - Stoneplow Finale - Zhu\'s Wardens - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(yimo, 0)
FadeIn(wardenA, 0)
FadeIn(wardenB, 0)
FadeIn(wardenC, 0)
FadeIn(wardenD, 0)
FadeIn(wardenE, 0)
FadeIn(wardenF, 0)

yimo:FollowPathAtSpeed(3515, paradeSpeed)
wardenA:FollowPathAtSpeed(3516, paradeSpeed)
wardenB:FollowPathAtSpeed(3517, paradeSpeed)
wardenC:FollowPathAtSpeed(3518, paradeSpeed)
wardenD:FollowPathAtSpeed(3519, paradeSpeed)
wardenE:FollowPathAtSpeed(3520, paradeSpeed)
wardenF:FollowPathAtSpeed(3521, paradeSpeed)

yimo:WaitMovementComplete()
wardenA:WaitMovementComplete()
wardenB:WaitMovementComplete()
wardenC:WaitMovementComplete()
wardenD:WaitMovementComplete()
wardenE:WaitMovementComplete()
wardenF:WaitMovementComplete()

yimo:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenE:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
wardenF:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
604	"Valley of the Four Winds - Stoneplow Finale - Li Li/Mudmug - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(lili, 0)
FadeIn(mudmug, 0)

lili:FollowPathAtSpeed(3523, paradeSpeed)
mudmug:FollowPathAtSpeed(3522, paradeSpeed)

lili:WaitMovementComplete()
mudmug:WaitMovementComplete()

lili:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
mudmug:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
605	"Valley of the Four Winds - Stoneplow Finale - Tauren - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(dezco, 0)
FadeIn(braveA, 0)
FadeIn(braveB, 0)
FadeIn(braveC, 0)
FadeIn(braveD, 0)

dezco:FollowPathAtSpeed(3529, paradeSpeed)
braveA:FollowPathAtSpeed(3525, paradeSpeed)
braveB:FollowPathAtSpeed(3526, paradeSpeed)
braveC:FollowPathAtSpeed(3527, paradeSpeed)
braveD:FollowPathAtSpeed(3528, paradeSpeed)

dezco:WaitMovementComplete()
braveA:WaitMovementComplete()
braveB:WaitMovementComplete()
braveC:WaitMovementComplete()
braveD:WaitMovementComplete()

dezco:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
braveA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
braveB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
braveC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
braveD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
606	"Valley of the Four Winds - Stoneplow Finale - Hidden Master - PRK (copy)"	"WaitForTrigger(\"TriggerParade\")
FadeIn(hiddenmaster, 0)

hiddenmaster:FollowPathAtSpeed(3524, paradeSpeed)

hiddenmaster:WaitMovementComplete()

hiddenmaster:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
607	"Valley of the Four Winds - Stoneplow Finale - Pang/Miss Fanny - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(pang, 0)
FadeIn(missfanny, 0)

pang:FollowPathAtSpeed(3530, paradeSpeed)
missfanny:FollowPathAtSpeed(3531, paradeSpeed)"	0	0
608	"Valley of the Four Winds - Stoneplow Finale - Night Elves - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(lyalia, 0)
FadeIn(sentinelA, 0)
FadeIn(sentinelB, 0)
FadeIn(sentinelC, 0)
FadeIn(sentinelD, 0)

lyalia:FollowPathAtSpeed(3532, paradeSpeed)
sentinelA:FollowPathAtSpeed(3533, paradeSpeed)
sentinelB:FollowPathAtSpeed(3534, paradeSpeed)
sentinelC:FollowPathAtSpeed(3535, paradeSpeed)
sentinelD:FollowPathAtSpeed(3536, paradeSpeed)

lyalia:WaitMovementComplete()
sentinelA:WaitMovementComplete()
sentinelB:WaitMovementComplete()
sentinelC:WaitMovementComplete()
sentinelD:WaitMovementComplete()

lyalia:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
sentinelA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
sentinelB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
sentinelC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
sentinelD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
609	"Valley of the Four Winds - Stoneplow Finale - Crane Monks - PRK"	"WaitForTrigger(\"TriggerParade\")
FadeIn(koro, 0)
FadeIn(monkA, 0)
FadeIn(monkB, 0)
FadeIn(monkC, 0)
FadeIn(monkD, 0)
FadeIn(priestA, 0)
FadeIn(priestB, 0)
FadeIn(priestC, 0)
FadeIn(priestD, 0)

koro:FollowPathAtSpeed(3537, paradeSpeed)
monkA:FollowPathAtSpeed(3538, paradeSpeed)
monkB:FollowPathAtSpeed(3539, paradeSpeed)
monkC:FollowPathAtSpeed(3540, paradeSpeed)
monkD:FollowPathAtSpeed(3541, paradeSpeed)
priestA:FollowPathAtSpeed(3542, paradeSpeed)
priestB:FollowPathAtSpeed(3543, paradeSpeed)
priestC:FollowPathAtSpeed(3544, paradeSpeed)
priestD:FollowPathAtSpeed(3545, paradeSpeed)

koro:WaitMovementComplete()
monkA:WaitMovementComplete()
monkB:WaitMovementComplete()
monkC:WaitMovementComplete()
monkD:WaitMovementComplete()
priestA:WaitMovementComplete()
priestB:WaitMovementComplete()
priestC:WaitMovementComplete()
priestD:WaitMovementComplete()

koro:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
monkA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
monkB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
monkC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
monkD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
priestA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
priestB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
priestC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
priestD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)
"	0	0
610	"Valley of the Four Winds - Stoneplow Finale - Kung Fu Five - PRK"	"--Fade in
WaitForTrigger(\"ChenEnters\")
Wait(1)
FadeIn(xiao, 0)
FadeIn(lin, 0)
FadeIn(kang, 0)
FadeIn(kenken, 0)
FadeIn(ashyo, 0)

--Run in, punch fools
WaitForTrigger(\"KungFuEnters\")
xiao:FollowPathAtSpeed(3547, 6)
kenken:FollowPathAtSpeed(3548, 6)
ashyo:FollowPathAtSpeed(3549, 6)
lin:FollowPathAtSpeed(3551, 6)
kang:FollowPathAtSpeed(3550, 6)

xiao:WaitMovementComplete()
xiao:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)

kenken:WaitMovementComplete()
kenken:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)

ashyo:WaitMovementComplete()
ashyo:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)

lin:WaitMovementComplete()
lin:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)

kang:WaitMovementComplete()
kang:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)"	0	0
611	"Global Functions - Debug"	"
-- Alias
Broadcast = print;
Print = print;

-- Debug stuff
--
function DEBUG_TABLE(table, depth, lookup)
	if ( not depth ) then
		depth = 0;
	end

	if ( depth > 20 ) then
		return;
	end

	local prefix = \"\";

	for i=1,depth do
		prefix = prefix..\"    \";
	end

	if ( type(table) == \"table\" ) then 
		for k,v in pairs(table) do	
			local label;
			if ( lookup ) then 
				label = GetStateLabel(k);
			end
			if ( k == \"__meta\" or k == \"__index\" ) then 
				Print(prefix..\" K :\"..k..\" V: \"..\"Unprintable!\");
			elseif ( type(v) == \"table\" ) then 
				if ( label ) then 
					Print(prefix..\" K: \"..label..\" V: { \");
				else
					Print(prefix..\" K: \"..k..\" V: { \");
				end
				DEBUG_TABLE(v, depth+1, lookup); 
				Print(prefix..\"  }\");
			else
				if ( label ) then 
					Print(prefix..\" K: \"..label..\" V: \"..tostring(v));
				else
					Print(prefix..\" K: \"..k..\" V: \"..tostring(v));
				end
			end
		end
	else
		Print(prefix..\" \"..tostring(table) );
	end
end

-- Pet battle specific debug tools - remove this later
function GetStateLabel(zub)
	for k,v in pairs (STATE_LOOKUP) do
		if ( v == zub ) then
			return k;
		end
	end

	return zub;
end

STATE_LOOKUP = {
    STATE_Is_Dead = 1;
    STATE_maxHealthBonus = 2;
    STATE_speedBonus = 3;
    STATE_Stat_Kharma = 4;
    STATE_healthBonus = 17;
    STATE_Stat_Power = 18;
    STATE_Stat_Stamina = 19;
    STATE_Stat_Speed = 20;
    STATE_Mechanic_IsPoisoned = 21;
    STATE_Mechanic_IsStunned = 22;
    STATE_Mod_DamageDealtPercent = 23;
    STATE_Mod_DamageTakenPercent = 24;
    STATE_Mod_SpeedPercent = 25;
    STATE_Ramping_DamageID = 26;
    STATE_Ramping_DamageUses = 27;
    STATE_Condition_WasDamagedThisTurn = 28;
    STATE_untargettable = 29;
    STATE_Mechanic_IsUnderground = 30;
    STATE_Last_HitTaken = 31;
    STATE_Last_HitDealt = 32;
    STATE_Mechanic_IsFlying = 33;
    STATE_Mechanic_IsBurning = 34;
    STATE_turnLock = 35;
    STATE_swapLock = 36;
    STATE_Stat_CritChance = 40;
    STATE_Stat_Accuracy = 41;
    STATE_Passive_Critter = 42;
    STATE_Passive_Beast = 43;
    STATE_Passive_Humanoid = 44;
    STATE_Passive_Flying = 45;
    STATE_Passive_Dragon = 46;
    STATE_Passive_Elemental = 47;
    STATE_Passive_Mechanical = 48;
    STATE_Passive_Magic = 49;
    STATE_Passive_Undead = 50;
    STATE_Passive_Aquatic = 51;
    STATE_Mechanic_IsChilled = 52;
    STATE_Weather_BurntEarth = 53;
    STATE_Weather_ArcaneStorm = 54;
    STATE_Weather_Moonlight = 55;
    STATE_Weather_Darkness = 56;
    STATE_Weather_Sandstorm = 57;
    STATE_Weather_Blizzard = 58;
    STATE_Weather_Mud = 59;
    STATE_Weather_Rain = 60;
    STATE_Weather_Sunlight = 61;
    STATE_Weather_LightningStorm = 62;
    STATE_Weather_Windy = 63;
    STATE_Mechanic_IsWebbed = 64;
    STATE_Mod_HealingDealtPercent = 65;
    STATE_Mod_HealingTakenPercent = 66;
    STATE_Mechanic_IsInvisible = 67;
};

"	0	0
613	"PetBattle - Debug Stuff"	"debugOn = false;

function DebugPrint(...)
	if ( debugOn == true ) then
		print(...);
	end
end


STATE_LOOKUP = {
    STATE_Is_Dead = 1;
    STATE_maxHealthBonus = 2;
    STATE_speedBonus = 3;
    STATE_Stat_Kharma = 4;
    STATE_healthBonus = 17;
    STATE_Stat_Power = 18;
    STATE_Stat_Stamina = 19;
    STATE_Stat_Speed = 20;
    STATE_Mechanic_IsPoisoned = 21;
    STATE_Mechanic_IsStunned = 22;
    STATE_Mod_DamageDealtPercent = 23;
    STATE_Mod_DamageTakenPercent = 24;
    STATE_Mod_SpeedPercent = 25;
    STATE_Ramping_DamageID = 26;
    STATE_Ramping_DamageUses = 27;
    STATE_Condition_WasDamagedThisTurn = 28;
    STATE_untargettable = 29;
    STATE_Mechanic_IsUnderground = 30;
    STATE_Last_HitTaken = 31;
    STATE_Last_HitDealt = 32;
    STATE_Mechanic_IsFlying = 33;
    STATE_Mechanic_IsBurning = 34;
    STATE_turnLock = 35;
    STATE_swapLock = 36;
    STATE_Stat_CritChance = 40;
    STATE_Stat_Accuracy = 41;
    STATE_Passive_Critter = 42;
    STATE_Passive_Beast = 43;
    STATE_Passive_Humanoid = 44;
    STATE_Passive_Flying = 45;
    STATE_Passive_Dragon = 46;
    STATE_Passive_Elemental = 47;
    STATE_Passive_Mechanical = 48;
    STATE_Passive_Magic = 49;
    STATE_Passive_Undead = 50;
    STATE_Passive_Aquatic = 51;
    STATE_Mechanic_IsChilled = 52;
    STATE_Weather_BurntEarth = 53;
    STATE_Weather_ArcaneStorm = 54;
    STATE_Weather_Moonlight = 55;
    STATE_Weather_Darkness = 56;
    STATE_Weather_Sandstorm = 57;
    STATE_Weather_Blizzard = 58;
    STATE_Weather_Mud = 59;
    STATE_Weather_Rain = 60;
    STATE_Weather_Sunlight = 61;
    STATE_Weather_LightningStorm = 62;
    STATE_Weather_Windy = 63;
    STATE_Mechanic_IsWebbed = 64;
    STATE_Mod_HealingDealtPercent = 65;
    STATE_Mod_HealingTakenPercent = 66;
    STATE_Mechanic_IsInvisible = 67;
};"	0	0
614	"[1] PetBattle - 2. Pre-Playback Processing"	"effectName = k;
				end
			end

			local eventType = \"Unknown\";
			for k,v in pairs(PetBattleEvent) do 
				if ( v == event.eventType ) then
					eventType = k;
				end 
			end

			DebugPrint(\"+     New Result, instanceID = \" .. event.instanceID..\" effectType: \"..effectName..\" eventType: \"..eventType)
		end
		
		lastEffect = event
	end
	if ( processDebug ) then
		DebugPrint(\"  \")
	end

	PlaybackAllTurns(topLevelTurnGroups);

	if ( processDebug ) then
		DebugPrint(\"  \")
	end
end


-- Used for the Brazie Event Filtering System
function FilterResultEventsByType(event)
	return event;
end"	568	0
620	"Brazie\'s PetBattle - PreTurn - Move Selected - Run Up"	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)
	-- print(\"Move Selected: Ability Visual ID: \" .. abilityVisualID)
	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if (not abilityVisual) then
		return
	end

	local player = nil
	local pet = nil
	if (observingPlayerIndex > 0) then
		player = GetTeamByIndex(observingPlayerIndex)
		if (player) then
			pet = player.pets[player.activePet]
		end
	end

	if (not pet) then
		return
	end

	local casterPlayer = GetTeamByIndex(observingPlayerIndex)
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - observingPlayerIndex)

	ReturnOrResetCheck (casterFrontPet, opponentFrontPet)
end
"	0	0
621	"Brazie\'s PetBattle - Post Turn - Reset"	"backwardSpeedMulti = 0.7;

function ReturnOrResetCheck (pet, opponent)

	if ( not pet or not pet.playerID  ) then
		print(\"ERROR: ReturnOrResetCheck - Pet has no player ID\");
		return;
	end

	if ( pet.isPad ) then 
		return;
	end

	if ( not opponent ) then 
		print(\"ERROR: ReturnOrResetCheck - Opponent was not provided!\");
		return;
	end

	local newFrontVector = UnitVectorFromAtoB(opponent.actor:GetPosition(), pet.actor:GetPosition()  );
	local returnPoint = newFrontVector * 1.5*battleScale;


	local petLoc = returnPoint;
	local petHome = HOME_LIST[pet.playerID].position;
	local newDist = petLoc:Dist ( petHome );

	local returnDistance = pet.actor:GetPosition():Dist(petLoc)

	if ( newDist > 1.75 * battleScale ) then 
		petLoc = HOME_LIST[pet.playerID].position;
		returnDistance = petHome:Dist(pet.actor:GetPosition());
	end

	if ( not opponent.dead and not opponent.isPad ) then
		local opponentHome = HOME_LIST[opponent.playerID].position;

		local opponentReturnDistance = opponent.actor:GetPosition():Dist(opponentHome)

		if ( opponentReturnDistance > 1.75 * battleScale ) then 		
			local distance = opponentHome:Dist(pet.actor:GetPosition());
			opponent.actor:MoveToAbs( opponentHome, distance/ ( opponent.moveSpeed*backwardSpeedMulti) );

		end
	end
	if ( not pet.dead and not pet.isPad) then 
		--pet.actor:WaitMoveToAbs( pet.home, returnDistance/ ( pet.speed*backwardSpeedMulti) );

		pet.actor:MoveToAbs( petLoc, returnDistance/ ( pet.moveSpeed*backwardSpeedMulti) );
		pet.actor:WaitMovementComplete()
		opponent.actor:WaitMovementComplete()
		pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
	end
end

"	0	0
622	"Brazie\'s PetBattle - Pet Movement - Knockback / Dodge"	"
function PerformTinySlide( opponent, pet, damage ) 
	local power = 30;
	local front = -math.random(power,power)*.025;
	local left = math.random(-power,power)*.025;
	local up = 0;

	--scene:WaitTimer(0.3)

	DebugPrint(\"slide\")		
	
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)

	--opponent.actor:AddDamageText(nil, damage, false, false)

	PerformRelativeSlide( opponent, pet, front, left, up );
end


function PerformDodge( opponent, pet ) 
	local coin = math.random(0,1);
	if ( coin == 0 ) then 
		coin = -1;
	end

	local front = 0.01;
	local left = 0.75*coin;
	local up = 0; 

	DebugPrint(\"dodge\") 
	opponent.actor:SetFacingToTarget( pet.actor, Vector:New() )
	pet.actor:SetFacingToTarget( opponent.actor, Vector:New() )

	opponent.actor:AddWorldText(opponent.actor, MissReasons.Dodged, false, false)

	PerformRelativeSlide( opponent, pet, front, left, up );
	--opponent.actor:ClearFacing(); 
end

function PerformKnockback( opponent, pet, howHard, duration ) 
	local front = howHard or 0.75;
	local left = 0
	local up = 0;

	front = front * -1;

	--scene:WaitTimer(0.3)

	print(\"knock\")		
	--opponent.actor:AddDamageText(nil, damage, false, false)
	local opponentFinalPoint 	= CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up );
	local driftDistance = 3

	local time = duration or 0.3 --driftDistance/battleScale/opponent.moveSpeed;

	--opponent.actor:MoveToAbs(opponentFinalPoint,  Vector:New() );
	opponent.actor:SetSnapToGround(false)
	local kit = opponent.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.Stand)

	opponent.actor:MoveSplineAbs( 
			BuildKnockbackSpline(opponent.actor:GetPosition(), opponentFinalPoint, time), time )
	opponent.actor:WaitMovementComplete()
	opponent.actor:SetSnapToGround(true)
	kit:Stop();

end 

function PerformJump( pet, dest, duration, animation )
	local moveTime = duration or 0.5
	local anim = animation or Animations.JumpLoop

	local kit;
	if ( anim ) then 
		-- This causes an animation to replace normal movement anims
		kit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, anim );
	end

	pet.actor:SetSnapToGround(false)
	pet.actor:MoveSplineAbs( 
			BuildKnockbackSpline(pet.actor:GetPosition(), dest, moveTime), moveTime )
	pet.actor:WaitMovementComplete()
	pet.actor:SetSnapToGround(true)

	if ( kit ) then 
		kit:Stop();
	end

end

function PerformSlide( opponent, pet ) 
	local front = -math.random(10,20)*.1;
	local left = math.random(-10,10)/10;
	local up = 0;

	scene:WaitTimer(0.3)

	DebugPrint(\"knock\")		
	--opponent.actor:AddDamageText(nil, damage, false, false)
	PerformRelativeSlide( opponent, pet, front, left, up );
end

function PerformVerticalKnockback( opponent, pet, damage ) 
	opponent.actor:SetSnapToGround(false)
	--opponent.actor:AddDamageText(nil, damage, false, false)

	opponent.actor:MoveSplineAbs(BuildKnockbackSpline(opponent.actor:GetPosition(), opponent.actor:GetPosition(), 0.5), 0.5)

	opponent.actor:WaitMovementComplete()
	opponent.actor:SetSnapToGround(true)
end"	0	0
623	"Brazie\'s PetBattle - Constant Overrides"	"-- Replace Arena Ring Size
arenaRingScale = 1.0

-- Replace Home Locations

HOME_LIST = {
	-- Weather
	[0] = Transform:New(Vector:New( 0, 0, 1), 180);
	-- Players
	[1] = Transform:New(Vector:New( -2, 0, 0), 0);
	[2] = Transform:New(Vector:New(  2, 0, 0), 180);
};
MASTER_SPOTS = { 
	-- Weather
	[0] = Transform:New(Vector:New( 0, 0, 3), 180);
	-- Players
	[1] = Transform:New(Vector:New( -5, 0, 1), 0);
	[2] = Transform:New(Vector:New(  5, 0, 1), 180);
};

BACKROW_PET_OFFSETS = {
	Vector:New(-1, 0, 0 );
	Vector:New(-1, 2, 0 );
	Vector:New(-1, -2, 0 );
};
"	0	0
624	"Brazie\'s PetBattle - Dispatcher"	"-- Responsible Object ID Tracking and Management
--
--ROID = 0xFFFF;

UNIT_ACTION_QUEUE = {
	--[ROID] = { 
	--  ROID = ROID;
	--  isProcessing = bool;
	--	commands = {
	--		{ func=function()end; args = {}; };
	--	};
	-- }
}

-- A global kill switch if I need it ??
BOT_KILL_SWITCH = false;

-- Parallel Mode Switch
PARALLEL_MODE = false;

function Dispatcher_AddCommandToQueue( responsibleObjectID, func, ...)

	if ( PARALLEL_MODE ) then
		if ( not UNIT_ACTION_QUEUE [responsibleObjectID] ) then
			UNIT_ACTION_QUEUE [responsibleObjectID] = {
				ROID = responsibleObjectID;
				isProcessing = false;
				commands = {};
			};
		end
		table.insert( UNIT_ACTION_QUEUE [responsibleObjectID].commands, 
			{
				func = func;
				args = {...};
			});

	else
		func(responsibleObjectID, ...);
	end

	--[[
	local status, result = pcall(func, responsibleObjectID, ...)
	if (status == true) then
		-- Research what this command does
		--setfenv(result, getfenv())

		print(\"Result from pcall was: \",type(result));

		return result
	else
		print(\"ERROR: Function Dispatched to \" .. responsibleObjectID.. \" failed.\")
		print(\"ERROR: \" .. result)
	end
	]]
end


function Dispatcher_HandleTurn(turn)
	-- DebugPrint(\"- Processing Turn \" .. turn.turnInstanceID.. \" Ability: \"..turn.abilityID)

	-- Turn Package? Hand-off

	local userROID = TurnToUserROID(turn);

	-- Attempt to process the package
	local processed = Dispatcher_HandleSpellVisualPackage(userROID, turn.turnVisualID, \"turn\", turn)

	-- Baseline
	if ( not processed ) then 
		Dispatcher_DefaultTurnBehaviour(userROID, turn )
	end
end 

ProcessRoundTurnGroup = Dispatcher_HandleTurn;

function Dispatcher_HandleSpellVisualPackage( ROID, turnVisualID, ...)

	-- use a custom script handler if we have one
	local turnVisual = nil
	if (turnVisualID) then
		turnVisual = petAbilityVisuals[turnVisualID]
	end
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		Dispatcher_AddCommandToQueue( ROID, turnVisual.scriptFunction, ...)
		processed = true;
	end

	return processed
end
"	0	0
625	"Brazie\'s PetBattle - Dispatcher - Display Damage"	"function Dispatcher_SetHealth(ROID, newHealth, dontDraw, crit)
	local pet = ROIDTOPET( ROID )

	SetHealth(pet, newHealth, dontDraw, crit);
end

function SetHealth(pet, newHealth, dontDraw, crit)
	local oldHealth = pet.currentHealth
	pet.currentHealth = newHealth

	local change = 0;

	if ( oldHealth ) then
		change = newHealth - oldHealth

		if ( not dontDraw ) then
			DisplayHealthChange(pet, change, crit)
		end
	end
 
	--Dispatcher_AddCommandToQueue( PETTOROID(pet), Dispatcher_DeathAndRespawnCheck ); 

	return change, DeathAndRespawnCheck(pet);
end


function DisplayHealthChange(pet, change, crit)
	-- damage numbers feedback for observed battles
	if (isObserved) then
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, crit, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, crit, false)
		end
	end
end

"	0	0
626	"Brazie\'s PetBattle - Dispatcher - Death and Respawn Check"	"function Dispatcher_DeathAndRespawnCheck(ROID)
	local pet = ROIDTOPET( ROID )
if ( not pet ) then 
	print (\"ERROR: Dispatcher_DeathAndRespawnCheck - No pet!\");
	return;
end
	return DeathAndRespawnCheck(pet);
end


--
-- Returns:
--
--		nil - no change
--		\"died\" - pet just perished
--		\"dead\" - pet was dead and remained dead
--		\"respawn\" - pet was dead and is now alive
function DeathAndRespawnCheck(pet)
	if (pet.currentHealth <= 0) and (not pet.dead) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector( (pet.teamFacing or 0.0), idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then 
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
			pet.dead = true;
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
			pet.dead = true;
		end

		return \"died\"
	elseif (pet.currentHealth <= 0) and (pet.dead) then
		return \"dead\"
	elseif (pet.currentHealth > 0) and (pet.dead) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		pet.dead = nil;

		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		--LookAtOpposingTeam(pet)
		pet.actor:Fade(1, 0.5)
		--UpdateAuraVisuals(pet)

		return \"respawn\"
	end
end"	0	0
627	"Brazie\'s PetBattle - Dispatcher - Display XP"	"function Dispatcher_SetXP(ROID, ...)
	local pet = ROIDTOPET( ROID )

	return SetXP(pet, ...)
end

function SetXP(pet, xp, level, dontDraw)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (dontDraw) then
		return
	end
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	ShowXPGains(pet, xpChange, levelChange, dontDraw)
end

function ShowXPGains(pet, xpChange, levelChange, dontDraw)		
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end"	0	0
628	"Brazie\'s PetBattle - Dispatcher - Pet Owner Emote"	"function Dispatcher_OwnerEmote( ROID, emote )
	local player = ROIDTOPLAYER( ROID )
	if (player and player.playerDisplay) then
		player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, emote)
	end
end"	0	0
630	"Brazie\'s PetBattle - Core - Default Do Result Processing"	"
function DoResult(result, dontWait, successEffect, failureEffect, func, ... )
	local targetROID = ResultToTargetROID(result);

	local failType = nil;

	if ( result.miss ) then 
		failType = \"miss\";
	elseif ( result.block ) then
		failType = \"block\";
	end

	if ( not failType ) then 
		if ( type(successEffect) == \"function\" ) then
			successEffect( targetROID, result );
		end
	else
		if ( type(failureEffect) == \"function\" ) then 
			failureEffect( targetROID, result );
		end
	end


	-- Do the special thing
	if ( type(func) == \"function\" ) then 
		func(targetROID, result, ...);
	else
		print(result)
	end

	-- signal the impact
	SignalEffectProcessed()

end"	0	0
632	"Brazie\'s PetBattle - Effect - GetStandardData"	"function GetStandardData(result)
	local effectDebug = false;
print(\"Result: \",result);

	local casterPlayerID = result.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[result.casterPetSlot]

	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]

	if ( effectDebug == true ) then
		local castingTeamName = \"Unknown\";
		local castingPetSlotName = \"Unknown\";


		for k,v in pairs(PetBattlePlayerID) do 
			if ( v == result.casterPlayerID ) then
				castingTeamName = k;
			end
		end
		for k,v in pairs(PetBattlePetID) do 
			if ( v == result.casterPetSlot ) then
				castingPetSlotName = k;
			end
		end

		DebugPrint(\"Requesting standard data for \",castingTeamName,\" slot \",castingPetSlotName);
	end

	-- Only happens during swaps... grrr
	if  ( not result.target ) then
		return casterCastingPet, nil
	end

	if ( effectDebug == true ) then 
		local targetTeamName = \"Unknown\";
		for k,v in pairs(PetBattlePlayerID) do 
			if ( v == result.target.playerID ) then
				targetTeamName = k;
			end
		end
		local targetPetSlotName = \"Unknown\";
		for k,v in pairs(PetBattlePetID) do 
			if ( v == result.target.petSlot ) then
				targetPetSlotName = k;
			end
		end

		DebugPrint(\"Requesting standard target data for \",targetTeamName,\" slot \",targetPetSlotName);
	end

	local targetData = result.target
	local targetPlayerID = targetData.playerID;

	if ( targetPlayerID > 2 ) then
		print(\"ERROR: Target Player ID is: \",targetPlayerID);
		return casterCastingPet, nil
	end

	local targetPlayer = GetTeamByIndex(targetPlayerID)
	if ( not targetPlayer ) then 
		print(\"ERROR: Invalid targetPlayerID (\",targetPlayerID,\")\");
		return casterCastingPet, nil
	end
	local targetPet = targetPlayer.pets[targetData.petSlot]

	return casterCastingPet, targetPet
end"	0	0
633	"Brazie\'s PetBattle - Dispatcher - Result - Set Health"	"function set_health_func(targetROID, result, ...)
	local targetPet = ROIDTOPET(targetROID);

	local oldHealth = targetPet.currentHealth
	local newHealth = select(1,...)
	local hidden = false;

	local crit = false; 

	if ( result.crit ) then 
		crit = true;
	end

	result = SetHealth(targetPet, newHealth, hidden, crit )

	-- This shouldn\'t be an inline response - convert to a dispatch later
	if ( result == \"died\" ) then
		local targetMaster = GETROIDFROMPLAYERID(targetPet.playerID) + ROID_TYPE_PLAYER_MASTER;
		local casterMaster = GETROIDFROMPLAYERID(3-targetPet.playerID) + ROID_TYPE_PLAYER_MASTER;

		Dispatcher_AddCommandToQueue( targetMaster, Dispatcher_OwnerEmote, Animations.EmoteCry )
		Dispatcher_AddCommandToQueue( casterMaster, Dispatcher_OwnerEmote, Animations.EmoteCheer )
	elseif ( result == \"respawn\" ) then
		local casterMaster = GETROIDFROMPLAYERID(targetPet.playerID) + ROID_TYPE_PLAYER_MASTER;
		Dispatcher_AddCommandToQueue( casterMaster, Dispatcher_OwnerEmote, Animations.EmoteCheer )
	end

end"	0	0
635	"Brazie\'s PetBattle - Dispatcher - Result - Aura Change"	"function aura_change_func(targetROID, result, ...)
	local targetPet = ROIDTOPET( targetROID );

	if not targetPet then
		print(\"ERROR: Unknown pet provided to aura_change_func: \", ROIDTOSTRING(targetROID), result );
		return;
	end

	local auraInstanceID, turnsRemaining, cancel = ...
	local aura = targetPet.auras[auraInstanceID]
	if not aura then
		print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
--print(result);
		print(\"WARNING: Attempting to reapply aura\");
		aura = ApplyAura(targetPet, auraInstanceID, turnsRemaining, auraVisualID);
	end

	if ( not turnsRemaining ) then
		print(\"ERROR: no turns remaining\");
	end

	if (cancel == true) or (turnsRemaining < 1) then
		RemoveAura(targetPet, auraInstanceID)
	else
		aura.turnsRemaining = turnsRemaining
	end
end
"	0	0
636	"Brazie\'s PetBattle - Dispatcher - Result - Shared"	"--[[
function preEffect_visual(targetPet, casterPet, result)
	local abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID = GetVisualData(result)

	PerformSpellVisual(casterPet, abilityVisualID, targetPet )
end

function successEffect_visual(targetPet, casterPet, result)
	local abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID = GetVisualData(result)

	local useID = spellVisualID

--print(abilityVisualID, \",\", spellVisualID, \",\", turnVisualID, \",\", turnVisualSpellID)
	if ( not spellVisualID and not turnVisualSpellID) then 
		print( \"No Spell Visual ID provided to successEffect_visual\" );
		return;
	elseif ( not spellVisualID and turnVisualSpellID ) then 
		useID = turnVisualSpellID;
	end
	targetPet.actor:PlaySpellImpactVisual(useID)

	-- If its not a proc, knock!
	local team = GetTeamByIndex(casterPet.playerID)

	if ( not team ) then
		print(\"Error: missing team. \"..casterPet.playerID);
	end
	if ( team and casterPet.slot == team.activePet ) then 
		PerformTinySlide( targetPet, casterPet ) 
		--PerformHardKnockback( targetPet, casterPet ) 
	end
end

function failureEffect_visual(targetPet, casterPet, result)
	PerformDodge( targetPet, casterPet ) 
end
--]]"	0	0
637	"Brazie\'s PetBattle - Dispatcher - Result - Aura Apply"	"function apply_aura_func( targetROID, result, ... )
	local targetPet = ROIDTOPET( targetROID );

	local auraInstanceID, turnsRemaining, auraAbilityID = ...

	local auraSpellVisualID = 0
	local auraVisual = GetAuraAbilityVisual(auraAbilityID)
	if (auraVisual) then
		auraSpellVisualID = auraVisual.spellVisualID
	end

	-- apply an aura, tracked by instance ID

print(\"Applying aura to \",targetPet.slot,\" of \",auraVisualID,\" using spell visual ID: \",auraSpellVisualID);

	if ( targetPet ) then
		local aura = ApplyAura(targetPet, auraInstanceID, turnsRemaining, auraSpellVisualID);

		if ( aura and auraVisual and auraVisual.scriptFunction ) then 
			PARALLEL_MODE = true;
				Dispatcher_AddCommandToQueue(targetROID, auraVisual.scriptFunction, \"aura\", aura, auraInstanceID, turnsRemaining ); 	 

				scene:WaitTimer(0.01);
			PARALLEL_MODE = false
		end
	else
		print(\"ERROR: Invalid pet supplied to apply_aura: \", ROIDTOSTRING( targetROID ), result );
	end
 
end

--[[
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		if ( turnVisual.scriptFunction( turnGroup ) ) then
			processed = true
		end
	end
]]--"	0	0
638	"Brazie\'s PetBattle - Dispatcher - Result - Swap "	"function swap_func(targetROID, result )
	local casterPlayer 		= ROIDTOPLAYER( targetROID ) ;
	local casterNewFrontPet = ROIDTOPET( targetROID );
	local casterFrontPet 	= casterPlayer.pets[casterPlayer.activePet]

	local opponentPlayer 	= GetTeamByIndex(3-casterNewFrontPet.playerID)
	local opponentFrontPet 	= opponentPlayer.pets[opponentPlayer.activePet]

	local casterMasterROID = GETROIDFROMPLAYERID(casterPlayerID) + ROID_TYPE_PLAYER_MASTER;

	if ( casterNewFrontPet.slot ~= casterFrontPet.slot ) then 
		Dispatcher_AddCommandToQueue( casterMasterROID, Dispatcher_OwnerEmote, Animations.EmotePoint )

		casterPlayer.activePet = casterNewFrontPet.slot

		-- This could probably be dispatched
		PerformSwap( casterFrontPet, casterNewFrontPet, opponentFrontPet );

	else
		casterPlayer.activePet = casterNewFrontPet.slot

		DebugPrint(\"Passed.\")
	end
	-- Clean up also forces the pets to run forward.
	DefaultTurnCleanUp(targetROID);
end"	0	0
639	"Brazie\'s PetBattle - Core - Default Do Effect Processing"	"function DefaultDoEffectProcessing(userROID, isEffect, effect, handlerOverrides ) 
	-- Only handle \"effect\" objects
	if ( isEffect ~= \"effect\" ) then
		print (\"ERROR: Object of type \"..isEffect..\" passed to DefaultDoEffect\");
		return SignalEffectProcessed();
	end

	for index=1,#effect.results do 
		local result = effect.results[index];

		StartEffectProcessing(result)
		
		local handlerTable = GetDefaultHandlerTable(result, index);

		-- Allows you to blow away basic handling
		if ( handlerOverrides ) then
			for eventType,overrides in pairs(handlerOverrides) do 
				
				for k,v in pairs(overrides) do 
					if ( not handlerTable[eventType] ) then
						handlerTable[eventType] = {};
					end
					handlerTable[eventType][k] = v;
				end
			end
		end

		local eventType = result.eventType
		local effectType = result.resultType

		-- This should only occur in case of a bug...
		if eventType and not (eventType == PetBattleEvent.RoundResult ) then
			break;
		end
		
		SignalEffectProcessed()

		-- DoFunction
		if ( handlerTable[effectType] ) then 
			local success = handlerTable[effectType].successEffect
			local failure = handlerTable[effectType].failureEffect

			local victimROID = ResultToTargetROID ( result );
			local successFunc;
			local failureFunc;

			-- sometimes I get slotless effects...
			if ( victimROID ~= nil and userPet ) then 
				successFunc = function () success(victimROID, userROID); end;
				failureFunc = function () failure(victimROID, userROID); end;
			end

			DoResult(result, 
				handlerTable[effectType].dontWait, 
				successFunc,
				failureFunc,
				handlerTable[effectType].func, 
				unpack( handlerTable[effectType].args) )
		else
			DebugPrint(\"UNHANDLED EFFECT TYPE: \",effectType);
		end

		if (result.procGroup) then
			ProcessRoundTurnGroup(result.procGroup)
		end
	end
end
"	0	0
640	"Brazie\'s PetBattle - Core - Default Turn Behaviour"	"function Dispatcher_DefaultTurnBehaviour( ROID, turn )
	DefaultTurnBehaviour( ROID, \"turn\", turn);
end 

function DefaultTurnBehaviour( ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to DefaultDoEffect\");

		return;
	end

	local visuals = true;

	-- If this is not being performed by a specific pet, skip the casting effects
	if ( not ROIDISAPET( ROID ) ) then
		visuals = false;
		userROID = nil;
	end

	-- Move into position
	DefaultTurnPreEffectMovement(ROID, turn )

	local turnVisualPlayed = false;

	if ( visuals ) then 
		turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn)
	end

	-- Handle all effects
	for index=1,#turn.effects do 
		local effect = turn.effects[index];
		local effectVisualPlayed

		if ( visuals ) then  
			effectVisualPlayed = DefaultDoEffect(ROID, effect)

			if ( effectVisualPlayed ) then 
				DefaultEffectCleanUp( ROID );
			end
		else
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
	end

	if ( turnVisualPlayed ) then 
		DefaultTurnCleanUp(ROID);
	end
end

function DefaultTurnCleanUp(ROID)
	local userPet = ROIDTOPET( ROID  );
	userPet.actor:WaitCastingComplete();

	scene:WaitTimer(0.75);

	-- Reset/reposition
	Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );
end


--
--  Moves the unit into the right place
--
function DefaultTurnPreEffectMovement( ROID, turn )
	local turnVisualID = turn.turnVisualID ;

	local turnVisual = petAbilityVisuals[turnVisualID]

	-- Stationary if undefined
	if ( not turnVisual ) then 
		print(\"ERROR: No turn ability visual!\",turnVisualID)
		Dispatcher_AddCommandToQueue(ROID, PerformMove, PetBattleRange.InPlace ); 
	else
		Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); 
	end

end

-- Play a visual and hit every involved unit
function DefaultTurnVisualHandler( ROID, turn, overrideSuccess, overrideFailure )
	local turnVisualID = turn.turnVisualID ;

	local turnVisual = petAbilityVisuals[turnVisualID]

	if ( turnVisual ) then 
		
		-- Perform the Turn Visual
		local masterTargets = {}

		for index=1,#turn.effects do 
			local effect = turn.effects[index];
			local targets = EffectToROIDs ( effect );

			for k,v in pairs(targets) do 
				table.insert(masterTargets, v);
			end
		end

		Dispatcher_PerformMultiTargetVisual(ROID, masterTargets, turnVisualID )

		for index=1,#turn.effects do 
			local effect = turn.effects[index];			
			DefaultEffectVisualHandler(ROID, effect, turnVisualID)
		end

		return true;
	end

	return false;
end

-- Default Effect Handler

function DefaultEffectVisualHandler(ROID, effect, visualID, overrideSuccess, overrideFailure)
	local result = effect.results[1];
	local targetROID = ResultToTargetROID(result)

	local failType = nil;

	if ( result.miss ) then 
		failType = \"miss\";
	elseif ( result.block ) then
		failType = \"block\";
	end

	if ( not failType ) then 
		local success = overrideSuccess or Dispatcher_DefaultSuccessVisual;
		success ( targetROID, ROID, visualID )
	else
		local failure = overrideFailure or Dispatcher_DefaultFailureVisual;
		failure( targetROID, ROID, visualID, failType )
	end
end


-- Play a visual and hit every involved unit
function DefaultTurnOnEffectVisualHandler( ROID, turn, effect, overrideSuccess, overrideFailure )
	local turnVisualID = turn.turnVisualID ;
	local turnVisual = petAbilityVisuals[turnVisualID]

	if ( turnVisual ) then 
		local masterTargets = {}
		local targets = EffectToROIDs ( effect );

		for k,v in pairs(targets) do 
			table.insert(masterTargets, v);
		end

		Dispatcher_PerformMultiTargetVisual(ROID, masterTargets, turnVisualID )

		local result = effect.results[1];
		local targetROID = ResultToTargetROID(result)
"	0	706
641	"Brazie\'s PetBattle - BitLib"	"function bit(p)
  return 2 ^ (p - 1)  -- 1-based indexing
end

-- Typical call:  if hasbit(x, bit(3)) then ...
function hasbit(x, p)
  return x % (p + p) >= p       
end

function setbit(x, p)
  return hasbit(x, p) and x or x + p
end

function clearbit(x, p)
  return hasbit(x, p) and x - p or x
end

function bitor(x, y)
  local p = 1; 
  local z = 0; 
  local limit = x > y and x or y
  while p <= limit do
    if hasbit(x, p) or hasbit(y, p) then
      z = z + p
    end
    p = p + p
  end
  return z
end

function bitand(x, y)
  local p = 1; 
  local z = 0; 
  local limit = x > y and x or y
  while p <= limit do
    if hasbit(x, p) and hasbit(y, p) then
      z = z + p
    end
    p = p + p
  end
  return z
end"	0	0
642	"Brazie\'s PetBattle - ROIDs"	"
-- Responsible Object ID
ROID_TYPE_PLAYER_PET_SLOT_1 = 0x0001; 
ROID_TYPE_PLAYER_PET_SLOT_2 = 0x0002;
ROID_TYPE_PLAYER_PET_SLOT_3 = 0x0004;
ROID_TYPE_PLAYER_MASTER		= 0x0008;
ROID_TYPE_PLAYER_PAD		= 0x0010;
ROID_TYPE_PLAYER_PAD_OBJ_1	= 0x0020;
ROID_TYPE_PLAYER_PAD_OBJ_2	= 0x0040;
ROID_TYPE_PLAYER_PAD_OBJ_3	= 0x0080;

ROID_TYPE_WEATHER			= 0x0100;

ROID_TYPE_PLAYER_1 			= 0x1000;
ROID_TYPE_PLAYER_2 			= 0x2000; 

function ROIDISAPET( ROID ) 
	return (bitand(ROID,0x07) > 0)
end


function ROIDTOSTRING( ROID ) 
	if ( not ROID ) then
		print(\"ERROR: Nil passed in to ROIDTOSTRING.\");
		return nil;
	end

	if ( not ROIDISAPET( ROID ) ) then 
		if ( ROID == ROID_TYPE_PLAYER_1 ) then
			return \"Player 1 - No Unit\";
		elseif ( ROID == ROID_TYPE_PLAYER_2 ) then
			return \"Player 2 - No Unit\";
		elseif ( ROID == ROID_TYPE_WEATHER ) then
			return \"Weather - No Unit\";
		end
		if ( ROID == 38 ) then
			errorzZ()
		end
		return \"Invalid ROID: \"..ROID;
	end

	local pet = ROIDTOPET(ROID);
	local playerID = pet.playerID;
	local slot = pet.slot;

	local castingTeamName = \"Unknown\";
	local castingPetSlotName = \"Unknown\"; 

	for k,v in pairs(PetBattlePlayerID) do 
		if ( v == playerID ) then
			castingTeamName = k;
		end
	end
	for k,v in pairs(PetBattlePetID) do 
		if ( v == slot ) then
			castingPetSlotName = k;
		end
	end

	return castingTeamName..\" - Pet \"..castingPetSlotName;
end

function ROIDTOPLAYER( ROID ) 
	if ( not ROID ) then
		print(\"ERROR: Nil passed in to ROIDTOSTRING.\");
		return nil;
	end

	local playerID = 0;
	if ( bitand(ROID, ROID_TYPE_WEATHER) == ROID_TYPE_WEATHER ) then
		playerID = PetBattlePlayerID.Weather;
	elseif ( bitand(ROID, 0xF000) == ROID_TYPE_PLAYER_1 ) then
		playerID = PetBattlePlayerID.Player1;
	elseif ( bitand(ROID, 0xF000) == ROID_TYPE_PLAYER_2 ) then
		playerID = PetBattlePlayerID.Player2;
	else
		return nil;
	end

	return GetTeamByIndex(playerID)
end

function ROIDTOPET( ROID ) 
	if ( not ROID ) then
		print(\"ERROR: Nil passed in to ROIDTOSTRING.\");
		return nil;
	end

--print(ROID,\" p1: \",ROID_TYPE_PLAYER_1, \" p2: \",ROID_TYPE_PLAYER_2)
	local player = ROIDTOPLAYER( ROID );

	if ( player ) then
		local slot = nil;

		if ( bitand(ROID, 0x001F) == ROID_TYPE_PLAYER_PET_SLOT_1 ) then
			slot = PetBattlePetID.Slot1
		elseif ( bitand(ROID, 0x001F) == ROID_TYPE_PLAYER_PET_SLOT_2 ) then
			slot = PetBattlePetID.Slot2
		elseif ( bitand(ROID, 0x001F) == ROID_TYPE_PLAYER_PET_SLOT_3 ) then
			slot = PetBattlePetID.Slot3
		elseif ( bitand(ROID, 0x001F) == ROID_TYPE_PLAYER_PAD ) then
			slot = PetBattlePetID.Pad
		elseif ( bitand(ROID, ROID_TYPE_WEATHER) > 0 ) then
			slot = PetBattlePetID.Weather
		end

		if ( slot ) then
			return player.pets[slot]
		end
	end

	return nil;
end

function GETROIDFROMPLAYERID( playerID )
	local roid = 0;
	if ( playerID == 0 ) then
		roid = roid + ROID_TYPE_WEATHER
	elseif ( playerID == 1 ) then
		roid = roid + ROID_TYPE_PLAYER_1
	elseif ( playerID == 2 ) then
		roid = roid + ROID_TYPE_PLAYER_2
	end
	return roid;

end

function GETROIDFROMPLAYERIDANDSLOT( playerID, slot )
	local roid = GETROIDFROMPLAYERID( playerID );
--print(\"Getter: \",playerID, \" \", slot);

	if ( roid == ROID_TYPE_WEATHER ) then 
		return roid;
	end

	if ( slot == PetBattlePetID.Slot1 ) then
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_1
	elseif ( slot == PetBattlePetID.Slot2 ) then
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_2
	elseif ( slot == PetBattlePetID.Slot3 ) then
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_3
	elseif ( slot == PetBattlePetID.Pad ) then
		roid = roid + ROID_TYPE_PLAYER_PAD
	end

	return roid
end

function PETTOROID( pet ) 
	local roid  = GETROIDFROMPLAYERIDANDSLOT ( pet.playerID, pet.slot );
--print(\"NEW RROID: \"..roid);
	return roid;
end"	0	0
643	"[1] PetBattle - 3. Playback Turn"	"end
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then
		print (\"WARNING: max turn instanceIDs exceeded \" .. maxTurnInstanceIDs)
	end
	
	local turnKey = turnInstanceID*maxStackDepth + stackDepth
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey
	return turnKey, effectKey
end

function HandleSpellVisualPackage(casterPlayerID, casterPetSlot, turnVisualID, ...)

	-- use a custom script handler if we have one
	local turnVisual = nil
	if (turnVisualID) then
		turnVisual = petAbilityVisuals[turnVisualID]
	end
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		Dispatcher_AddCommandToQueue(casterPlayerID, casterPetSlot, turnVisual.scriptFunction, ...)
		processed = true;
	end

	return processed
end

"	600	0
644	"Brazie\'s PetBattle - Dispatcher - Post Attack Cleanup"	"
-- Reset after an attack if needed
function Dispatcher_PerformPostAttackCleanup( ROID )
	local pet = ROIDTOPET(ROID);
	if ( not pet ) then 
		print (\"ERROR: Post-Attack Clean-up - Invalid ROID: \"..ROIDTOSTRING(ROID)..\" || \"..ROID);
		return;
	end

	local opponent = GetActivePetByIndex(3 - pet.playerID)
		
	ReturnOrResetCheck( pet, opponent );
end

"	0	0
645	"Turn Package - Multi-Attack"	"function Dispatcher_MultiAttack( ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_MultiAttack\");

		return;
	end

	-- Generate some points
	local points = {
	}

	local numPoints = #turn.effects;

	local offset=270
	local step= 720/numPoints;

	for i=offset+step,offset+720,step do 
		local sin = math.sin(i/180*math.pi)*1.25
		local cos = math.cos(i/180*math.pi)*1.25
		table.insert(points, Vector:New(sin, cos, 0));

	end

--print(\"NumPoints: \",numPoints);
--print(\"Turn1: \"..turn.effects[1]);

	local pet = ROIDTOPET(ROID);
--print(\" pet.playerID: \", pet.playerID);
--[[
local t = GetTeamByIndex(1);

	for k,v in pairs (turn.effects) do
		print(\"K: \",k,\" V: \",v);
	end 
--]]
	-- TERRIBLE HACKL WHILE DARREN IS OUT OF TOWN. FIX PLZ
	if ( not GetTeamByIndex(1).activePet ) then 
		GetTeamByIndex(1).activePet = 0;
	end
	if ( not GetTeamByIndex(2).activePet ) then 
		GetTeamByIndex(2).activePet = 0;
	end

	local originalPetLoc = VectorCopy(pet.actor:GetPosition());

	local i=0;

	local visualMode = \"turn\";


	-- Get up close
	DefaultTurnPreEffectMovement( ROID, turn )

	-- Handle all effects
	for index=1,#turn.effects do 
		local effect = turn.effects[index];

		-- Use the first result from each effect
		local targetROID = ResultToTargetROID(effect.results[1])
		local target =  ROIDTOPET(targetROID);

		local originalTargetLoc = VectorCopy(target.actor:GetPosition());

		-- Face the target
		pet.actor:SetFacingToTarget(target.actor, Vector:New())


		-- Do the effect visual
		if ( visualMode == \"turn\" ) then 
			local effectVisualPlayed = DefaultTurnOnEffectVisualHandler( ROID, turn, effect )
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 

		elseif ( visualMode == \"effect\" ) then  
			local effectVisualPlayed = DefaultDoEffect( ROID, effect )

		else
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
 
		-- ## Unique Stuff Start 
		i = i + 1;
		local v = points[i]; 
		if ( v ) then 
			local newDrift = FastLocalFacingCoordinates(originalTargetLoc, originalPetLoc , v * -battleScale );
			local targetDriftPoint 	=  newDrift;
			local driftDistance = targetDriftPoint:Dist( pet.actor:GetPosition() )
			pet.actor:MoveToAbs(targetDriftPoint, driftDistance/pet.moveSpeed );
		end
		-- ## Unique Stuff End

	end

	-- Reset/reposition
	DefaultTurnCleanUp(ROID);

end
"	0	0
646	"Brazie\'s PetBattle - Dispatcher - Result - SetState"	"function set_state_func(targetROID, result) 
	local targetPet = ROIDTOPET( targetROID );

	local label = \"Unknown State\";

	for k,v in pairs(STATE_LOOKUP) do
		if ( v == result.stateID ) then
			label = k;
			break;
		end
	end

	DebugPrint(\"*** State Update: \",label,\" = \",result.value) 

	-- stealth activated
	if ( result.stateID == 84 ) then

		if ( result.value > 0 ) then
			targetPet.stealthed = true;
		else
			targetPet.stealthed = false;
		end
		
		targetPet.actor:Fade( GetNaturalAlpha( targetROID ) , 0.5)
	end
end"	0	0
647	"zzOld - PetBattle(fallback) - EffectSet State"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
local debugStates = false
function EffectSetState(effect)
	if (not effect) then
		return
	end

	for targetIndex, target in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(target.playerID)
		local targetPet = targetPlayer.pets[target.petSlot]

		if (target and target.stateID and target.stateValue) then
			if (debugStates == true) then
				print(\"STATE CHANGE: Player \" .. target.playerID .. \", Pet \" .. target.petSlot .. \" - \" .. \"State \" .. target.stateID .. \" = \" .. target.stateValue )
			end
		end
	end
end
"	0	0
648	"Turn Package - Vanish - Ambush"	"function Dispatcher_VanishAttackOnMultiHit( ROID, isTurn, turn )

	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_VanishAttackOnMultiHit\");

		return;
	end

	-- Behave normally on 1 effect
	if ( #turn.effects == 1 ) then 
		DefaultTurnBehaviour( ROID, isTurn, turn )

	else
		-- ## Unique Stuff Start 
		local pet = ROIDTOPET(ROID);
		local opponent = GetActivePetByIndex(3 - pet.playerID)
		local alpha = 0;
		local delay = 0.5; -- sec
		pet.actor:PlaySpellCastVisual(255);
		pet.actor:Fade(alpha, delay)
		scene:WaitTimer(delay)
		pet.actor:SetFacingToTarget(opponent.actor, Vector:New())

		local opponentLocation = opponent.actor:GetPosition()
		local behindSpot = FastLocalFacingCoordinates(opponentLocation, pet.actor:GetPosition() , Vector:New(-0.5,0,0) );

		local distance = opponentLocation:Dist( behindSpot )

		pet.actor:WaitMoveToAbs(behindSpot,0); --driftDistance/pet.moveSpeed 

		pet.actor:PlaySpellCastVisual(255);
		pet.actor:Fade( GetNaturalAlpha(ROID) , delay)
		scene:WaitTimer(delay)

		-- ## Unique Stuff End
		local effect = turn.effects[2];
		local effectVisualPlayed = DefaultTurnOnEffectVisualHandler( ROID, turn, effect )

		DefaultDoEffectProcessing( nil, \"effect\", effect ); 

		if ( effectVisualPlayed ) then 
			DefaultTurnCleanUp( ROID );
		end
	end
end
"	0	0
649	"Brazie\'s PetBattle - Dispatcher - Thread Bot 1"	"local myROID;
local myList=nil;

while( not BOT_KILL_SWITCH ) do
	for k,v in pairs(UNIT_ACTION_QUEUE) do
		if ( v.isProcessing == false and #v.commands > 0 ) then 
			myROID = k;
			myList = v;
			break;
		end
	end

	if ( myROID ) then 
--print( \"Bot Acquired Task for \", ROIDTOSTRING(myROID) );
		UNIT_ACTION_QUEUE[myROID].isProcessing = true;
		
		while myList.commands[1] ~= nil do
			local task = myList.commands[1];
--print(\"Mine: \",ROIDTOSTRING(myROID));
--print(\"Other: \",ROIDTOSTRING(task.args[1]));
--DEBUG_TABLE(task.args);
			local result = task.func(myROID, unpack(task.args));

			--print(\"Bot1 Result: \",result)

			table.remove(myList.commands,1);
		end
	
		UNIT_ACTION_QUEUE[myROID].isProcessing = false;
		myROID = nil;
		myList = nil;
--print( \"Bot 1 Released Task\" );
	end

	scene:WaitTimer(0)
end"	0	0
650	"Brazie\'s PetBattle - Dispatcher - Thread Bot 2"	"local myROID;
local myList=nil;

while( not BOT_KILL_SWITCH ) do
	for k,v in pairs(UNIT_ACTION_QUEUE) do
		if ( v.isProcessing == false and #v.commands > 0 ) then 
			myROID = k;
			myList = v;
			break;
		end
	end

	if ( myROID ) then 
--print( \"Bot 2 Acquired Task for \", ROIDTOSTRING(myROID) );
		UNIT_ACTION_QUEUE[myROID].isProcessing = true;
		
		while myList.commands[1] ~= nil do
			local task = myList.commands[1];
--print(\"Mine: \",ROIDTOSTRING(myROID));
--print(\"Other: \",ROIDTOSTRING(task.args[1]));
--DEBUG_TABLE(task.args);
			local result = task.func(myROID, unpack(task.args));

			--print(\"Bot1 Result: \",result)

			table.remove(myList.commands,1);
		end
	
		UNIT_ACTION_QUEUE[myROID].isProcessing = false;
		myROID = nil;
		myList = nil;

--print( \"Bot 2 Released Task\" );

	end

	scene:WaitTimer(0)
end"	0	0
651	"Brazie\'s PetBattle - Helper Functions"	"allPetsShown = true;

function GetNaturalAlpha(ROID)
	local player = ROIDTOPLAYER( ROID ) 
	local pet = ROIDTOPET( ROID ) 

	if ( pet.slot == player.activePet ) then

		if ( pet.stealthed ) then 
			return 0.5;
		else
			return 1;
		end
	elseif ( allPetsShown ) then

		if ( pet.stealthed ) then 
			return 0.5;
		else
			return 0;
		end
	end
end"	0	0
652	"Turn Package - Skip Turn, Run The First N Effects"	"function Dispatcher_SkipTurnAnimateEffects1toN( n, ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_SkipTurnAnimateEffects1toN\");

		return;
	end

	local visuals = true;

	-- If this is not being performed by a specific pet, skip the casting effects
	if ( not ROIDISAPET( ROID ) ) then
		visuals = false;
		userROID = nil;
	end

	-- Move into position
	DefaultTurnPreEffectMovement(ROID, turn )

	local turnVisualPlayed = false;

	if ( visuals ) then 
		--turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn)
	end

	-- Handle all effects
	for index=1,#turn.effects do 
		local effect = turn.effects[index];
		local effectVisualPlayed

		if ( index <= n ) then
			effectVisualPlayed = DefaultDoEffect(ROID, effect)

			if ( effectVisualPlayed ) then 
				DefaultEffectCleanUp( ROID );
			end
		else
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
	end

	if ( turnVisualPlayed ) then 
		DefaultTurnCleanUp(ROID);
	end
end"	0	0
653	"Turn Package - Leap Into Range - Play N"	"function Dispatcher_LeapIntoMeleeOnlyPlayN( n, ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_LeapIntoMeleeOnlyPlayN\");

		return;
	end

	local turnVisualPlayed

	local abilityVisualID = turn.firstEvent.resultVisualID
	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if ( abilityVisual ) then 
		-- Get me in position
		Dispatcher_AddCommandToQueue(ROID, PerformLeap, abilityVisual.range, Animations.Jump )
		turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn)
	end

	-- Handle all effects
	for index=1,#turn.effects do 
		local effect = turn.effects[index];
		local effectVisualPlayed

		if ( index <= n ) then 
			effectVisualPlayed = DefaultDoEffect(ROID, effect)

			if ( effectVisualPlayed ) then 
				DefaultEffectCleanUp( ROID );
			end
		else
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
	end

	-- Default CleanUp
	DefaultTurnCleanUp(ROID);
end"	0	0
654	"Brazie\'s PetBattle - Turn - Perform Move"	"
-- Moves the unit to the correct location based on the ability
function PerformMove(ROID, range)
	local pet = ROIDTOPET(ROID);
	if ( not pet or (pet and pet.isPad) ) then
		return;
	end

	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	pet.actor:ClearFacing(); 

	--casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)
	local finalDestination = nil;

	-- Melee
	if ( range == PetBattleRange.Melee ) then 
		local meleePoint = frontVector * 1*battleScale;
		local meleeAttackPoint = opponentLocation + meleePoint;
		finalDestination = meleeAttackPoint;
	-- Ranged
	elseif ( range == PetBattleRange.Ranged ) then 
		local rangedPoint = frontVector * 2*battleScale;
		local rangedAttackPoint = opponentLocation + rangedPoint;
		finalDestination = rangedAttackPoint;
	-- Stationary
	elseif (range == PetBattleRange.InPlace ) then 
		pet.actor:SetFacingToAbs(opponentLocation)
	-- Do nothing
	else
		Print(\"ERROR: PerformMove - No movement range specified!\");
	end

	if ( finalDestination ) then 
		local distance = finalDestination:Dist( pet.actor:GetPosition() );

		if ( distance > 0.02 ) then 
			moveTime = distance/battleScale/(pet.moveSpeed);
			pet.actor:WaitMoveToAbs(finalDestination, moveTime)
		end
	else
		-- \"You didnt need to go anywhere
	end
end

"	0	0
655	"Brazie\'s PetBattle - Turn - Perform Leap"	"
-- Moves the unit to the correct location based on the ability
function PerformLeap(ROID, range, animation)
	local pet = ROIDTOPET(ROID);

	if ( not pet or (pet and pet.isPad) ) then
		return;
	end

	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	pet.actor:ClearFacing(); 

	--casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)
	local finalDestination = nil;

	-- Melee
	if ( range == PetBattleRange.Melee ) then 
		local meleePoint = frontVector * 1*battleScale;
		local meleeAttackPoint = opponentLocation + meleePoint;
		finalDestination = meleeAttackPoint;
	-- Ranged
	elseif ( range == PetBattleRange.Ranged ) then 
		local rangedPoint = frontVector * 2*battleScale;
		local rangedAttackPoint = opponentLocation + rangedPoint;
		finalDestination = rangedAttackPoint;
	-- Stationary
	elseif (range == PetBattleRange.InPlace ) then 
		pet.actor:SetFacingToAbs(opponentLocation)
	-- Do nothing
	else
		Print(\"ERROR: PerformLeap - No movement range specified!\");
	end

	if ( finalDestination ) then 
		local distance = finalDestination:Dist( pet.actor:GetPosition() );

		if ( distance > 0.02 ) then 

			PerformJump( pet, finalDestination, 0.5, animation )

		end
	else
		-- \"You didnt need to go anywhere
	end
end

"	0	0
660	"Global Constants - Animation Table 1"	"AnimTable1 =
{  
	None = -1;
	Stand = 0;
	Death = 1;
	Spell = 2;
	Stop = 3;
	Walk = 4;
	Run = 5;
	Dead = 6;
	Rise = 7;
	StandWound = 8;
	CombatWound = 9;
	CombatCritical = 10;
	ShuffleLeft = 11;
	ShuffleRight = 12;
	Walkbackwards = 13;
	Stun = 14;
	HandsClosed = 15;
	AttackUnarmed = 16;
	Attack1H = 17;
	Attack2H = 18;
	Attack2HL = 19;
	ParryUnarmed = 20;
	Parry1H = 21;
	Parry2H = 22;
	Parry2HL = 23;
	ShieldBlock = 24;
	ReadyUnarmed = 25;
	Ready1H = 26;
	Ready2H = 27;
	Ready2HL = 28;
	ReadyBow = 29;
	Dodge = 30;
	SpellPrecast = 31;
	SpellCast = 32;
	SpellCastArea = 33;
	NPCWelcome = 34;
	NPCGoodbye = 35;
	Block = 36;
	JumpStart = 37;
	Jump = 38;
	JumpEnd = 39;
	Fall = 40;
	SwimIdle = 41;
	Swim = 42;
	SwimLeft = 43;
	SwimRight = 44;
	SwimBackwards = 45;
	AttackBow = 46;
	FireBow = 47;
	ReadyRifle = 48;
	AttackRifle = 49;
	Loot = 50;
	ReadySpellDirected = 51;
	ReadySpellOmni = 52;
	SpellCastDirected = 53;
	SpellCastOmni = 54;
	BattleRoar = 55;
	ReadyAbility = 56;
	Special1H = 57;
	Special2H = 58;
	ShieldBash = 59;
	EmoteTalk = 60;
	EmoteEat = 61;
	EmoteWork = 62;
	EmoteUseStanding = 63;
	EmoteTalkExclamation = 64;
	EmoteTalkQuestion = 65;
	EmoteBow = 66;
	EmoteWave = 67;
	EmoteCheer = 68;
	EmoteDance = 69;
	EmoteLaugh = 70;
	EmoteSleep = 71;
	EmoteSitGround = 72;
	EmoteRude = 73;
	EmoteRoar = 74;
	EmoteKneel = 75;
	EmoteKiss = 76;
	EmoteCry = 77;
	EmoteChicken = 78;
	EmoteBeg = 79;
	EmoteApplaud = 80;
	EmoteShout = 81;
	EmoteFlex = 82;
	EmoteShy = 83;
	EmotePoint = 84;
	Attack1HPierce = 85;
	Attack2HLoosePierce = 86;
	AttackOff = 87;
	AttackOffPierce = 88;
	Sheath = 89;
	HipSheath = 90;
	Mount = 91;
	RunRight = 92;
	RunLeft = 93;
	MountSpecial = 94;
	Kick = 95;
	SitGroundDown = 96;
	SitGround = 97;
	SitGroundUp = 98;
	SleepDown = 99;
	Sleep = 100;
	SleepUp = 101;
	SitChairLow = 102;
	SitChairMed = 103;
	SitChairHigh = 104;
	LoadBow = 105;
	LoadRifle = 106;
	AttackThrown = 107;
	ReadyThrown = 108;
	HoldBow = 109;
	HoldRifle = 110;
	HoldThrown = 111;
	LoadThrown = 112;
	EmoteSalute = 113;
	KneelStart = 114;
	KneelLoop = 115;
	KneelEnd = 116;
	AttackUnarmedOff = 117;
	SpecialUnarmed = 118;
	StealthWalk = 119;
	StealthStand = 120;
	Knockdown = 121;
	EatingLoop = 122;
	UseStandingLoop = 123;
	ChannelCastDirected = 124;
	ChannelCastOmni = 125;
	Whirlwind = 126;
	Birth = 127;
	UseStandingStart = 128;
	UseStandingEnd = 129;
	CreatureSpecial = 130;
	Drown = 131;
	Drowned = 132;
	FishingCast = 133;
	FishingLoop = 134;
	Fly = 135;
	EmoteWorkNoSheathe = 136;
	EmoteStunNoSheathe = 137;
	EmoteUseStandingNoSheathe = 138;
	SpellSleepDown = 139;
	SpellKneelStart = 140;
	SpellKneelLoop = 141;
	SpellKneelEnd = 142;
	Sprint = 143;
	InFlight = 144;
	Spawn = 145;
	Close = 146;
	Closed = 147;
	Open = 148;
	Opened = 149;
	Destroy = 150;
	Destroyed = 151;
	Rebuild = 152;
	Custom0 = 153;
	Custom1 = 154;
	Custom2 = 155;
	Custom3 = 156;
	Despawn = 157;
	Hold = 158;
	Decay = 159;
	BowPull = 160;
	BowRelease = 161;
	ShipStart = 162;
	ShipMoving = 163;
	ShipStop = 164;
	GroupArrow = 165;
	Arrow = 166;
	CorpseArrow = 167;
	GuideArrow = 168;
	Sway = 169;
	DruidCatPounce = 170;
	DruidCatRip = 171;
	DruidCatRake = 172;
	DruidCatRavage = 173;
	DruidCatClaw = 174;
	DruidCatCower = 175;
	DruidBearSwipe = 176;
	DruidBearBite = 177;
	DruidBearMaul = 178;
	DruidBearBash = 179;
	DragonTail = 180;
	DragonStomp = 181;
	DragonSpit = 182;
	DragonSpitHover = 183;
	DragonSpitFly = 184;
	EmoteYes = 185;
	EmoteNo = 186;
	JumpLandRun = 187;
	LootHold = 188;
	LootUp = 189;
	StandHigh = 190;
	Impact = 191;
	LiftOff = 192;
	Hover = 193;
	SuccubusEntice = 194;
	EmoteTrain = 195;
	EmoteDead = 196;
	EmoteDanceOnce = 197;
	Deflect = 198;
	EmoteEatNoSheathe = 199;
	Land = 200;}
"	0	0
665	"Global Constants - Animation Table 2"	"AnimTable2 = {
	Submerge = 201;
	Submerged = 202;
	Cannibalize = 203; 
	ArrowBirth = 204;
	GroupArrowBirth = 205;
	CorpseArrowBirth = 206;
	GuideArrowBirth = 207;
	EmoteTalkNoSheathe = 208;
	EmotePointNoSheathe = 209;
	EmoteSaluteNoSheathe = 210;
	EmoteDanceSpecial = 211;
	Mutilate = 212;
	CustomSpell01 = 213;
	CustomSpell02 = 214;
	CustomSpell03 = 215;
	CustomSpell04 = 216;
	CustomSpell05 = 217;
	CustomSpell06 = 218;
	CustomSpell07 = 219;
	CustomSpell08 = 220;
	CustomSpell09 = 221;
	CustomSpell10 = 222;
	StealthRun = 223;
	Emerge = 224;
	Cower = 225;
	Grab = 226;
	GrabClosed = 227;
	GrabThrown = 228;
	FlyStand = 229;
	FlyDeath = 230;
	FlySpell = 231;
	FlyStop = 232;
	FlyWalk = 233;
	FlyRun = 234;
	FlyDead = 235;
	FlyRise = 236;
	FlyStandWound = 237;
	FlyCombatWound = 238;
	FlyCombatCritical = 239;
	FlyShuffleLeft = 240;
	FlyShuffleRight = 241;
	FlyWalkbackwards = 242;
	FlyStun = 243;
	FlyHandsClosed = 244;
	FlyAttackUnarmed = 245;
	FlyAttack1H = 246;
	FlyAttack2H = 247;
	FlyAttack2HL = 248;
	FlyParryUnarmed = 249;
	FlyParry1H = 250;
	FlyParry2H = 251;
	FlyParry2HL = 252;
	FlyShieldBlock = 253;
	FlyReadyUnarmed = 254;
	FlyReady1H = 255;
	FlyReady2H = 256;
	FlyReady2HL = 257;
	FlyReadyBow = 258;
	FlyDodge = 259;
	FlySpellPrecast = 260;
	FlySpellCast = 261;
	FlySpellCastArea = 262;
	FlyNPCWelcome = 263;
	FlyNPCGoodbye = 264;
	FlyBlock = 265;
	FlyJumpStart = 266;
	FlyJump = 267;
	FlyJumpEnd = 268;
	FlyFall = 269;
	FlySwimIdle = 270;
	FlySwim = 271;
	FlySwimLeft = 272;
	FlySwimRight = 273;
	FlySwimBackwards = 274;
	FlyAttackBow = 275;
	FlyFireBow = 276;
	FlyReadyRifle = 277;
	FlyAttackRifle = 278;
	FlyLoot = 279;
	FlyReadySpellDirected = 280;
	FlyReadySpellOmni = 281;
	FlySpellCastDirected = 282;
	FlySpellCastOmni = 283;
	FlyBattleRoar = 284;
	FlyReadyAbility = 285;
	FlySpecial1H = 286;
	FlySpecial2H = 287;
	FlyShieldBash = 288;
	FlyEmoteTalk = 289;
	FlyEmoteEat = 290;
	FlyEmoteWork = 291;
	FlyEmoteUseStanding = 292;
	FlyEmoteTalkExclamation = 293;
	FlyEmoteTalkQuestion = 294;
	FlyEmoteBow = 295;
	FlyEmoteWave = 296;
	FlyEmoteCheer = 297;
	FlyEmoteDance = 298;
	FlyEmoteLaugh = 299;
	FlyEmoteSleep = 300;
	FlyEmoteSitGround = 301;
	FlyEmoteRude = 302;
	FlyEmoteRoar = 303;
	FlyEmoteKneel = 304;
	FlyEmoteKiss = 305;
	FlyEmoteCry = 306;
	FlyEmoteChicken = 307;
	FlyEmoteBeg = 308;
	FlyEmoteApplaud = 309;
	FlyEmoteShout = 310;
	FlyEmoteFlex = 311;
	FlyEmoteShy = 312;
	FlyEmotePoint = 313;
	FlyAttack1HPierce = 314;
	FlyAttack2HLoosePierce = 315;
	FlyAttackOff = 316;
	FlyAttackOffPierce = 317;
	FlySheath = 318;
	FlyHipSheath = 319;
	FlyMount = 320;
	FlyRunRight = 321;
	FlyRunLeft = 322;
	FlyMountSpecial = 323;
	FlyKick = 324;
	FlySitGroundDown = 325;
	FlySitGround = 326;
	FlySitGroundUp = 327;
	FlySleepDown = 328;
	FlySleep = 329;
	FlySleepUp = 330;
	FlySitChairLow = 331;
	FlySitChairMed = 332;
	FlySitChairHigh = 333;
	FlyLoadBow = 334;
	FlyLoadRifle = 335;
	FlyAttackThrown = 336;
	FlyReadyThrown = 337;
	FlyHoldBow = 338;
	FlyHoldRifle = 339;
	FlyHoldThrown = 340;
	FlyLoadThrown = 341;
	FlyEmoteSalute = 342;
	FlyKneelStart = 343;
	FlyKneelLoop = 344;
	FlyKneelEnd = 345;
	FlyAttackUnarmedOff = 346;
	FlySpecialUnarmed = 347;
	FlyStealthWalk = 348;
	FlyStealthStand = 349;
	FlyKnockdown = 350;
	FlyEatingLoop = 351;
	FlyUseStandingLoop = 352;
	FlyChannelCastDirected = 353;
	FlyChannelCastOmni = 354;
	FlyWhirlwind = 355;
	FlyBirth = 356;
	FlyUseStandingStart = 357;
	FlyUseStandingEnd = 358;
	FlyCreatureSpecial = 359;
	FlyDrown = 360;
	FlyDrowned = 361;
	FlyFishingCast = 362;
	FlyFishingLoop = 363;
	FlyFly = 364;
	FlyEmoteWorkNoSheathe = 365;
	FlyEmoteStunNoSheathe = 366;
	FlyEmoteUseStandingNoSheathe = 367;
	FlySpellSleepDown = 368;
	FlySpellKneelStart = 369;
	
	
}
"	0	0
670	"Global Constants - Animation Table 3"	"AnimTable3 = {
	FlyDruidCatRip = 400;
	FlyDruidCatRake = 401;
	FlyDruidCatRavage = 402;
	FlyDruidCatClaw = 403;
	FlyDruidCatCower = 404;
	FlyDruidBearSwipe = 405;
	FlyDruidBearBite = 406;
	FlyDruidBearMaul = 407;
	FlyDruidBearBash = 408;
	FlyDragonTail = 409; 
	FlyDragonStomp = 410;
	FlyDragonSpit = 411;
	FlyDragonSpitHover = 412;
	FlyDragonSpitFly = 413; 
	FlyEmoteYes = 414;
	FlyEmoteNo = 415;
	FlyJumpLandRun = 416;
	FlyLootHold = 417;
	FlyLootUp = 418;
	FlyStandHigh = 419;
	FlyImpact = 420;
	FlyLiftOff = 421;
	FlyHover = 422;
	FlySuccubusEntice = 423;
	FlyEmoteTrain = 424;
	FlyEmoteDead = 425;
	FlyEmoteDanceOnce = 426;
	FlyDeflect = 427;
	FlyEmoteEatNoSheathe = 428;
	FlyLand = 429;
	FlySubmerge = 430;
	FlySubmerged = 431;
	FlyCannibalize = 432;
	FlyArrowBirth = 433;
	FlyGroupArrowBirth = 434;
	FlyCorpseArrowBirth = 435;
	FlyGuideArrowBirth = 436;
	FlyEmoteTalkNoSheathe = 437;
	FlyEmotePointNoSheathe = 438;
	FlyEmoteSaluteNoSheathe = 439;
	FlyEmoteDanceSpecial = 440;
	FlyMutilate = 441;
	FlyCustomSpell01 = 442;
	FlyCustomSpell02 = 443;
	FlyCustomSpell03 = 444;
	FlyCustomSpell04 = 445;
	FlyCustomSpell05 = 446;
	FlyCustomSpell06 = 447;
	FlyCustomSpell07 = 448;
	FlyCustomSpell08 = 449;
	FlyCustomSpell09 = 450;
	FlyCustomSpell10 = 451;
	FlyStealthRun = 452;
	FlyEmerge = 453;
	FlyCower = 454;
	FlyGrab = 455;
	FlyGrabClosed = 456;
	FlyGrabThrown = 457;
	ToFly = 458;
	ToHover = 459;
	ToGround = 460;
	FlyToFly = 461;
	FlyToHover = 462;
	FlyToGround = 463;
	Settle = 464;
	FlySettle = 465;
	DeathStart = 466;
	DeathLoop = 467;
	DeathEnd = 468;
	FlyDeathStart = 469;
	FlyDeathLoop = 470;
	FlyDeathEnd = 471;
	DeathEndHold = 472;
	FlyDeathEndHold = 473;
	Strangulate = 474;
	FlyStrangulate = 475;
	ReadyJoust = 476;
	LoadJoust = 477;
	HoldJoust = 478;
	FlyReadyJoust = 479;
	FlyLoadJoust = 480;
	FlyHoldJoust = 481;
	AttackJoust = 482;
	FlyAttackJoust = 483;
	ReclinedMount = 484;
	FlyReclinedMount = 485;
	ToAltered = 486;
	FromAltered = 487;
	FlyToAltered = 488;
	FlyFromAltered = 489;
	InStocks = 490;
	FlyInStocks = 491;
	VehicleGrab = 492;
	VehicleThrow = 493;
	FlyVehicleGrab = 494;
	FlyVehicleThrow = 495;
	ToAlteredPostSwap = 496;
	FromAlteredPostSwap = 497;
	FlyToAlteredPostSwap = 498;
	FlyFromAlteredPostSwap = 499;
	ReclinedMountPassenger = 500;
	FlyReclinedMountPassenger = 501;
	Carry2H = 502;
	Carried2H = 503;
	FlyCarry2H = 504;
	FlyCarried2H = 505;
	EmoteSniff = 506;
	EmoteFlySniff = 507;
	AttackFist1H = 508;
	FlyAttackFist1H = 509;
	AttackFist1HOff = 510;
	FlyAttackFist1HOff = 511;
	ParryFist1H = 512;
	FlyParryFist1H = 513;
	ReadyFist1H = 514;
	FlyReadyFist1H = 515;
	SpecialFist1H = 516;
	FlySpecialFist1H = 517;
	EmoteReadStart = 518;
	FlyEmoteReadStart = 519;
	EmoteReadLoop = 520;
	FlyEmoteReadLoop = 521;
	EmoteReadEnd = 522;
	FlyEmoteReadEnd = 523;
	SwimRun = 524;
	FlySwimRun = 525;
	SwimWalk = 526;
	FlySwimWalk = 527;
	SwimWalkBackwards = 528;
	FlySwimWalkBackwards = 529;
	SwimSprint = 530;
	FlySwimSprint = 531;
	MountSwimIdle = 532;
	FlyMountSwimIdle = 533;
	MountSwimBackwards = 534;
	FlyMountSwimBackwards = 535;
	MountSwimLeft = 536;
	FlyMountSwimLeft = 537;
	MountSwimRight = 538;
	FlyMountSwimRight = 539;
	MountSwimRun = 540;
	FlyMountSwimRun = 541;
	MountSwimSprint = 542;
	FlyMountSwimSprint = 543;
	MountSwimWalk = 544;
	FlyMountSwimWalk = 545;
	MountSwimWalkBackwards = 546;
	FlyMountSwimWalkBackwards = 547;
	MountFlightIdle = 548;
	FlyMountFlightIdle = 549;
	MountFlightBackwards = 550;
	FlyMountFlightBackwards = 551;
	MountFlightLeft = 552;
	FlyMountFlightLeft = 553;
	MountFlightRight = 554;
	FlyMountFlightRight = 555;
	MountFlightRun = 556;
	FlyMountFlightRun = 557;
	MountFlightSprint = 558;
	FlyMountFlightSprint = 559;
	MountFlightWalk = 560;
}
"	0	0
675	"Global Constants - Animation Table 4"	"AnimTable4 =
{

	FlySpellKneelLoop = 370;
	FlySpellKneelEnd = 371;
	FlySprint = 372;
	FlyInFlight = 373;
	FlySpawn = 374;
	FlyClose = 375;
	FlyClosed = 376;
	FlyOpen = 377;
	FlyOpened = 378;
	FlyDestroy = 379;
	FlyDestroyed = 380;
	FlyRebuild = 381;
	FlyCustom0 = 382;
	FlyCustom1 = 383;
	FlyCustom2 = 384;
	FlyCustom3 = 385;
	FlyDespawn = 386;
	FlyHold = 387;
	FlyDecay = 388; 
	FlyBowPull = 389;
	FlyBowRelease = 390;
	FlyShipStart = 391;
	FlyShipMoving = 392;
	FlyShipStop = 393;
	FlyGroupArrow = 394;
	FlyArrow = 395;
	FlyCorpseArrow = 396;
	FlyGuideArrow = 397;
	FlySway = 398;
	FlyDruidCatPounce = 399;
--
	BartenderEmoteTalk = 600;
	FlyBartenderEmoteTalk = 601;
	BartenderEmotePoint = 602;
	FlyBartenderEmotePoint = 603;
	BarmaidStand = 604;
	FlyBarmaidStand = 605;
	BarmaidWalk = 606;
	FlyBarmaidWalk = 607;
	BarmaidRun = 608;
	FlyBarmaidRun = 609;
	BarmaidShuffleLeft = 610;
	FlyBarmaidShuffleLeft = 611;
	BarmaidShuffleRight = 612;
	FlyBarmaidShuffleRight = 613;
	BarmaidEmoteTalk = 614;
	FlyBarmaidEmoteTalk = 615;
	BarmaidEmotePoint = 616;
	FlyBarmaidEmotePoint = 617;
	MountSelfIdle = 618;
	FlyMountSelfIdle = 619;
	MountSelfWalk = 620;
	FlyMountSelfWalk = 621;
	MountSelfRun = 622;
	FlyMountSelfRun = 623;
	MountSelfSprint = 624;
	FlyMountSelfSprint = 625;
	MountSelfRunLeft = 626;
	FlyMountSelfRunLeft = 627;
	MountSelfRunRight = 628;
	FlyMountSelfRunRight = 629;
	MountSelfShuffleLeft = 630;
	FlyMountSelfShuffleLeft = 631;
	MountSelfShuffleRight = 632;
	FlyMountSelfShuffleRight = 633;
	MountSelfWalkBackwards = 634;
	FlyMountSelfWalkBackwards = 635;
	MountSelfSpecial = 636;
	FlyMountSelfSpecial = 637;
	MountSelfJump = 638;
	FlyMountSelfJump = 639;
	MountSelfJumpStart = 640;
	FlyMountSelfJumpStart = 641;
	MountSelfJumpEnd = 642;
	FlyMountSelfJumpEnd = 643;
	MountSelfJumpLandRun = 644;
	FlyMountSelfJumpLandRun = 645;
	MountSelfStart = 646;
	FlyMountSelfStart = 647;
	MountSelfFall = 648;
	FlyMountSelfFall = 649;
	Stormstrike = 650;
	FlyStormstrike = 651;
	ReadyJoustNoSheathe = 652;
	FlyReadyJoustNoSheathe = 653;
	Slam = 654;
	FlySlam = 655;
	DeathStrike = 656;
	FlyDeathStrike = 657;
	SwimAttackUnarmed = 658;
	FlySwimAttackUnarmed = 659;
	SpinningKick = 660;
	FlySpinningKick = 661;
	RoundHouseKick = 662;
	FlyRoundHouseKick = 663;
	RollStart = 664;
	FlyRollStart = 665;
	Roll = 666;
	FlyRoll = 667;
	RollEnd = 668;
	FlyRollEnd = 669;
	PalmStrike = 670;
	FlyPalmStrike = 671;
	MonkOffenseAttackUnarmed = 672;
	FlyMonkOffenseAttackUnarmed = 673;
	MonkOffenseAttackUnarmedOff = 674;
	FlyMonkOffenseAttackUnarmedOff = 675;
	MonkOffenseParryUnarmed = 676;
	FlyMonkOffenseParryUnarmed = 677;
	MonkOffenseReadyUnarmed = 678;
	FlyMonkOffenseReadyUnarmed = 679;
	MonkOffenseSpecialUnarmed = 680;
	FlyMonkOffenseSpecialUnarmed = 681;
	MonkDefenseAttackUnarmed = 682;
	FlyMonkDefenseAttackUnarmed = 683;
	MonkDefenseAttackUnarmedOff = 684;
	FlyMonkDefenseAttackUnarmedOff = 685;
	MonkDefenseParryUnarmed = 686;
	FlyMonkDefenseParryUnarmed = 687;
	MonkDefenseReadyUnarmed = 688;
	FlyMonkDefenseReadyUnarmed = 689;
	MonkDefenseSpecialUnarmed = 690;
	FlyMonkDefenseSpecialUnarmed = 691;
	MonkHealAttackUnarmed = 692;
	FlyMonkHealAttackUnarmed = 693;
	MonkHealAttackUnarmedOff = 694;
	FlyMonkHealAttackUnarmedOff = 695;
	MonkHealParryUnarmed = 696;
	FlyMonkHealParryUnarmed = 697;
	MonkHealReadyUnarmed = 698;
	FlyMonkHealReadyUnarmed = 699;
	MonkHealSpecialUnarmed = 700;
	FlyMonkHealSpecialUnarmed = 701;
	FlyingKick = 702;
	FlyFlyingKick = 703;
	FlyingKickStart = 704;
	FlyFlyingKickStart = 705;
	FlyingKickEnd = 706;
	FlyFlyingKickEnd = 707;
	CraneStart = 708;
	FlyCraneStart = 709;
	CraneLoop = 710;
	FlyCraneLoop = 711;
	CraneEnd = 712;
	FlyCraneEnd = 713;
	Despawned = 714;
	FlyDespawned = 715;
}
"	0	0
681	"Global Constants - Animation Table 5"	"AnimTable5 =
{
	FlyMountFlightWalk = 561;
	MountFlightWalkBackwards = 562;
	FlyMountFlightWalkBackwards = 563;
	MountFlightStart = 564;
	FlyMountFlightStart = 565;
	MountSwimStart = 566;
	FlyMountSwimStart = 567;
	MountSwimLand = 568;
	FlyMountSwimLand = 569;
	MountSwimLandRun = 570;
	FlyMountSwimLandRun = 571;
	MountFlightLand = 572;
	FlyMountFlightLand = 573;
	MountFlightLandRun = 574;
	FlyMountFlightLandRun = 575;
	ReadyBlowDart = 576;
	FlyReadyBlowDart = 577;
	LoadBlowDart = 578;
	FlyLoadBlowDart = 579;
	HoldBlowDart = 580;
	FlyHoldBlowDart = 581;
	AttackBlowDart = 582;
	FlyAttackBlowDart = 583;
	CarriageMount = 584;
	FlyCarriageMount = 585;
	CarriagePassengerMount = 586;
	FlyCarriagePassengerMount = 587;
	CarriageMountAttack = 588;
	FlyCarriageMountAttack = 589;
	BartenderStand = 590;
	FlyBartenderStand = 591;
	BartenderWalk = 592;
	FlyBartenderWalk = 593;
	BartenderRun = 594;
	FlyBartenderRun = 595;
	BartenderShuffleLeft = 596;
	FlyBartenderShuffleLeft = 597;
	BartenderShuffleRight = 598;
	FlyBartenderShuffleRight = 599;
	ThousandFists = 716;
	FlyThousandFists = 717;
	MonkHealReadySpellDirected = 718;
	FlyMonkHealReadySpellDirected = 719;
	MonkHealReadySpellOmni = 720;
	FlyMonkHealReadySpellOmni = 721;
	MonkHealSpellCastDirected = 722;
	FlyMonkHealSpellCastDirected = 723;
	MonkHealSpellCastOmni = 724;
	FlyMonkHealSpellCastOmni = 725;
	MonkHealChannelCastDirected = 726;
	FlyMonkHealChannelCastDirected = 727;
	MonkHealChannelCastOmni = 728;
	FlyMonkHealChannelCastOmni = 729;
	Torpedo = 730;
	FlyTorpedo = 731;
}
"	0	0
682	"Brazie\'s PetBattle - Dispatcher - Default Result Handlers"	"
function GetDefaultHandlerTable(result, index)
	local handlerTable = {
		[PetBattleEffect.SetHealth] = {
			dontWait = false;

			func = set_health_func;
			args = { result.value };
		};
		[PetBattleEffect.AuraApply] = {
			dontWait = true;

			showSuccessOrFail = true;

			func = apply_aura_func;
			args = { result.auraInstanceID, result.auraTurnsRemaining, result.auraAbilityID };
		};
		[PetBattleEffect.AuraCancel] = {
			dontWait = true;
			func = aura_change_func;
			args = { result.auraInstanceID, result.auraTurnsRemaining, true };

		};	
		[PetBattleEffect.AuraChange] = {
			dontWait = true;
			func = aura_change_func;
			args = { result.auraInstanceID, result.auraTurnsRemaining, false };
		};	
		[PetBattleEffect.PetSwap] = {
			dontWait = false;

			func = swap_func;
			args = { result };
		};
		[PetBattleEffect.StatusChange] = {
			dontWait = false;
			func = status_change_func;
			args = { result };
		};
		[PetBattleEffect.SetState] = {
			dontWait = true;
			func = set_state_func;
			args = { result };
		};
	};

	return handlerTable;
end"	0	0
683	"Brazie\'s PetBattle - Dispatcher - Result - ChangeStatus"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function status_change(targetROID, result)
	if (not result) then
		return
	end
--
print(\"Debugging Status Change Table\");
DEBUG_TABLE(result)
--]]

	local targetPet = ROIDTOPET( targetROID );
	
	-- Save the local state
	if ( result.isTrapped ) then 
		targetPet.isTrapped = result.isTrapped;
	end
--[[
	-- check if we need to perform a special trap visual
	local player = nil
	if (effect.casterPlayerID > 0) then
		player = GetTeamByIndex(effect.casterPlayerID)
	end

	if (player) then
		if (effect.abilityVisualID == player.trapVisualID) then
			TrapCast(effect)
		end
	end
]]--
	if ( result.isTrapped ) then 
		local enemyMasterRoid = GETROIDFROMPLAYERID(3-targetPet.playerID) + ROID_TYPE_PLAYER_MASTER;
		Dispatcher_OwnerTrap( enemyMasterRoid, targetROID );
print(\"I\'m the very best.\");
		scene:WaitTimer(5);
	end
end
"	0	0
684	"Turn Package - Stampede With Clones"	"function Dispatcher_Stampede( clonesPerRow, ROID, isTurn, turn )
	--[[
	-- Global checker:
	--
	local env = {};
	setmetatable(env, { __index = getfenv(1), __newindex = function(tab, k, v) error(\"Attempt to set global \"..k); end});
	setfenv(1, env);
	]]---

	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_Stampede\");

		return;
	end

	local radius = 3; 
	local cloneSpeed = 10;
	local effectTime = 2;

	local chargeWithClones = true;

	local cols = clonesPerRow
	local rows = #turn.effects

	if ( chargeWithClones ) then 
		rows = rows - 1;
	end

	local frontSpread = radius*2 / rows; 
	local leftSpread = radius*2 / cols; 

	local objectTable = {};

	for i=1,rows do
		for j=1,cols do			
			local col = j
			local row = i;
			
			table.insert(objectTable, {
					index = (i-1)*rows+(j);
					f = -radius + row*frontSpread + math.random( -frontSpread*75,frontSpread*75 )/100, 
					l = -radius + col*leftSpread + math.random( -leftSpread*75,leftSpread*75 )/100
			});
		end
	end

	local pet = ROIDTOPET(ROID);
	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local name = \"Clone\";
	local creatureID = pet.creatureID; 
	local scale = 1;

	local createData = ActorCreateData:Default();
	createData.creatureID = creatureID;
	createData.scale = scale;
	createData.interactible = false;

	local petStartingPoint = VectorCopy(pet.actor:GetPosition());
	local centerStartingPoint = FastLocalFacingCoordinates( petStartingPoint, opponent.actor:GetPosition(), Vector:New(-8,0,0) );
	local centerEndingPoint   = FastLocalFacingCoordinates( opponent.actor:GetPosition(), petStartingPoint, Vector:New(-8,0,0) );

	local cleanUpCheck=function(remove)
		for i=#objectTable,1,-1 do 
			local v = objectTable[i]
			if ( v.actor ) then
				local remainder = v.actor:GetPosition():Dist( v.destination );
--print(v.index,\": \",remainder,\":\",v.actor:IsMoving())
				if ( remainder < 4 or not v.actor:IsMoving() ) then 
					v.actor:Despawn();
					if ( remove ) then
						table.remove(objectTable,i);
					end
				end
			elseif (remove) then

				table.remove(objectTable,i);
			end	
		end
	end

	-- Wave Stuff
	local timeSpent = 0;
	local waveDelay = effectTime/rows;
	local effectDelay = (opponent.actor:GetPosition():Dist(petStartingPoint) / cloneSpeed ) + waveDelay;
	local petDelay = 0;

	local nextWave = 0

	local waveIndex = 1;
	local effectIndex = 1;

	local delay = 0.05;

	-- Get the pet to charge
	local petStarted = false;
	local petFirstHit = false;
	local petArrived = false;
	local petTeleport = false;
	local petReturned = false;	
	local petDone = false;

	local doEffect = function(updateDelay)
		local effect = turn.effects[effectIndex];
		-- Use this to cap the number of effects rendered
		if ( effectIndex <= 99 ) then 
			-- Attempt to process the package
			local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \"effect\", effect)

			-- fallback handling
			if (processed ~= true) then
				-- Start the effect animation
				Dispatcher_AddCommandToQueue(ROID, DefaultDoEffect, effect, nil, true ); 
				-- End
			end
		else
			for index, result in pairs(effect.results) do
				StartEffectProcessing(result)
				SignalEffectProcessed()
			end
		end

		effectIndex = effectIndex + 1;

		if ( updateDelay ) then 
			effectDelay = timeSpent + waveDelay	/ 2
		end
	end

	while effectIndex <= #turn.effects do

		if ( timeSpent >= petDelay and not pet.actor:IsCasting()) then 
			if ( not petStarted ) then 
				petStarted = true;
				pet.actor:ClearFacing(); 
				pet.actor:MoveToAbs( centerEndingPoint,  petStartingPoint:Dist( centerEndingPoint ) / cloneSpeed );
				petDelay = 0.1
			elseif ( not petFirstHit ) then  
				local remainder = "	0	685
685	"[1] Turn Package - Stampede With Clones"	"pet.actor:GetPosition():Dist( opponent.actor:GetPosition() );
				if ( remainder < 1 ) then
					petFirstHit = true;
					doEffect(false);
					petDelay = timeSpent + petStartingPoint:Dist( centerEndingPoint ) / cloneSpeed;
				else
					petDelay = 0.1;
				end
			elseif ( not petArrived ) then 

				local remainder = pet.actor:GetPosition():Dist( centerEndingPoint );

				if ( remainder < 4 or not pet.actor:IsMoving() ) then 
					--pet.actor:Fade(0,0.5); 
					petArrived = true;
					petDelay = timeSpent + 0.05
				else
					petDelay = timeSpent + 0.05
				end
			elseif ( not petTeleport ) then 

				pet.actor:MoveToAbs(centerStartingPoint, 0);
				petTeleport = true;
				petDelay = timeSpent + 0.05
			elseif ( pet.actor:GetPosition():Dist( centerStartingPoint ) < 1 and not pet.actor:IsMoving() ) then 
				pet.actor:MoveToAbs(petStartingPoint,  2);				
			end
		end

		if ( timeSpent >= nextWave ) then 
			for j = 1, cols do 
				local v = objectTable[(waveIndex-1)*#turn.effects+j];

				if ( v ) then
					createData.transform = Transform:New(centerStartingPoint + Vector:New(v.f,v.l,0),0);
					local actor = scene:SpawnActor(createData);

					v.actor = actor;
					v.destination = FastLocalFacingCoordinates(opponent.actor:GetPosition(), petStartingPoint, Vector:New(-8+v.f,v.l,0) );
					v.actor:Fade(1,0.5);

					local moveTime = v.actor:GetPosition():Dist( v.destination ) / cloneSpeed;

					v.actor:MoveToAbs( v.destination, moveTime )
				end
			end

			waveIndex = waveIndex + 1;
			nextWave = timeSpent + waveDelay			
		end
	

		-- Used to filter effects
		if ( timeSpent > effectDelay ) then
			doEffect(true);
		end

		scene:WaitTimer(delay)
		timeSpent = timeSpent + delay;
		cleanUpCheck(false);
	end

	pet.actor:MoveToAbs(petStartingPoint, pet.actor:GetPosition():Dist( petStartingPoint ) / cloneSpeed);
	
	while ( #objectTable > 0 ) do
		cleanUpCheck(true);
		scene:WaitTimer(0.1)
	end

	-- Wait until the pet is home
	pet.actor:WaitMovementComplete()
	pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
	pet.actor:Fade(1,0);

	-- Reset/reposition
	Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );

end"	684	0
686	"Turn Package - Huge Knockback on Multi Hit"	"function Dispatcher_HugeKnockbackOnMultiHit( ROID, isTurn, turn )

	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_HugeKnockbackOnMultiHit\");

		return;
	end


	-- Behave normally on 1 effect
	if ( #turn.effects == 1 ) then 
		DefaultTurnBehaviour( ROID, isTurn, turn )
	else

		-- Move into position
		DefaultTurnPreEffectMovement(ROID, turn )

		local turnVisualPlayed = false;

		if ( visuals ) then 
			turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn, huge_knockback_successEffect_visual )
		end

		-- Skip the first effect
		for index=2,#turn.effects do 
			local effect = turn.effects[index];
			local effectVisualPlayed

			if ( visuals ) then  
				effectVisualPlayed = DefaultDoEffect(ROID, effect)

				if ( effectVisualPlayed ) then 
					DefaultEffectCleanUp( ROID );
				end
			else
				DefaultDoEffectProcessing( nil, \"effect\", effect ); 
			end
		end

		if ( turnVisualPlayed ) then 
			DefaultTurnCleanUp(ROID);
		end
	end



end

function huge_knockback_successEffect_visual(targetPet, casterPet, result)
	--[[
	local abilityVisualID, spellVisualID = GetVisualData(result)

	if ( not spellVisualID ) then 
		print( \"No Spell Visual ID provided to successEffect_visual\" );
		return;
	end
	]]

	--targetPet.actor:PlaySpellImpactVisual(spellVisualID)
	targetPet.actor:PlaySpellImpactVisual( 6587 ) 

	-- If its not a proc, knock!
	local team = GetTeamByIndex(casterPet.playerID)
	if ( casterPet.slot == team.activePet ) then 
		--PerformTinySlide( targetPet, casterPet ) 
		PerformKnockback( targetPet, casterPet, 3 ) 
	end
end
"	0	0
690	"Brazie\'s PetBattle - Effect - GetVisualData"	"function GetVisualData(result)
	local abilityVisualID = result.abilityVisualID
	local turnVisualID = result.turnVisualID

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return abilityVisualID, nil, turnVisualID
	end

	local spellVisualID = abilityVisual.spellVisualID

	local turnVisual = petAbilityVisuals[turnVisualID]
	if not turnVisual then
		return abilityVisualID, spellVisualID, turnVisualID
	end
	local turnVisualSpellID = turnVisual.spellVisualID;

	return abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID
end"	0	0
691	"Turn Package - Use Secondary Spell Visual on Multi Hit"	"function Dispatcher_AlternateVisualOnMultiHit( secondaryVisualID, ROID, isTurn, turn )

	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_AlternateVisualOnMultiHit\");

		return; 
	end
	-- Behave normally on 1 effect
	if ( #turn.effects == 1 ) then 
		DefaultTurnBehaviour( ROID, isTurn, turn )

	elseif ( #turn.effects > 1 ) then 
 
		-- Move into position
		DefaultTurnPreEffectMovement(ROID, turn )


		for i=2, #turn.effects do
			-- Handle 2nd effect
			local effect = turn.effects[i];

			local effectVisualPlayed = DefaultTurnOnEffectVisualHandler( ROID, turn, effect, function(...) secondary_successEffect_visual(secondaryVisualID, ...) end )

			DefaultDoEffectProcessing( nil, \"effect\", effect ); 

			if ( effectVisualPlayed ) then 
				DefaultEffectCleanUp( ROID );
			end
		end
	end

end

function secondary_successEffect_visual( secondaryVisual, targetPet, casterPet, result )

	targetPet.actor:PlaySpellImpactVisual( secondaryVisual ) 

end
"	0	0
692	"Turn Package - Run Turn For The First N Effects"	"function Dispatcher_OnlyTurnAnimateTheEffects1toN( n, ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Dispatcher_OnlyTurnAnimateTheEffects1toN\");

		return;
	end

	local visuals = true;

	-- If this is not being performed by a specific pet, skip the casting effects
	if ( not ROIDISAPET( ROID ) ) then
		visuals = false;
		userROID = nil;
	end

	-- Move into position
	DefaultTurnPreEffectMovement(ROID, turn )

	local turnVisualPlayed = false;

	if ( visuals ) then 
		--turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn)
	end

	-- Handle all effects
	for index=1,#turn.effects do 
		local effect = turn.effects[index];
		local effectVisualPlayed

		if ( index <= n and visuals ) then
			effectVisualPlayed = DefaultTurnOnEffectVisualHandler( ROID, turn, effect )
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 

			if ( effectVisualPlayed ) then 
				DefaultEffectCleanUp( ROID );
			end
		else
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
	end

	if ( turnVisualPlayed ) then 
		DefaultTurnCleanUp(ROID);
	end
end"	0	0
693	"Turn Package - IonCannon"	"function Dispatcher_IonCannon( ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to DefaultDoEffect\");

		return;
	end

--Print(\"ION CANNON!\");

	local n = #turn.effects;

	local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])
	local turnVisual = petAbilityVisuals[turnVisualID]
	if ( turnVisual ) then 
		-- Get me in position
		Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); 
	end
	
	local casterCastingPet = ROIDTOPET( ROID );
	local playerID = turn.firstEvent.target.playerID
	local slot = turn.firstEvent.target.petSlot
	local target = ROIDTOPET( GETROIDFROMPLAYERIDANDSLOT( playerID, slot ) )


	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(25866)
	scene:WaitTimer(1)
	casterCastingPet.actor:ClearSpellPreCastVisual(25866, preCastInstance)
	casterCastingPet.actor:PlaySpellCastVisual(25866)

	local newPosition = casterCastingPet.actor:GetPosition()+Vector:New(8,0,0.5)
	local transform = Transform:New( newPosition, (casterCastingPet.actor:GetTransform()).yaw, -90, (casterCastingPet.actor:GetTransform()).roll );
	local create = ActorCreateData:NewModel(
		\"Moonfire\",
		\"SPELLS\\MOONFIRE_IMPACT_BASE.m2\",
		transform,
		0.5);
	create.groundSnap = false;
	local newActor = scene:SpawnActor(create);
	--newActor:SetFacingToAbs(target.actor:GetPosition())

	--newActor:SetTransform

	scene:WaitTimer(0.5)


	local overrides = {
		[PetBattleEffect.SetHealth] = {
			successEffect = ion_cannon_knockback_successEffect_visual;
		};
	};

	for index, effect in pairs(turn.effects) do
		if ( index <= n ) then 
			-- Attempt to process the package
			local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \"effect\", effect, overrides, true)

			-- fallback handling
			if (processed ~= true) then
				-- Start the effect animation
				Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, overrides, true ); 
				-- End
			end
		else
			for index, result in pairs(effect.results) do
				StartEffectProcessing(result)
				SignalEffectProcessed()
			end
		end
	end

	scene:WaitTimer(0.5)
	newActor:Despawn();

	-- Reset/reposition
	Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );

end

function ion_cannon_knockback_successEffect_visual(targetPet, casterPet, result)
	--[[
	local abilityVisualID, spellVisualID = GetVisualData(result)

	if ( not spellVisualID ) then 
		print( \"No Spell Visual ID provided to successEffect_visual\" );
		return;
	end
	]]

	--targetPet.actor:PlaySpellImpactVisual(spellVisualID)
	targetPet.actor:PlaySpellImpactVisual( 6587 ) 

	-- If its not a proc, knock!
	local team = GetTeamByIndex(casterPet.playerID)
	if ( casterPet.slot == team.activePet ) then 
		--PerformTinySlide( targetPet, casterPet ) 
		PerformKnockback( targetPet, casterPet, 5 ) 
	end
end
"	0	0
694	"Turn Package - Banana Barrage"	"function Dispatcher_BananaBarrage( model, ROID, isTurn, turn )
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \",type(isTurn),\" passed to DefaultDoEffect\");

		return;
	end
--print(\"banana\");	
	-- NOTE TO SELF:
	-- Upgrade this to drop bananas on each unit getting hit by the effect

	local userROID = TurnToUserROID(turn);


	-- Who\'s getting hit
	local pet = ROIDTOPET(ROID);
	local targetROID = ResultToTargetROID(turn.effects[1].results[2])
	local target = ROIDTOPET( targetROID )

	-- Bananas! 
	local bananaWaves = 6;
	local bananaRows  = 3;
	local bananaCols  = 3;
	local bananaFallSpeed = 9.8 / 3; -- M / s
	local bananaSpinRate = 180; -- deg / sec

	local bananaRadius = 1;
	local frontSpread = bananaRadius * 2 / bananaRows; 
	local leftSpread = bananaRadius * 2 / bananaCols;
	local upSpread = 1;

	local objectTable = {};

	for w=1,bananaWaves do
		for r=1,bananaRows do
			for c=1,bananaCols do
				local index = c + (r-1)*bananaRows + (w-1)*bananaRows*bananaWaves;
				local f = -bananaRadius 	+ r*frontSpread + math.random( -frontSpread*75,frontSpread*75 )/100;
				local l = -bananaRadius 	+ c*leftSpread + math.random( -leftSpread*75,leftSpread*75 )/100;
				local u = 0 				+ math.random( -upSpread*75,upSpread*75 )/100;

				local pitch = math.random(0,360);
--print(f,\":\",l,\":\",u)
				table.insert(objectTable, {	index=index, f=f, l=l, u=u, pitch=pitch } ); 
			end
		end
	end
	
	-- Important
	local effectDuration = 2;
	local timeSpent = 0;
	local waveIndex = 1;
	
	local delay = 0.05;
	local waveDelay = effectDuration / bananaWaves;
	local effectDelay = waveDelay;
	local nextWaveDelay = 0;
	local nextEffectDelay = waveDelay * bananaWaves / 2;


	-- Change this variable to not show all effects
	local maxEffects = #turn.effects
	local effectIndex = 1;

	-- Handle an effect
	local doEffect = function(updateDelay)
		local effect = turn.effects[effectIndex];
		-- Use this to cap the number of effects rendered
		if ( effectIndex <= maxEffects ) then 
			-- Attempt to process the package
			local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \"effect\", effect)

			-- fallback handling
			if (processed ~= true) then
				-- Start the effect animation
				Dispatcher_AddCommandToQueue(ROID, DefaultDoEffect, effect, nil, true ); 
				-- End
			end
		else
			for index, result in pairs(effect.results) do
				StartEffectProcessing(result)
				SignalEffectProcessed()
			end
		end

		effectIndex = effectIndex + 1;

		if ( updateDelay ) then 
			nextEffectDelay = timeSpent + effectDelay
		end
	end


	-- Create Banana Wave Actors
	local centerStartingPoint = VectorCopy(target.actor:GetPosition());
	local bananaCreateData = ActorCreateData:Default()
	bananaCreateData.model = model or \"WORLD\\EXPANSION04\\DOODADS\\PANDAREN\\SHRINE_PROPS\\PA_banana_01.M2\";
	bananaCreateData.groundSnap = false;
	bananaCreateData.interactible = false;
	bananaCreateData.name = \"Banana\";

	local spawnBananaWave = function ()
		for r=1,bananaRows do
			for c=1,bananaCols do 
				local v = objectTable[ (waveIndex-1) * bananaWaves * bananaRows + (r-1) * bananaRows + c];

				if ( v ) then
					bananaCreateData.transform = Transform:New(centerStartingPoint + Vector:New(v.f,v.l,v.u+4),0);
					local actor = scene:SpawnActor(bananaCreateData);

					v.actor = actor;
					v.destination = centerStartingPoint + Vector:New(v.f,v.l,v.u-4);
					v.actor:Fade(1,0.5);

					local moveTime = v.actor:GetPosition():Dist( v.destination ) / bananaFallSpeed;

					v.actor:MoveToAbs( v.destination, moveTime )
				end
			end
		end

		waveIndex = waveIndex + 1;
		nextWaveDelay = timeSpent + waveDelay	
	end

	-- Spin da banana
	local spinBananaWave = function ()
		for k,v in pairs(objectTable) "	0	695
695	"[1] Turn Package - Banana Barrage"	"do 
			if ( v.actor ) then 
				local transform = v.actor:GetTransform();
				local pitch = v.pitch;
				pitch = pitch + bananaSpinRate * delay;

				transform.roll = pitch;
				v.pitch = pitch;
				v.actor:SetTransform(transform);
--print(pitch);
			end
		end
	end

	-- Despawns unneeded actors
	local cleanUpCheck=function(remove)
		for i=#objectTable,1,-1 do 
			local v = objectTable[i]
			if ( v.actor ) then
				local remainder = v.actor:GetPosition():Dist( v.destination );
				if ( remainder < 1 or not v.actor:IsMoving() ) then 
					v.actor:Despawn();
					if ( remove ) then
						table.remove(objectTable,i);
					end
				end
			elseif (remove) then
				table.remove(objectTable,i);
			end	
		end
	end

--[[
	-- Standard move into range
	local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])
	local turnVisual = petAbilityVisuals[turnVisualID]
	if ( turnVisual ) then 
		-- Get me in position
		Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); 
	end
]]

	-- Loop over the effects and draw the visuals
	while effectIndex <= #turn.effects do
		if ( timeSpent > nextWaveDelay ) then 
			spawnBananaWave();
		end

		spinBananaWave();

		if ( timeSpent > nextEffectDelay ) then 
			doEffect(true);
		end

		scene:WaitTimer(delay)
		timeSpent = timeSpent + delay;
		cleanUpCheck(false);
	end

	-- Reset/reposition
	Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );

end"	694	0
697	"----- Event Handling -----"	"

--
--
-- "	0	0
698	"Brazie\'s PetBattle - ROIDs - GetROIDs"	"function TurnToUserROID(turn)
	local userPlayerID = turn.playerID
	local userSlot = turn.petSlot

	local userROID = GETROIDFROMPLAYERIDANDSLOT( userPlayerID, userSlot )

	return userROID;
end

function EffectToROIDs(effect)

	local targets = {}
	
	for index,result in pairs(effect.results) do 
		local roid = ResultToTargetROID(result)
		
		if ( roid ) then
			targets[index] = roid;
		end
	end

	return targets;
end

function ResultToTargetROID(result)
	if ( result.targetPlayerID ) then 
		local targetPlayerID, targetSlot = result.targetPlayerID, result.targetPetSlot

		local roid = GETROIDFROMPLAYERIDANDSLOT( targetPlayerID, targetSlot );

		return roid;
	elseif ( result.swapPlayerID ) then 
		local targetPlayerID, targetSlot = result.swapPlayerID, result.newFrontPet

		local roid = GETROIDFROMPLAYERIDANDSLOT( targetPlayerID, targetSlot );

		return roid;
	else
print(\"ResultToTargetROID Error\");
print(result);
	end

	return nil;
end"	0	0
699	"Brazie\'s PetBattle - Result Event Filtering (V1)"	"
-- Used for the Brazie Event Filtering System
function FilterResultEventsByType(event)
	local filteredEvent = FilteredEventMetaTable({});
	
	local eventType = event.eventType
	local effectType = event.effectType

	-- What kind of result
	filteredEvent.eventType = event.eventType;
	filteredEvent.resultType = event.effectType;
	filteredEvent.instanceID = event.instanceID;

	-- ImplicitAbilityID
	filteredEvent.resultVisualID = event.abilityVisualID
	filteredEvent.effectVisualID = nil; -- Fill this in someday

	-- Procs
	filteredEvent.procGroup = event.procGroup;

	-- Targetting
	if ( event.target ) then 
		filteredEvent.targetPlayerID = event.target.playerID;
		filteredEvent.targetPetSlot = event.target.petSlot;
	end

	-- Failure reasons
	if ( event.failureReason and event.failureReason > 0 ) then
		filteredEvent.failureReason =  event.failureReason;
	end

	if ( event.flags ) then
-- DEBUG_TABLE(event.flags);
		filteredEvent.miss = event.flags.miss;
		filteredEvent.crit = event.flags.crit;
		filteredEvent.blocked = event.flags.blocked;
	end

	-- battle round effects
	if ( effectType == PetBattleEffect.SetHealth)  then

		filteredEvent.newHealth = event.target.newHealth;

	elseif (
		effectType == PetBattleEffect.AuraApply or
		effectType == PetBattleEffect.AuraChange or
		effectType == PetBattleEffect.AuraCancel ) then

		filteredEvent.auraVisualID = event.target.auraVisualID
		filteredEvent.auraInstanceID = event.target.auraInstanceID
		filteredEvent.auraTurnsRemaining = event.target.turnsRemaining

	elseif ( effectType == PetBattleEffect.PetSwap ) then

		filteredEvent.swapPlayerID = event.casterPlayerID;
		filteredEvent.oldFrontPet = event.casterPetSlot;

		filteredEvent.newFrontPet = event.newFrontPet;

	elseif ( effectType == PetBattleEffect.SetState ) then

		filteredEvent.stateID = event.target.stateID
		filteredEvent.stateValue = event.target.stateValue;

	elseif ( effectType == PetBattleEffect.StatusChange ) then
		filteredEvent.isTrapped = event.target.isTrapped;
		filteredEvent.isStunned = event.target.isStunned;
		filteredEvent.isSwapLocked = event.target.isSwapLocked;

	elseif ( effectType == PetBattleEffect.SetMaxHealth ) then 

		filteredEvent.value = event.target.value;

	elseif ( effectType == PetBattleEffect.SetSpeed ) then 

		filteredEvent.value = event.target.value;

	elseif ( effectType == PetBattleEffect.SetPower ) then 

		filteredEvent.value = event.target.value;

	end

	return filteredEvent;
end

function FilteredEventMetaTable(newTable)

	setmetatable(newTable, { __tostring = FilteredEventMetaTablePrinter })
	
	return newTable;
end
function FilteredEventMetaTablePrinter (tableRef, depth) 
	local output = \"{\n\";
	local indent = depth or 1;
	local indentText = \"\";

	-- Safety valve
	if ( indent > 100 ) then
		return \"Depth Error\";
	end

	for i=1,indent do 
		indentText = indentText..\"  \";
	end

	for key,val in pairs( tableRef ) do 
		local text = tostring(val);
		if ( key == \"resultType\" ) then 
			for name,id in pairs( PetBattleEffect ) do 
				if ( val == id ) then 
					text = name;
				end
			end

		elseif ( key  == \"playerID\" or key  == \"targetPlayerID\" or key  == \"swapPlayerID\" ) then 
			text = tostring(val);
			for name,id in pairs( PetBattlePlayerID ) do 
				if ( val == id ) then 
					text = name;
				end
			end

		elseif (key  == \"petSlot\" or key  == \"targetPetSlot\" or key == \"oldFrontPet\" or key == \"newFrontPet\" ) then 
			text = tostring(val);

			for name,id in pairs( PetBattlePetID ) do 
				if ( val == id ) then 
					text = name;
				end
			end			

		elseif (key  == \"stateID\" ) then 
			text = tostring(val);
			for name,id in pairs( STATE_LOOKUP ) do 
				if ( val == id ) then 
					text = name;
				end
			end			

		elseif ( type(val) == \"table\" ) "	0	701
701	"[1] Brazie\'s PetBattle - Result Event Filtering (V1)"	"then 
			text = FilteredEventMetaTablePrinter(tableRef, indent + 1);
		else
			text = tostring(val);
		end
		output = output..indentText..\"K: \"..key..\" V: \"..text..\"\n\";
	end

	output = output..\"}\n\";

	return output
end


	--
	-- Effect Types:
	--
	-- 

	-- EventTypes
	--
	-- This list is primarily for my own edification
	--
	-- PetBattleEvent.BattleOver
	--	params:
	--		event.winnerID - ID of the winner
	--
	-- PetBattleEvent.BattleResults
	--  params:
	--		event.rewards {
	--				playerID
	--				petSlot 
	--				wasCaptured
	--				newLevel
	--				newXP
	--			}
	--
	--	PetBattleEvent.ObserverChange
	--   param:
	--		- none -
	--
	--	PetBattleEvent.MoveAbilitySelected
	--	 params:
	--		event.abilityVisualID
	--
	--	PetBattleEvent.MovePetSwapSelected
	-- 	 params:
	--		event.newFrontPet
	--  
	-- PetBattleEvent.MoveTrapSelected
	-- 	 params:
	--		event.abilityVisualID - the trap ability visual id
	-- 
	-- PetBattleEvent.RoundEffect
	-- 	 params:
	-- 		- MANY -
	-- 
	-- PetBattleEvent.RoundStart
	--	 params:
	--		roundNumber - the round starting
	--
	-- PetBattleEvent.RoundComplete
	-- 	 params:
	-- 		roundNumber - the round ending
	--		stateChange - the battle state
"	699	0
702	"Brazie\'s PetBattle - Dispatcher - Perform Visual Stuff"	"function Dispatcher_DefaultSuccessVisual( victimROID, attackerROID, visualID )
	if ( not attackerROID ) then 
		print(\"ERROR: No Attacker ROID provided to Default Failure.\");
		return;
	end
PARALLEL_MODE = true;
	Dispatcher_AddCommandToQueue(victimROID, Dispatcher_PerformResultImpactVisual, visualID ); 	 
	Dispatcher_AddCommandToQueue(victimROID, Dispatcher_PerformImpactKnockback, attackerROID ); 	 
PARALLEL_MODE = false

end

function Dispatcher_DefaultFailureVisual( victimROID, attackerROID, visualID, failType )
	if ( not attackerROID ) then 
		print(\"ERROR: No Attacker ROID provided to Default Failure.\");
		return;
	end

PARALLEL_MODE = true;

	if ( failType == \"block\" ) then 
print(\"block\");
		Dispatcher_AddCommandToQueue( victimROID, Dispatcher_PerformDodge, attackerROID );
	elseif ( failType == \"miss\" ) then
		Dispatcher_AddCommandToQueue( victimROID, Dispatcher_PerformDodge, attackerROID );
	end
PARALLEL_MODE = false;
end


--
-- Performs the effect visual for each target
--
function Dispatcher_PerformMultiTargetVisual( userROID, targetROIDs,  visualID )
	local user = ROIDTOPET( userROID );

	local targets = {};

--print(\"CastVisual: \", ROIDTOSTRING(userROID),\" ? \",visualID );
	for i=1,#targets do 
		local targetROID = targetROIDs[i];
		local targetPet = ROIDTOPET( targetROID );
--print(\"CastVisual@: \", ROIDTOSTRING(targetROID) );

		if ( targetPet and targetROID ~= userROID ) then 
			table.insert( targets, targetPet );
		else
			print (\"ERROR: Invalid target pet: \",ROIDTOSTRING(targetROID) );
		end 
	end

	if ( not user ) then 
		print (\"ERROR: Invalid pet. \",ROIDTOSTRING(userROID) );
		return;
	end

	PerformSpellVisualManyTargets( user, visualID, targets )

end 

-- Performs an impact visual whenever
--

function Dispatcher_PerformResultImpactVisual(targetROID,  abilityVisualID )

	if ( not abilityVisualID ) then 
		print( \"No Spell Visual ID provided to Dispatcher_PerformResultImpactVisual\" );
		return;
	end
--print( \"ImpactVisual: \",ROIDTOSTRING(targetROID),\" \",visualID );


	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end
	local spellVisualID = abilityVisual.spellVisualID


	local targetPet = ROIDTOPET(targetROID);
	targetPet.actor:PlaySpellImpactVisual(spellVisualID)
end

-- Performs a bump when requested
--
function Dispatcher_PerformImpactKnockback( victimROID, attackerROID )
	local victim = ROIDTOPET( victimROID );
	local attacker = ROIDTOPET( attackerROID );

	-- If its not a proc, knock!
	local victimTeam = ROIDTOPLAYER(victimROID)
	local attackerTeam = ROIDTOPLAYER(attackerROID)

	if ( not attackerTeam ) then
		print( \"Error: missing team. \"..ROIDTOSTRING(attackerROID) );
	end
	if ( not victim ) then 
		print (\"Error: ImpactKnockback missing victim: \", ROIDTOSTRING(victimROID) );
		return;
	end
	if ( not attacker ) then 
		print (\"Error: ImpactKnockback missing attacker: \", ROIDTOSTRING(attackerROID) );
		return;
	end

	if ( attackerTeam and attacker.slot == attackerTeam.activePet ) then 
		PerformTinySlide( victim, attacker ) 
		--PerformHardKnockback( targetPet, casterPet ) 
	else
		DebugPrint(\"WARNING: Couldn\'t slide, attacker was not the team\'s active pet!! :\", attacker.slot,\" : \", attackerTeam.activePet);
	end
end

-- Performs a dodge when requested
--
function Dispatcher_PerformDodge( victimROID, attackerROID )
	local victim = ROIDTOPET( victimROID );
	local attacker = ROIDTOPET( attackerROID );

	if ( not victim ) then 
		print (\"Error: PerformDodge missing victim: \", ROIDTOSTRING(victimROID) );
		return;
	end
	if ( not attacker ) then 
		print (\"Error: PerformDodge missing attacker: \", ROIDTOSTRING(attackerROID) );
		return;
	end

	PerformDodge( victim, attacker ) 
end"	0	0
703	"Brazie\'s PetBattle - Dispatcher - Pet Owner Trap"	"function Dispatcher_OwnerTrap( ROID, targetROID, success, turn )
	local player = ROIDTOPLAYER( ROID )
	local targetPet = ROIDTOPET( targetROID );

	if (player and player.playerDisplay) then

		local trapVisual = GetAuraAbilityVisual(player.trapAbilityID)
		local trapSpellVisualID = nil
		if (trapVisual) then
			trapSpellVisualID = trapVisual.spellVisualID
		end		

		if (not trapSpellVisualID) or (trapSpellVisualID == 0) then
			--print(\"NO TRAP VISUAL! \",trapSpellVisualID);
			return
		end
		
		--player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, emote)
		
		-- Play a trap visual
		player.trapPrecastID = player.playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID)

		scene:WaitTimer(trapVisual.castTime)

		player.playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)

		-- 
		if (targetPet) then

			castInstanceID = player.playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})

			scene:WaitTimer(trapVisual.impactTime-.75)

			for index=1,#turn.effects do 
				local effect = turn.effects[index];			
				DefaultEffectVisualHandler(ROID, effect, turnVisualID)
				DefaultDoEffectProcessing( nil, \"effect\", effect ); 
			end

			local waitCondition = function()
				return not player.playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)
			end
			scene:WaitCondition(waitCondition)

			if (success) then
				--print(\"Succesful Trap\")
				targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)

				Dispatcher_OwnerEmote( ROID, Animations.EmoteCheer )

				scene:WaitTimer(5);
			else
				print(\"Failed Trap\")
			end
		end
	end
end"	0	0
704	"Brazie\'s PetBattle - Core - Handle Turn"	"-- This replaces the default behaviour with mine
ProcessRoundTurnGroup = Dispatcher_HandleTurn;

function Dispatcher_HandleTurn(turn)
	-- Turn Package? Hand-off

	local userROID = TurnToUserROID(turn);

	-- Attempt to process the package
	local processed = Dispatcher_HandleSpellVisualPackage(userROID, turn.turnVisualID, \"turn\", turn)

	-- Baseline
	if ( not processed ) then 
		Dispatcher_DefaultTurnBehaviour(userROID, turn )
	end
end  

function Dispatcher_HandleSpellVisualPackage( ROID, turnVisualID, ...)

	-- use a custom script handler if we have one
	local turnVisual = nil
	if (turnVisualID) then
		turnVisual = petAbilityVisuals[turnVisualID]
	end
	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		Dispatcher_AddCommandToQueue( ROID, turnVisual.scriptFunction, ...)
		processed = true;
	end

	return processed
end
"	0	0
705	"Brazie\'s PetBattle - Core - Default Effect Behaviour"	"function DefaultDoEffect(ROID, effect)
	-- Attempt to process the package
	local processed = Dispatcher_HandleSpellVisualPackage( ROID, effect.effectVisualID, \"effect\", effect )

	-- fallback handling
	if (processed ~= true) then
		local targets = EffectToROIDs ( effect );

		local effectVisualID = effect.effectVisualID;

		-- Start the effect animation
		if ( effectVisualID ) then 
			DefaultEffectVisualHandler( ROID, effect, effect.effectVisualID);
		end

		DefaultDoEffectProcessing( userROID, \"effect\", effect ); 

		-- End
		if ( effectVisualID ) then 
			return true;
		end
	end
end


function DefaultEffectCleanUp(ROID)
	local userPet = ROIDTOPET( ROID );
	userPet.actor:WaitCastingComplete();
	scene:WaitTimer(0.25);
end"	0	0
706	"[1] Brazie\'s PetBattle - Core - Default Turn Behaviour"	"
		local failType = nil;

		if ( result.miss ) then 
			failType = \"miss\";
		elseif ( result.block ) then
			failType = \"block\";
		end

		if ( not failType ) then 
			local success = overrideSuccess or Dispatcher_DefaultSuccessVisual;
			success ( targetROID, ROID, turnVisualID )
		else
			local failure = overrideFailure or Dispatcher_DefaultFailureVisual;
			failure( targetROID, ROID, turnVisualID, failType )
		end

		return true;
	else
		print(\"WARNING: NO turn visual provided to DefaultTurnOnEffectVisualHandler.\");
	end

	return false;
end"	640	0
707	"Undead - Death and Decay"	"function Control_DeathAndDecay(ROID, isAura, aura, auraInstanceID, turnsRemaining)

	local pad = ROIDTOPET(ROID);

	local fillModel = \"Spells\\DeathAndDecay.m2\";
	local groundModel = \"spells\\deathanddecay_area_runes_state.m2\";

	print(\"Rune!!\");

	local centerPosition = pad.actor:GetPosition()+Vector:New(0,0,0)

	CreateBlizzardEffect( 
			groundModel, 
			fillModel, 
			centerPosition,
			2,  -- width
			2,  -- depth
			6   -- fill rate
			) 

end"	0	0
708	"Brazie\'s PetBattle - Dispatcher - Thread Bot 3"	"local myROID;
local myList=nil;

while( not BOT_KILL_SWITCH ) do
	for k,v in pairs(UNIT_ACTION_QUEUE) do
		if ( v.isProcessing == false and #v.commands > 0 ) then 
			myROID = k;
			myList = v;
			break;
		end
	end

	if ( myROID ) then 
--print( \"Bot 3 Acquired Task for \", ROIDTOSTRING(myROID) );
		UNIT_ACTION_QUEUE[myROID].isProcessing = true;
		
		while myList.commands[1] ~= nil do
			local task = myList.commands[1];
--print(\"Mine: \",ROIDTOSTRING(myROID));
--print(\"Other: \",ROIDTOSTRING(task.args[1]));
--DEBUG_TABLE(task.args);
			local result = task.func(myROID, unpack(task.args));

			--print(\"Bot1 Result: \",result)

			table.remove(myList.commands,1);
		end
	
		UNIT_ACTION_QUEUE[myROID].isProcessing = false;
		myROID = nil;
		myList = nil;

--print( \"Bot 3 Released Task\" );

	end

	scene:WaitTimer(0)
end"	0	0
709	"Resuable Scripts - Blizzard Effect"	"function CreateBlizzardEffect( 
			baseModel, 
			fillModel, 
			centerLocation,
			width,
			depth, 
			fillRate
			) 

	local newPosition = centerLocation
	local transform = Transform:New( newPosition, 0, 0, 0 )  --(pad.actor:GetTransform()).yaw, -90, (casterCastingPet.actor:GetTransform()).roll );

	
	local centerCreateData = ActorCreateData:NewModel(
		\"Rain\",
		baseModel,
		transform,
		0.25); -- scale
	centerCreateData.groundSnap = true;
	centerCreateData.interactible = false;

	local groundActor = scene:SpawnActor(centerCreateData);
	local kit = groundActor:PlayLoopingAnimKit(petBattleAnimKits.StandHoldDecay);

	local radiusX = width/2*10
	local radiusY = depth/2*10

	local max = 3;
	local q = 1
	while (q < max) do
		q = q + 1;
print(\"Drawing rain...\");
		local objects = {};
		for i = 1, fillRate do 
			local t = Transform:New( centerLocation+Vector:New( math.random(-radiusX,radiusX)/10, math.random(-radiusY,radiusY)/10, 0) );
			local fill = ActorCreateData:NewModel(
				\"Rain\",
				fillModel,
				t,
				0.1); -- scale
			fill.groundSnap = true;
			fill.interactible = false;
			local newRain = scene:SpawnActor(fill);

			table.insert(objects, newRain);
			scene:WaitTimer(0.25);
		end

		scene:WaitTimer(3);

		for k,v in pairs(objects) do 
			v:Despawn();
		end
	end

	kit:Stop();
	groundActor:Despawn();

end"	0	0
710	"PetBattle(fallback) - Constants"	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
playerRadius   = 5.0
idleRadius     = 2.0
readyRadius    = 1.25
rangedRadius   = 0.5
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.25

--------------------------------------------------------------------------------
-- pad
padModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
padAlpha = 1.0
padScale = 1.0

--------------------------------------------------------------------------------
-- arena
arenaRingModel = \"SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"
arenaRingAlpha = 0.0
arenaRingScale = 1.0
arenaFadeTime = 5.0

--------------------------------------------------------------------------------
-- camera
freelookZoomMin = 5
freelookZoomMax = 12
freelookZoomStart = 9.0
useFreelookCamera = true

battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand = 2267;
	Death = 2268;
	Dead  = 2269;
}
"	0	0
711	"PetBattle(fallback) - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate, crit)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	local isCritical = false
	if (crit == true) then
		isCritical = true
	end

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) then
			pet.actor:AddDamageText(nil, -change, isCritical, false)
		elseif (change > 0) then
			pet.actor:AddHealingText(nil, change, isCritical, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged "	0	712
712	"[1] PetBattle(fallback) - Functions"	"then
		attackRadius = rangedRadius
	end
	return attackRadius
end

"	711	0
713	"PetBattle(fallback) - Init Player"	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	padCreateData.interactible = false
	local padActor = nil
	if (PetBattleScene.SpawnPet) then
		padActor = battleScene:SpawnPet(playerID, PetBattlePetID.Pad, padCreateData)
	else
		padActor = scene:SpawnActor(padCreateData)
	end

	padActor:Fade(padAlpha, 0)

	-- spawn NPC character
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)
		local npcCreateData = ActorCreateData:Default()
		npcCreateData.creatureID = team.npcCreatureID
		npcCreateData.creatureDisplayID = team.npcDisplayID
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)
		npcCreateData.interactible = false
		team.npcActor = scene:SpawnActor(npcCreateData)
		team.playerDisplay = team.npcActor
	end

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }
		pet.playerID = playerID
		team.pets[id] = pet

		if (id == PetBattlePetID.Pad) then
			pet.isPad = true
			pet.actor = padActor
			team.pad = pet
		else			
			pet.isPad = false
			local radius = backlineRadius
			local offset = 0
			if id == team.activePet then
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
					radius = backlineRadius
				else
					radius = idleRadius
				end
			else
				offset = backLineOffset
				backLineOffset = backLineOffset + backlineSpacing
			end
			
			local pos = BuildVector(team.teamFacing, -radius, offset)
			local transform = Transform:New(pos, team.teamFacing)
			
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
			petCreateData.creatureDisplayID = petDesc.displayID or 0

			if (PetBattleScene.SpawnPet) then
				pet.actor = battleScene:SpawnPet(playerID, id, petCreateData)
			else
				pet.actor = scene:SpawnActor(petCreateData)
			end

			SetXP(pet, petDesc.xp, petDesc.level, true)
			SetHealth(pet, petDesc.health, true)

			pet.status = petDesc.status

			pet.currentRadius = radius
			pet.currentOffset = offset

			-- always face the opponent location (at idleRadius)
			LookAtOpposingTeam(pet)

			-- hide all pets until loaded
			pet.actor:SetInteractible(false)
			pet.actor:SetHidden(true)
			pet.actor:Fade(0, 0)
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
		end

		-- apply initial auras
		for auraIndex, auraData in pairs(petDesc.auras or { }) do
			local auraVisual = GetAuraAbilityVisual(auraData.abilityID)
			if (auraVisual) then
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
			end
		end
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, "	0	714
714	"[1] PetBattle(fallback) - Init Player"	"pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetHidden(false)

					local targetAlpha = backlineAlpha
					if slot == player.activePet then
						-- use the front alpha if it is the active pet
						targetAlpha = GetAlpha(pet)
					end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	713	0
715	"PetBattle(fallback) - Effect Cast"	"
--------------------------------------------------------------------------------
function GetRelevantEffectPets(effect)
	if (not effect) then
		return
	end

	-- if the effect source was from an aura, look up the owning pet and use that
	local sourceAuraOwnerPet = GetAuraOwnerPet(effect.sourceAuraInstanceID)

	local casterPlayer = GetTeamByIndex(effect.casterPlayerID)
	local casterPet = casterPlayer.pets[effect.casterPetSlot]
	
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - effect.casterPlayerID)

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	-- the source off the effect is the owner of the aura, otherwise fall back to the casting pet
	local effectSourcePet = casterPet
	if (sourceAuraOwnerPet) then
		effectSourcePet = sourceAuraOwnerPet
	end

	return effectSourcePet, casterPet, casterFrontPet, opponentFrontPet, targetPet
end

--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)

	local effectSourcePet = nil
	local casterPet = nil
	local casterFrontPet = nil
	local opponentFrontPet = nil
	local targetPet = nil
	effectSourcePet, casterPet, casterFrontPet, opponentFrontPet, targetPet = GetRelevantEffectPets(effect)
	if (not effectSourcePet) then
		return
	end

	--
	-- Get the pets in their rightful places
	--
	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, readyRadius)
	end

	local abilityVisual = GetAbilityVisual(abilityVisualID)
	if not abilityVisual then
		return effectSourcePet
	end

	local attackRadius = GetAttackRadius(abilityVisual.range)
	
	-- move front pet to the correct radius, if it was the caster
	if (effectSourcePet) and (not effectSourcePet.deathAnimKit) then
		local sourcePlayer = GetTeamByIndex(effectSourcePet.playerID)
		if (sourcePlayer.activePet == effectSourcePet.slot) then
			WaitMoveToRadius(effectSourcePet, attackRadius)
		end
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = effectSourcePet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	effectSourcePet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (effectSourcePet.actor ~= targetPet.actor) then
		effectSourcePet.actor:PlaySpellCastVisualAtTargets(
			spellVisualID,
			abilityVisual.impactTime,
			true,
			{targetPet.actor})
	else
		-- self targeted
		effectSourcePet.actor:PlaySpellCastVisual(spellVisualID)
	end

	-- wait for impact
	if (effectSourcePet.actor:HasPendingMissiles(0) == true) then
		effectSourcePet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return effectSourcePet, spellVisualID
end
"	0	0
716	"PetBattle(fallback) - Effect Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(effect)

--	ResetActivePets()

	if (effect.flags and ((effect.flags.miss == true) or (effect.flags.invalidTarget == true))) then
		return; --	Miss text?
	end

	local teamID = effect.targetPlayerID;
	local petIndex  = effect.targetPetSlot;

	--print(\"TeamID\"..teamID)

	local team = GetTeamByIndex(teamID)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player point
	if (team.playerDisplay) then
		team.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		lastPet.actor:Fade(0, backlineFadeTime)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forward then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
717	"PetBattle(fallback) - Effect Set Health"	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for SetHealth\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local playersWithDeaths = { }
	local playersWithKills = { }

	local isCritical = false
	if (effect.flags and effect.flags.crit) then
		isCritical = true
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.flags and effect.flags.miss == true) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)	
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		local oldHealth = targetPet.currentHealth
		local newHealth = effect.value	-- actual health change is stored in the value field

		SetHealth(targetPet, newHealth, false, isCritical)

		if (newHealth <= 0) and (oldHealth > 0) then
			playersWithDeaths[targetPet.playerID] = true
			if (effectSourcePet) then
				playersWithKills[effectSourcePet.playerID] = true
			end
		end
	end

	-- feedback on players that lost pets
	for playerID, hasDeath in pairs(playersWithDeaths) do
		if (hasDeath) then
			playersWithKills[playerID] = nil
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)
			end
		end
	end

	-- feedback on players that killed pets
	for playerID, hasKill in pairs(playersWithKills) do
		if (hasKill) then
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)
			end
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) and (effectSourceActor) then
		effectSourceActor:WaitCastingComplete(true)
	end
end
"	0	0
718	"PetBattle(fallback) - Effect Aura Apply"	"
-- store a mapping of all active auras to the pet they\'re on
local activeAuraPets = { }

--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	local auraSpellVisualID = 0
	local auraVisual = GetAuraAbilityVisual(effect.auraAbilityID)
	if (auraVisual) then
		auraSpellVisualID = auraVisual.spellVisualID
	end

	local casterCastingPet
	local spellVisualID
	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no auraVisual for aura\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		-- apply an aura, tracked by instance ID
		ApplyAura(targetPet, effect.auraInstanceID, effect.auraTurnsRemaining, auraSpellVisualID)
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		effectSourceActor:WaitCastingComplete(true)
	end
end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	activeAuraPets[auraInstanceID] = pet

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	if (aura.spellVisualID) then
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	else
		aura.spellVisualInstanceID = nil
	end
	aura.turnsRemaining = turnsRemaining
end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil
	activeAuraPets[auraInstanceID] = nil
end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end

--------------------------------------------------------------------------------
function "	0	742
719	"PetBattle(fallback) - Effect Aura Change"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	local petPlayerID = effect.targetPlayerID
	local petSlot = effect.targetPetSlot

	local player = GetTeamByIndex(petPlayerID)
	local pet = player.pets[petSlot]

	if not petSlot then
		return
	end

	local auraInstanceID = effect.auraInstanceID
	local aura = pet.auras[auraInstanceID]
	if not aura then
		print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
		return
	end

	if (cancel == true) or (effect.auraTurnsRemaining < 1) then
		RemoveAura(pet, auraInstanceID)
	else
		aura.turnsRemaining = effect.auraTurnsRemaining
	end

end
"	0	0
720	"PetBattle(fallback) - Effect Status Change"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (target and target.status) then
		targetPet.status = target.status
	end

	-- check if we need to perform a special trap visual
	local player = nil
	if (effect.casterPlayerID > 0) then
		player = GetTeamByIndex(effect.casterPlayerID)
	end

	if (player and player.trapPrecastID) then
		TrapCast(effect)
	end
end
"	0	0
721	"PetBattle(fallback) - EffectSet State"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
local debugStates = false
function EffectSetState(effect)
	if (not effect) then
		return
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (target and target.stateID and target.value) then
		if (debugStates == true) then
			print(\"STATE CHANGE: Player \" .. target.playerID .. \", Pet \" .. target.petSlot .. \" - \" .. \"State \" .. target.stateID .. \" = \" .. target.value )
		end
	end
end
"	0	0
722	"PetBattle(fallback) - Effect Processing"	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false

function ProcessAllRoundResults(allEffects)

	if (debugOn == true) then
		print(\"== Round Result Grouping ==\")
	end

	-- group on (turnInstanceID, effectID, stackDepth)

	-- build an effect tree, taking into account procs
	local turnGroups = { }
	local effectGroups = { }
	
	-- top level turns that we will process
	local topLevelTurnGroups = { }
	
	-- generate groups, and a  mapping from effectIndex
	local lastEffect = nil
	for effectIndex, effect in pairs(allEffects) do
		local turnKey
		local effectKey
		turnKey, effectKey = GenerateUniqueGroupKeys(effect)

		-- find or build a turn group as necessary
		local turnGroup = turnGroups[turnKey]
		if (not turnGroup) then
			turnGroup =
			{
				key = turnKey;
				firstEffect = effect;
				effects = { };
			}
			turnGroups[turnKey] = turnGroup
			
			if (effect.stackDepth <= 1) or (not lastEffect) then
				if (not table) then
					topLevelTurnGroups[#topLevelTurnGroups + 1] = turnGroup
				else
					table.insert(topLevelTurnGroups, turnGroup)
				end
			else
				-- this is a proc off of the last effect, and should be attached as a child
				lastEffect.procGroup = turnGroup
			end

			if (debugOn == true) then
				print(\"+ New Turn Group, turnID = \" .. effect.turnInstanceID .. \", depth = \" .. effect.stackDepth)
			end
		end
		
		-- find or build an effect group as necessary
		local effectGroup = effectGroups[effectKey]
		if (not effectGroup) then
			effectGroup =
			{
				key = efffectKey;
				firstEffect = effect;
				results = { };
			}
			effectGroups[effectKey] = effectGroup
			
			-- this is a new effect group, link it to the end of our parent turn group
			if (not table) then
				turnGroup.effects[#turnGroup.effects + 1] = effectGroup
			else
				table.insert(turnGroup.effects, effectGroup)
			end

			if (debugOn == true) then
				print(\"+   New Effect Group, effectID = \" .. effect.effectID)
			end
		end
		
		-- add this effect to the end of the group list
		if (not table) then
			effectGroup.results[#effectGroup.results + 1] = effect
		else
			table.insert(effectGroup.results, effect)
		end

		if (debugOn == true) then
			print(\"+     New Result, instanceID = \" .. effect.instanceID)
		end
		
		lastEffect = effect
	end

	if (debugOn == true) then
		print(\"  \")
		print(\"== Start Round Playback ==\")
	end
	
	-- process top level turns in order
	for index, turnGroup in pairs(topLevelTurnGroups) do
		ProcessRoundTurnGroup(turnGroup)
	end

	if (debugOn == true) then
		print(\"== End Round Playback ==\")
		print(\"  \")
	end

end

--------------------------------------------------------------------------------
function ProcessRoundTurnGroup(turnGroup)
	if (debugOn == true) then
		print(\"- Processing Turn \" .. turnGroup.firstEffect.turnInstanceID)
	end

	-- use a custom script handler if we have one
	local abilityEffect = GetAbilityEffect(turnGroup.firstEffect.effectID)
	local abilityTurn = nil
	if (abilityEffect) then
		abilityTurn = GetAbilityTurn(abilityEffect.turnID)
	end

	local turnVisual = nil
	if (abilityTurn) then
		turnVisual = GetAbilityVisual(abilityTurn.visualID)
	end

	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		if ( turnVisual.scriptFunction( turnGroup ) ) then
			processed = true
		end
	end

	-- fallback processing
	if (processed ~= true) then
		for index, effectGroup in pairs(turnGroup.effects) do
			ProcessRoundEffectGroup(effectGroup)
		end
	end
end

--------------------------------------------------------------------------------
function ProcessRoundEffectGroup(effectGroup)
	if (debugOn == true) then
		print(\"-   Processing Effect \" .. "	0	723
723	"[1] PetBattle(fallback) - Effect Processing"	"effectGroup.firstEffect.effectID)
	end

	-- use a custom script handler if we have one
	local abilityEffect = GetAbilityEffect(effectGroup.firstEffect.effectID)
	local effectVisual = nil
	if (abilityEffect) then
		effectVisual = GetAbilityVisual(abilityEffect.visualID)
	end

	local processed = false
	if (effectVisual and effectVisual.scriptFunction) then
		if ( effectVisual.scriptFunction( effectGroup ) ) then
			processed = true
		end
	end

	-- fallback handling
	if (processed ~= true) then
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Process an individula Round Effect Result
function ProcessRoundResult(event)

	if (debugOn == true) then
		print(\"-     Processing Result \" .. event.instanceID)
	end

	local eventType = event.eventType
	local effectType = event.effectType

	if not (eventType == PetBattleEvent.RoundResult) then
		return
	end

	-- battle round effects
	if (effectType == PetBattleEffect.SetHealth) then
		EffectSetHealth(event)
	elseif (effectType == PetBattleEffect.AuraApply) then
		EffectAuraApply(event)
	elseif (effectType == PetBattleEffect.AuraCancel) then
		EffectAuraChange(event, true)
	elseif (effectType == PetBattleEffect.AuraChange) then
		EffectAuraChange(event, false)
	elseif (effectType == PetBattleEffect.PetSwap) then
		EffectSwap(event)
	elseif (effectType == PetBattleEffect.StatusChange) then
		EffectStatusChange(event)
	elseif (effectType == PetBattleEffect.SetState) then
		EffectSetState(event)
	end

end

--------------------------------------------------------------------------------
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn

--------------------------------------------------------------------------------
function GenerateUniqueGroupKeys(effect)	
	local stackDepth = effect.stackDepth or 0
	local turnInstanceID = effect.turnInstanceID or 0
	local effectID = effect.effectID or 0
	if (stackDepth > maxStackDepth) then
		print (\"WARNING: stack depth exceeded \" .. maxStackDepth)
	end
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then
		print (\"WARNING: max turn instanceIDs exceeded \" .. maxTurnInstanceIDs)
	end
	
	local turnKey = turnInstanceID*maxStackDepth + stackDepth
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey
	return turnKey, effectKey
end

"	722	0
724	"PetBattle(fallback) - Event Reward"	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = GetTeamByIndex(reward.playerID)
			local playerPet = player.pets[reward.petSlot]
			if (playerPet) then
				local rewardedPet =
				{
					pet = playerPet;
					newXP = reward.newXP;
					newLevel = reward.newLevel;
				}
				rewardedPets[rewardIndex] = rewardedPet

				-- resurrect and move this pet up
				if (playerPet.deathAnimKit) then
					playerPet.deathAnimKit:Stop()
					playerPet.deathAnimKit = nil		
				end

				playerPet.actor:Fade(1.0, backlineFadeTime)
				MoveToRadius(playerPet, idleRadius, playerPet.currentOffset)
			end
		end
	end

	-- wait until all pets have stopped moving
	local waitCondition = function()
		-- all actors must be renderable
		for prewardIndex,rewardedPet in pairs(rewardedPets) do
			if rewardedPet.pet.actor:IsMoving() then
				return false
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

	-- apply the rewards
	for rewardIndex,rewardedPet in pairs(rewardedPets) do
		SetXP(rewardedPet.pet, rewardedPet.newXP, rewardedPet.newLevel, false)
	end
end
"	0	0
725	"PetBattle(fallback) - Event Move Ability Selected"	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityID)

	local player = nil
	local pet = nil
	if (observingPlayerIndex > 0) then
		player = GetTeamByIndex(observingPlayerIndex)
		if (player) then
			pet = player.pets[player.activePet]
		end
	end

	if (not pet) then
		return
	end

	local radius = readyRadius
	WaitMoveToRadius(pet, radius)

end
"	0	0
726	"PetBattle(fallback) - Event Move Pet Swap Selected"	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\"Move Selected: Pet Swap Slot: \" .. petSlot)

end"	0	0
727	"PetBattle(fallback) - Event Move Trap Selected"	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected(trapAbilityID)

	-- print(\"Move Selected: Trap\")
	StartTrapPrecast(observingPlayerIndex)

end

function GetTrapVisuals(playerID)

	local player = nil
	local playerDisplay = nil
	if (playerID and (playerID > 0)) then
		player = GetTeamByIndex(playerID)
		if (player) then
			playerDisplay = player.playerDisplay
		end
	end
	
	if (not playerDisplay) then
		return
	end

	local trapVisual = GetAuraAbilityVisual(player.trapAbilityID)
	local trapSpellVisualID = nil
	if (trapVisual) then
		trapSpellVisualID = trapVisual.spellVisualID
	end

	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then
		return
	end

	return player, playerDisplay, trapVisual, trapSpellVisualID
end

function StartTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (playerDisplay) then
		if (not player.trapPrecastID) then
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID)
		end
	end

end

function ClearTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (player.trapPrecastID) then
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)
		player.trapPrecastID = nil
	end

end

function TrapCast(effect)

	local playerID = effect.casterPlayerID

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)

	if (not player) then
		return
	end

--	print(\"Casting Trap...\")

	StartTrapPrecast(playerID)
	scene:WaitTimer(trapVisual.castTime)
	ClearTrapPrecast()


	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (targetPet) then
		local trapSuccess = false
		if (targetPet.status) then
			trapSuccess = targetPet.status.isTrapped
		end

		castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})
		scene:WaitTimer(trapVisual.impactTime)

		local waitCondition = function()
			return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)
		end
		scene:WaitCondition(waitCondition)

		if (trapSuccess) then
			--print(\"Succesful Trap\")
			targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)
		else
			print(\"Failed Trap\")
		end
	end

end
"	0	0
728	"PetBattle(fallback) - Event Processing"	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.value)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.targetPetSlot)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected(event.value)
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\"WARNING: processing round result outside of RoundStart/End\")
		ProcessRoundResult(event)
	elseif (eventType == PetBattleEvent.RoundStart) then

		-- pull off all round effects
		local allEffects = { }
		local effectNum = 0
		local done = false
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do
			event = battleScene:GetPendingEffect()
			eventType = event.eventType
			if (eventType == PetBattleEvent.RoundComplete) then
				done = true
			else
				effectNum = effectNum + 1
				allEffects[effectNum] = event
			end
		end
		
		-- if we have at least one effect or we\'re done, make sure
		-- process the round start then batch process effects
		-- NOTE: the event we are left with will be RoundComplete
		if (done == true or #allEffects > 0) then
			SignalEffectProcessed()
			ProcessAllRoundResults(allEffects)

			-- switch to the next pendign event
			StartEffectProcessing(event)
		end
	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (eventType == PetBattleEvent.RoundComplete) then
		for playerID, player in pairs(teams) do
			ClearTrapPrecast(playerID)
		end
		ResetActivePets()
	end

	return true
end

function StartEffectProcessing(event)
	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID
end

function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(effects)
  local customFunc = function(effects)
    return %s
  end
  customFunc(effects)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString
	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\"ERROR: loading script on BattlePetVisual ID=\" .. abilityVisual.ID .. \" failed: \" .. createString)
			print(\"ERROR: \" .. result)
		end
	end

end"	0	729
729	"[1] PetBattle(fallback) - Event Processing"	"

"	728	0
730	"PetBattle(fallback) - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \"arenaCameraBunny\"
	cameraBunnyCreate.model = padModel
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()
	cameraBunnyCreate.transform.facing = player.teamFacing
	cameraBunnyCreate.interactible = false

	cameraBunny = scene:SpawnActor(cameraBunnyCreate)
	cameraBunny:SetFacingToAbs(BuildVector(player.teamFacing, playerRadius, 0.0))
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)
	
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)
end

function StopCameraBunny(transitionTime)
	if ( not cameraBunny ) or ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	-- return to the player
	local player = teams[observingPlayerIndex]
	scene:ResetGameCameraZoom()

	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)
	scene:WaitTimer(transitionTime)
	scene:SetGameCameraTarget(nil, 0.0, 0.0)
end

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 2.0, observedTeam.pad.actor, otherTeam.pad.actor)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
731	"PetBattle(fallback) - Intro"	"
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(1.5)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(1.6)
		scene:SetCamera(0, 0.75, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end

	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
732	"PetBattle(fallback) - Arena"	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \"arenaRing\"
arenaCreateData.model = arenaRingModel
arenaCreateData.scale = arenaRingScale
arenaCreateData.interactible = false
arenaRing = scene:SpawnActor(arenaCreateData)
arenaRing:Fade(0, 0)
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)

scene:WaitTimer(0.25)
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)
"	0	0
733	"PetBattle(fallback) - Placeholder Players"	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \"placeHolder\" .. playerID
					createData.interactible = false
					createData.floatingTooltip = false

					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)
					local transform = Transform:New(pos, player.teamFacing)
					createData.transform = transform

					placeHolderActor = scene:SpawnActor(createData)
					placeHolderActors[playerID] = placeHolderActor
				end

				-- keep using the placeholder
				player.playerDisplay = placeHolderActor
			else
				-- done with this placeholder, despawn it
				local placeHolderActor = placeHolderActors[playerID]
				if (placeHolderActor) then
					placeHolderActor:Despawn()
				end

				placeHolderActors[playerID] = nil
			end
		end
	end
end

placeHolderActors = nil
"	0	0
734	"PetBattle(fallback) - Main"	"
--------------------------------------------------------------------------------
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

InitStaticData(initialBattleState)

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[0].teamFacing = 0
initialBattleState.players[1].teamFacing = 0
initialBattleState.players[2].teamFacing = 180

teams = { }
teams[0] = initialBattleState.players[0]
teams[1] = initialBattleState.players[1]
teams[2] = initialBattleState.players[2]

if (teams[1]) then
	teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
end
if (teams[2]) then
	teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
end

if (teams[2].isNPC == true) and (#teams[2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(0, teams[0])
InitTeam(1, teams[1])
InitTeam(2, teams[2])

-- wait for teams to load
local battleMusicIDs = { 28753, 28754, 28755 }
battleScene:PlayPetBattleMusic(battleMusicIDs[math.random(#battleMusicIDs)])

if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		if (useFreelookCamera) then
			StartCameraBunny(0)
		else
			SetCamera(3)
		end
	end
	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local finalEvent = nil
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle = ProcessEvent(event)
	if (not inBattle) then
		finalEvent = event
	end
end

local winnerID = finalEvent.winnerID
if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
			-- move backline up to celebrate
			pet.actor:Fade(1.0, backlineFadeTime)
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end
SignalEffectProcessed()

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.25)
	else
		SetCamera(4)
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0
735	"PetBattle(fallback) - Ability Data"	"
local petAbilities = { }
local petAbilityTurns = { }
local petAbilityEffects = { }
local petAbilityEffectTypes = { }
local petAbilityVisuals = { }

local debugStaticData = false
local debugEffectVisualSearch = false

function InitStaticData(initialBattleState)
	if (debugStaticData) then
		print(\"Init Static Data\")
	end

	for index,ability in pairs(initialBattleState.abilityDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY \" .. ability.ID)
		end
		petAbilities[ability.ID] = ability
	end

	for index,abilityTurn in pairs(initialBattleState.abilityTurnDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY TURN \" .. abilityTurn.ID)
		end
		petAbilityTurns[abilityTurn.ID] = abilityTurn
	end

	for index,abilityEffect in pairs(initialBattleState.abilityEffectDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT \" .. abilityEffect.ID)
		end
		petAbilityEffects[abilityEffect.ID] = abilityEffect
	end

	for index,abilityEffectType in pairs(initialBattleState.abilityEffectTypeDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT TYPE \" .. abilityEffectType.ID)
		end
		petAbilityEffectTypes[abilityEffectType.ID] = abilityEffectType
	end

	for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY VISUAL \" .. abilityVisual.ID)
		end

		petAbilityVisuals[abilityVisual.ID] = abilityVisual

		-- add any custom script function
		LoadCustomVisualScript(abilityVisual)
	end

end

function GetAbility(abilityID)
	if (abilityID) then
		return petAbilities[abilityID]
	end
end

function GetAbilityTurn(abilityTurnID)
	if (abilityTurnID) then
		return petAbilityTurns[abilityTurnID]
	end
end

function GetAbilityEffect(abilityEffectID)
	if (abilityEffectID) then
		return petAbilityEffects[abilityEffectID]
	end
end

function GetAbilityEffectType(abilityEffectTypeID)
	if (abilityEffectTypeID) then
		return petAbilityEffectTypes[abilityEffectTypeID]
	end
end

function GetAbilityVisual(abilityVisualID)
	if (abilityVisualID) then
		return petAbilityVisuals[abilityVisualID]
	end
end

function GetAllAbilityVisualsFromEffectID(effectID)
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil

	local abilityEffect = GetAbilityEffect(effectID)
	if (abilityEffect) then
		effectVisual = GetAbilityVisual(abilityEffect.visualID)

		-- check parents: turn and then ability
		local abilityTurn = GetAbilityTurn(abilityEffect.turnID)
		if (abilityTurn) then
			turnVisual = GetAbilityVisual(abilityTurn.visualID)

			local ability = GetAbility(abilityTurn.abilityID)
			if (ability) then
				abilityVisual = GetAbilityVisual(ability.visualID)		
			end			
		end

		-- check fallback: effect properties
		local effectType = GetAbilityEffectType(abilityEffect.effectType)
		if (effectType) then
			effectTypeVisual = GetAbilityVisual(effectType.visualID)
		end
	end

	return effectVisual, turnVisual, abilityVisual, effectTypeVisual
end

function GetAbilityVisualFromEffectID(effectID)
	-- Priority rules for picking visuals for an EFFECT:
	--   1. Effect Visual
	--   2. Turn Visual (if not scripted)
	--   3. Ability Visual (if not scripted)
	--   4. Effect Type Visual
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil
	effectVisual, turnVisual, abilityVisual, effectTypeVisual = GetAllAbilityVisualsFromEffectID(effectID)

	if (effectVisual) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT Visual ID \" .. effectVisual.ID)
		end
		return effectVisual
	end

	if (turnVisual and turnVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" "	0	736
736	"[1] PetBattle(fallback) - Ability Data"	"Visual: Using TURN Visual ID \" .. turnVisual.ID)
		end
		return turnVisual
	end

	if (abilityVisual and abilityVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using ABILITY Visual ID \" .. abilityVisual.ID)
		end
		return abilityVisual
	end

	if (debugEffectVisualSearch) then
		if (effectTypeVisual) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT TYPE visual ID \" .. effectTypeVisual.ID)
		else
			print(\"Effect \" .. effectID .. \" Visual: NONE FOUND\")
		end
	end

	return effectTypeVisual
end

function GetAuraAbilityVisualID(auraAbilityID)
	-- in the absence of any other info, search down to the first turn
	local visualID = nil
	local ability = petAbilities[auraAbilityID]
	if (not ability) then
		return visualID
	end

	if (ability.visualID and ability.visualID ~= 0) then
		visualID = ability.visualID
	end

	if (#ability.turnIDs < 1) then
		return visualID
	end

	local abilityTurn = petAbilityTurns[ability.turnIDs[1]]
	if (not abilityTurn) then
		return visualID
	end

	if (abilityTurn.visualID and abilityTurn.visualID ~= 0) then
		visualID = abilityTurn.visualID
	end

	return visualID
end

function GetAuraAbilityVisual(auraAbilityID)
	local abilityVisualID = GetAuraAbilityVisualID(auraAbilityID)
	if (not abilityVisualID) then
		return nil
	end

	return petAbilityVisuals[abilityVisualID]
end
"	735	0
737	"Flying - Cocoon Strike"	"local scaleCreateData = ActorCreateData:Default()
scaleCreateData.name = \"scaleAxis\"
scaleCreateData.model = \"SPELLS\\AxisTestObject.m2\"
scaleCreateData.scale = 1.0
scaleCreateData.interactible = false
scaleCreateData.groundSnap = false;

function Dispatcher_CocoonStrike( model, ROID, isTurn, turn )
-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to DefaultDoEffect\");

		return;
	end
--print(\"ROID: \"..ROID..\" User ROID: \"..userROID);
--print(\"Turn: \",turn.playerID,\" : \",turn.petSlot,\" ? \",turn.firstEvent );

	local visuals = true;

	-- If this is not being performed by a specific pet, skip the casting effects
	if ( not ROIDISAPET( ROID ) ) then
		visuals = false;
		userROID = nil;
	end

	-- Move into position
	--DefaultTurnPreEffectMovement(ROID, turn )


	-- MY MOVEMENT START
	local pet = ROIDTOPET(ROID);
	if ( not pet or (pet and pet.isPad) ) then
		return;
	end

	local turnVisualID = turn.turnVisualID ;

	-- Remove this part later.
	if ( turnVisualID == 0 ) then turnVisualID = turn.firstEvent.resultVisualID; end

	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	pet.actor:ClearFacing(); 

	local finalPoint = frontVector * -2*battleScale;
	local finalAttackPoint = opponentLocation + finalPoint;

	local points = {}

	-- First calculate the bezier

	local dist = opponentLocation:Dist( pet.actor:GetPosition() );
	local heightFloor = opponent.actor:GetPosition().z - pet.actor:GetPosition().z;

	-- Start
	local coreSpline = {
		[1] = {
			basePoint = Vector:New(0,0,0);
		};
		[2] = {
			basePoint = Vector:New(dist, 0, heightFloor+0);
		};
		[3] = {
			leftArm   = Vector:New(dist*1.8,   0, heightFloor+0.1);
			basePoint = Vector:New(dist*1.8,   0, heightFloor+0.5);
			rightArm  = Vector:New(dist*1.8,   0, heightFloor+3);
		};
		[4] = {
			leftArm   = Vector:New(dist*0.7, 0, heightFloor+5);
			basePoint = Vector:New(dist*0.5, 0, heightFloor+5);
			rightArm  = Vector:New(dist*0.0, 0, heightFloor+5);
		};
		[5] = {
			leftArm   = Vector:New(dist*0, 0, heightFloor+2);
			basePoint = Vector:New(0,0,0);
		};
	}
	

	local relativeSpline = Brazie_SplineBuilder(coreSpline, \"x\", \"z\");
	local realSpline = {};

	for i=1, #relativeSpline  do 
		local relativeNode = relativeSpline[i];
		local newNode = FastLocalFacingCoordinates ( pet.actor:GetPosition(), opponent.actor:GetPosition(), relativeNode )
		
		table.insert( realSpline, newNode );
	end

	local visKit = pet.actor:PlaySpellStateVisual(6)

	pet.actor:SetSnapToGround(false)
	pet.actor:MoveSplineAbs(realSpline, 2 )

	local showDmg = true;
	local dist = pet.actor:GetPosition():Dist( opponent.actor:GetPosition() );

	while( dist > 1 and pet.actor:IsMoving() ) do
		dist = pet.actor:GetPosition():Dist( opponent.actor:GetPosition() );

		if ( dist < 2 and showDmg ) then 
			showDmg = false;
			-- Handle all effects
			local effect = turn.effects[1];
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
			DefaultEffectVisualHandler(ROID, effect, turnVisualID)
		end

		scene:WaitTimer(0.0001);
	end
	pet.actor:WaitMovementComplete()
	pet.actor:SetSnapToGround(false)

	scene:WaitTimer(0.2);
	pet.actor:ClearSpellStateVisual( 6, visKit)

	-- MY MOVEMENT END

	local turnVisualPlayed = false;

	if ( visuals ) then 
		--turnVisualPlayed = DefaultTurnVisualHandler(ROID, turn)
	end

	if ( not showDmg ) then 
		-- Handle all effects
		for index=1,#turn.effects do 
			local effect = "	0	772
738	"PetBattle - Bezier Curve Generation"	"local scaleCreateData = ActorCreateData:Default()
scaleCreateData.name = \"scaleAxis\"
scaleCreateData.model = \"SPELLS\\AxisTestObject.m2\"
scaleCreateData.scale = 1.0
scaleCreateData.interactible = false
scaleCreateData.groundSnap = false;


function Brazie_SplineBuilder( splineData, indexA, indexB ) 
	local finalSpline = {};

	for i=1,#splineData do
		local node = splineData[i];
		local nextNode = splineData[i+1];

		-- If there are spline arms specified, build a bSpline
		if ( nextNode and (node.rightArm and nextNode.leftArm ) ) then 
--print(\"SEGMENT: \"..i.. \" handled as bSpline\");
			local bezierInput = {};

			table.insert(bezierInput, node.basePoint);
--[[
		scaleCreateData.transform = Transform:New( node.basePoint, 45 )
		scaleCreateData.scale = 2;
		actor = scene:SpawnActor( scaleCreateData )
--]]
			table.insert(bezierInput, node.rightArm);
			table.insert(bezierInput, nextNode.leftArm);
			table.insert(bezierInput, nextNode.basePoint);


			local output = Build_Bezier( bezierInput, 10 )

			for j=1,#output do 
				local newPoint = output[j];

				if ( #finalSpline > 0 and newPoint:Dist(finalSpline[#finalSpline]) < 0.01 ) then
				else
					table.insert(finalSpline, newPoint );
				end
			end
		-- Otherwise insert splines in a line
		else
			table.insert(finalSpline, node.basePoint);
		end
	end

	return finalSpline;
end

function Bezier_GetFactorial(n)
	if ( n < 0) then 
		print (\"ERROR: Factorial < 0 requested in Bezier Curve Calculation\")
		return 1;
	elseif ( n > 32 ) then 
		print (\"ERROR: Factorial > 32 requested. Not supported.\");
		return 1;
	end

	return FACTORIAL_TABLE[n];
end

function Build_Bezier( arrayOfPoints, numPointsRequested )
	local bezier = {};

	local npts = #arrayOfPoints/2;
	local iCount, jCount;
	local step, t;

	-- Calculate the points on the curve

	iCount = 0;
	t = 0;
	step = 1 / (numPointsRequested-1);

	for i1 = 1, numPointsRequested do 
		if ( (1-t) < 0.00000005 ) then 
			t = 1;
		end

		local u = 1 - t;
		local tt = t * t;
		local uu = u * u;
		local uuu = uu * u;
		local ttt = tt * t;		

		local newPoint = arrayOfPoints[1] * uuu;
		newPoint = newPoint + ( arrayOfPoints[2] * t * uu * 3 );
		newPoint = newPoint + ( arrayOfPoints[3] * u * tt * 3 );
		newPoint = newPoint + ( arrayOfPoints[4] * ttt );

		table.insert(bezier, newPoint);
		
		t = t + step;
	end

	return bezier
end
"	0	0
742	"[1] PetBattle(fallback) - Effect Aura Apply"	"GetAuraOwnerPet(auraInstanceID)
	if (auraInstanceID) then
		return activeAuraPets[auraInstanceID]
	end
end

"	718	0
744	"PetBattle(3.0) - Constants"	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------
-- pet ranges and move speeds
playerRadius   = 5.0
idleRadius     = 2.0
readyRadius    = 1.25
rangedRadius   = 0.5
meleeRadius    = -0.5
backlineRadius = 4.0
forwardSpeed   = 7
backwardSpeed  = 8

--------------------------------------------------------------------------------
-- backline
backlineSpacing = 2.0
backlineAlpha   = 1.0
backlineFadeTime = 0.25

--------------------------------------------------------------------------------
-- pad
padModel = \"CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"
padAlpha = 1.0
padScale = 1.0

--------------------------------------------------------------------------------
-- arena
arenaRingModel = \"SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"
arenaRingAlpha = 0.5
arenaRingScale = 1.0
arenaFadeTime = 5.0

--------------------------------------------------------------------------------
-- camera
freelookZoomMin = 5
freelookZoomMax = 12
freelookZoomStart = 9.0
useFreelookCamera = true

battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

--------------------------------------------------------------------------------
-- animation
petBattleAnimKits =
{
	Stand = 2267;
	Death = 2268;
	Dead  = 2269;
}
"	0	0
745	"PetBattle(3.0) - Functions"	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate, crit)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	local isCritical = false
	if (crit == true) then
		isCritical = true
	end

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) then
			pet.actor:AddDamageText(nil, -change, isCritical, false)
		elseif (change > 0) then
			pet.actor:AddHealingText(nil, change, isCritical, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged "	0	746
746	"[1] PetBattle(3.0) - Functions"	"then
		attackRadius = rangedRadius
	end
	return attackRadius
end

"	745	0
747	"PetBattle(3.0) - Ability Data"	"
local petAbilities = { }
local petAbilityTurns = { }
local petAbilityEffects = { }
local petAbilityEffectTypes = { }
local petAbilityVisuals = { }

local debugStaticData = false
local debugEffectVisualSearch = true

function InitStaticData(initialBattleState)
	if (debugStaticData) then
		print(\"Init Static Data\")
	end

	for index,ability in pairs(initialBattleState.abilityDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY \" .. ability.ID)
		end
		petAbilities[ability.ID] = ability
	end

	for index,abilityTurn in pairs(initialBattleState.abilityTurnDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY TURN \" .. abilityTurn.ID)
		end
		petAbilityTurns[abilityTurn.ID] = abilityTurn
	end

	for index,abilityEffect in pairs(initialBattleState.abilityEffectDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT \" .. abilityEffect.ID)
		end
		petAbilityEffects[abilityEffect.ID] = abilityEffect
	end

	for index,abilityEffectType in pairs(initialBattleState.abilityEffectTypeDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT TYPE \" .. abilityEffectType.ID)
		end
		petAbilityEffectTypes[abilityEffectType.ID] = abilityEffectType
	end

	for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY VISUAL \" .. abilityVisual.ID)
		end

		petAbilityVisuals[abilityVisual.ID] = abilityVisual

		-- add any custom script function
		LoadCustomVisualScript(abilityVisual)
	end

end

function GetAbility(abilityID)
	if (abilityID) then
		return petAbilities[abilityID]
	end
end

function GetAbilityTurn(abilityTurnID)
	if (abilityTurnID) then
		return petAbilityTurns[abilityTurnID]
	end
end

function GetAbilityEffect(abilityEffectID)
	if (abilityEffectID) then
		return petAbilityEffects[abilityEffectID]
	end
end

function GetAbilityEffectType(abilityEffectTypeID)
	if (abilityEffectTypeID) then
		return petAbilityEffectTypes[abilityEffectTypeID]
	end
end

function GetAbilityVisual(abilityVisualID)
	if (abilityVisualID) then
		return petAbilityVisuals[abilityVisualID]
	end
end

function GetAllAbilityVisualsFromEffectID(effectID)
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil

	local abilityEffect = GetAbilityEffect(effectID)
	if (abilityEffect) then
		effectVisual = GetAbilityVisual(abilityEffect.visualID)

		-- check parents: turn and then ability
		local abilityTurn = GetAbilityTurn(abilityEffect.turnID)
		if (abilityTurn) then
			turnVisual = GetAbilityVisual(abilityTurn.visualID)

			local ability = GetAbility(abilityTurn.abilityID)
			if (ability) then
				abilityVisual = GetAbilityVisual(ability.visualID)		
			end			
		end

		-- check fallback: effect properties
		local effectType = GetAbilityEffectType(abilityEffect.effectType)
		if (effectType) then
			effectTypeVisual = GetAbilityVisual(effectType.visualID)
		end
	end

	return effectVisual, turnVisual, abilityVisual, effectTypeVisual
end

function GetAbilityVisualFromEffectID(effectID)
	-- Priority rules for picking visuals for an EFFECT:
	--   1. Effect Visual
	--   2. Turn Visual (if not scripted)
	--   3. Ability Visual (if not scripted)
	--   4. Effect Type Visual
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil
	effectVisual, turnVisual, abilityVisual, effectTypeVisual = GetAllAbilityVisualsFromEffectID(effectID)

	if (effectVisual) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT Visual ID \" .. effectVisual.ID)
		end
		return effectVisual
	end

	if (turnVisual and turnVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" "	0	748
748	"[1] PetBattle(3.0) - Ability Data"	"Visual: Using TURN Visual ID \" .. turnVisual.ID)
		end
		return turnVisual
	end

	if (abilityVisual and abilityVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using ABILITY Visual ID \" .. abilityVisual.ID)
		end
		return abilityVisual
	end

	if (debugEffectVisualSearch) then
		if (effectTypeVisual) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT TYPE visual ID \" .. effectTypeVisual.ID)
		else
			print(\"Effect \" .. effectID .. \" Visual: NONE FOUND\")
		end
	end

	return effectTypeVisual
end

function GetAuraAbilityVisualID(auraAbilityID)
	-- in the absence of any other info, search down to the first turn
	local visualID = nil
	local ability = petAbilities[auraAbilityID]
	if (not ability) then
		return visualID
	end

	if (ability.visualID and ability.visualID ~= 0) then
		visualID = ability.visualID
	end

	if (#ability.turnIDs < 1) then
		return visualID
	end

	local abilityTurn = petAbilityTurns[ability.turnIDs[1]]
	if (not abilityTurn) then
		return visualID
	end

	if (abilityTurn.visualID and abilityTurn.visualID ~= 0) then
		visualID = abilityTurn.visualID
	end

	return visualID
end

function GetAuraAbilityVisual(auraAbilityID)
	local abilityVisualID = GetAuraAbilityVisualID(auraAbilityID)
	if (not abilityVisualID) then
		return nil
	end

	return petAbilityVisuals[abilityVisualID]
end
"	747	0
749	"PetBattle(3.0) - Init Player"	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\"pad\", padModel, padTransform, padScale*battleScale)
	padCreateData.interactible = false
	local padActor = nil
	if (PetBattleScene.SpawnPet) then
		padActor = battleScene:SpawnPet(playerID, PetBattlePetID.Pad, padCreateData)
	else
		padActor = scene:SpawnActor(padCreateData)
	end

	padActor:Fade(padAlpha, 0)

	-- spawn NPC character
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)
		local npcCreateData = ActorCreateData:Default()
		npcCreateData.creatureID = team.npcCreatureID
		npcCreateData.creatureDisplayID = team.npcDisplayID
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)
		npcCreateData.interactible = false
		team.npcActor = scene:SpawnActor(npcCreateData)
		team.playerDisplay = team.npcActor
	end

	team.pets = { }
	local numDescs = #team.petDescs
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing
	for id, petDesc in pairs(team.petDescs) do
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }
		pet.playerID = playerID
		team.pets[id] = pet

		if (id == PetBattlePetID.Pad) then
			pet.isPad = true
			pet.actor = padActor
			team.pad = pet
		else			
			pet.isPad = false
			local radius = backlineRadius
			local offset = 0
			if id == team.activePet then
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
					radius = backlineRadius
				else
					radius = idleRadius
				end
			else
				offset = backLineOffset
				backLineOffset = backLineOffset + backlineSpacing
			end
			
			local pos = BuildVector(team.teamFacing, -radius, offset)
			local transform = Transform:New(pos, team.teamFacing)
			
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)
			petCreateData.creatureDisplayID = petDesc.displayID or 0

			if (PetBattleScene.SpawnPet) then
				pet.actor = battleScene:SpawnPet(playerID, id, petCreateData)
			else
				pet.actor = scene:SpawnActor(petCreateData)
			end

			SetXP(pet, petDesc.xp, petDesc.level, true)
			SetHealth(pet, petDesc.health, true)

			pet.status = petDesc.status

			pet.currentRadius = radius
			pet.currentOffset = offset

			-- always face the opponent location (at idleRadius)
			LookAtOpposingTeam(pet)

			-- hide all pets until loaded
			pet.actor:SetInteractible(false)
			pet.actor:SetHidden(true)
			pet.actor:Fade(0, 0)
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)
		end

		-- apply initial auras
		for auraIndex, auraData in pairs(petDesc.auras or { }) do
			local auraVisual = GetAuraAbilityVisual(auraData.abilityID)
			if (auraVisual) then
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
			end
		end
	end
end

function WaitAllPetsLoaded()

	local waitCondition = function()
		-- all actors must be renderable
		for playerID, player in pairs( allPlayers ) do
			for slot, pet in pairs ( player.pets ) do
				if not pet.actor:IsReadyToDisplay() then
					return false
				end
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

end

function FadeInAllPets( fadeInTime )

	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, "	0	750
750	"[1] PetBattle(3.0) - Init Player"	"pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetHidden(false)

					local targetAlpha = backlineAlpha
					if slot == player.activePet then
						-- use the front alpha if it is the active pet
						targetAlpha = GetAlpha(pet)
					end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	749	0
751	"PetBattle(3.0) - Effect Cast"	"
--------------------------------------------------------------------------------
function GetRelevantEffectPets(effect)
	if (not effect) then
		return
	end

	-- if the effect source was from an aura, look up the owning pet and use that
	local sourceAuraOwnerPet = GetAuraOwnerPet(effect.sourceAuraInstanceID)

	local casterPlayer = GetTeamByIndex(effect.casterPlayerID)
	local casterPet = casterPlayer.pets[effect.casterPetSlot]
	
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - effect.casterPlayerID)

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	-- the source off the effect is the owner of the aura, otherwise fall back to the casting pet
	local effectSourcePet = casterPet
	if (sourceAuraOwnerPet) then
		effectSourcePet = sourceAuraOwnerPet
	end

	return effectSourcePet, casterPet, casterFrontPet, opponentFrontPet, targetPet
end

--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)

	local effectSourcePet = nil
	local casterPet = nil
	local casterFrontPet = nil
	local opponentFrontPet = nil
	local targetPet = nil
	effectSourcePet, casterPet, casterFrontPet, opponentFrontPet, targetPet = GetRelevantEffectPets(effect)
	if (not effectSourcePet) then
		return
	end

	--
	-- Get the pets in their rightful places
	--
	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, readyRadius)
	end

	local abilityVisual = GetAbilityVisual(abilityVisualID)
	if not abilityVisual then
		return effectSourcePet
	end

	local attackRadius = GetAttackRadius(abilityVisual.range)
	
	-- move front pet to the correct radius, if it was the caster
	if (effectSourcePet) and (not effectSourcePet.deathAnimKit) then
		local sourcePlayer = GetTeamByIndex(effectSourcePet.playerID)
		if (sourcePlayer.activePet == effectSourcePet.slot) then
			WaitMoveToRadius(effectSourcePet, attackRadius)
		end
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = effectSourcePet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	effectSourcePet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (effectSourcePet.actor ~= targetPet.actor) then
		effectSourcePet.actor:PlaySpellCastVisualAtTargets(
			spellVisualID,
			abilityVisual.impactTime,
			true,
			{targetPet.actor})
	else
		-- self targeted
		effectSourcePet.actor:PlaySpellCastVisual(spellVisualID)
	end

	-- wait for impact
	if (effectSourcePet.actor:HasPendingMissiles(0) == true) then
		effectSourcePet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return effectSourcePet, spellVisualID
end
"	0	0
752	"PetBattle(3.0) - Effect Swap"	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

--	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player point
	if (team.playerDisplay) then
		team.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	-- store where the backline pet was
	local backLineOffset = nextPet.currentOffset

	nextPet.actor:Fade(GetAlpha(nextPet), backlineFadeTime)		
	if (lastPet.currentHealth <= 0) then
		lastPet.actor:Fade(0, backlineFadeTime)

		-- backline pet moves straight to the front
		WaitMoveToRadius(nextPet, idleRadius, 0)

		-- teleport the corpse
		MoveToRadius(lastPet, backlineRadius, backLineOffset, true)

		-- fade corpse back in
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)
	else
		-- swap pets normally
		lastPet.actor:Fade(backlineAlpha, backlineFadeTime)

		-- backline pet moves straight to the front
		MoveToRadius(nextPet, idleRadius, 0)
		
		-- frontline pet moves forward then back
		WaitMoveToRadius(lastPet, backlineRadius, 0)
		MoveToRadius(lastPet, backlineRadius, backLineOffset)
		
		-- continue once the new frontline pet has finished moving
		nextPet.actor:WaitMovementComplete()
	end

	team.activePet = petIndex
end
"	0	0
753	"PetBattle(3.0) - Effect Set Health"	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no abilityVisual for SetHealth\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local playersWithDeaths = { }
	local playersWithKills = { }

	local isCritical = false
	if (effect.flags and effect.flags.crit) then
		isCritical = true
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.flags and effect.flags.miss == true) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)	
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		local oldHealth = targetPet.currentHealth
		local newHealth = effect.value	-- actual health change is stored in the value field

		SetHealth(targetPet, newHealth, false, isCritical)

		if (newHealth <= 0) and (oldHealth > 0) then
			playersWithDeaths[effect.casterPlayerID] = true
			if (effectSourcePet) then
				playersWithKills[effect.casterPlayerID] = true
			end
		end
	end

	-- feedback on players that lost pets
	for playerID, hasDeath in pairs(playersWithDeaths) do
		if (hasDeath) then
			playersWithKills[playerID] = nil
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)
			end
		end
	end

	-- feedback on players that killed pets
	for playerID, hasKill in pairs(playersWithKills) do
		if (hasKill) then
			local player = GetTeamByIndex(playerID)
			if (player and player.playerDisplay) then
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)
			end
		end
	end

	-- wait until the casters animation has completed
	if (spellVisualID) and (effectSourceActor) then
		effectSourceActor:WaitCastingComplete(true)
	end
end
"	0	0
754	"PetBattle(3.0) - Effect Aura Apply"	"
-- store a mapping of all active auras to the pet they\'re on
local activeAuraPets = { }

--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisual = GetAbilityVisualFromEffectID(effect.effectID)
	local abilityVisualID = nil
	if (abilityVisual) then
		abilityVisualID = abilityVisual.ID
	end

	local auraSpellVisualID = 0
	local auraVisual = GetAuraAbilityVisual(effect.auraAbilityID)
	if (auraVisual) then
		auraSpellVisualID = auraVisual.spellVisualID
	end

	local casterCastingPet
	local spellVisualID
	effectSourcePet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\"WARNING: no auraVisual for aura\")
	elseif (not spellVisualID) then
		print(\"WARNING: no spellVisual found for BattlePetVisual ID=\" .. abilityVisualID)
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	local effectSourceActor = nil
	if (effectSourcePet) then
		effectSourceActor = effectSourcePet.actor
	end

	if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then
		targetPet.actor:AddWorldText(effectSourceActor, MissReasons.Physical, false, false)
	else
		if (spellVisualID) then
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)
		end

		-- apply an aura, tracked by instance ID
		ApplyAura(targetPet, effect.auraInstanceID, effect.auraTurnsRemaining, auraSpellVisualID)
	end

	-- wait until the casters animation has completed
	if (spellVisualID) then
		effectSourceActor:WaitCastingComplete(true)
	end
end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	activeAuraPets[auraInstanceID] = pet

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	if (aura.spellVisualID) then
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	else
		aura.spellVisualInstanceID = nil
	end
	aura.turnsRemaining = turnsRemaining

	return aura;
end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil
	activeAuraPets[auraInstanceID] = nil
end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end

"	0	755
755	"[1] PetBattle(3.0) - Effect Aura Apply"	"--------------------------------------------------------------------------------
function GetAuraOwnerPet(auraInstanceID)
	if (auraInstanceID) then
		return activeAuraPets[auraInstanceID]
	end
end

"	754	0
756	"PetBattle(3.0) - Effect Aura Change"	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	local petPlayerID = effect.targetPlayerID
	local petSlot = effect.targetPetSlot

	local player = GetTeamByIndex(petPlayerID)
	local pet = player.pets[petSlot]

	if not petSlot then
		return
	end

	local auraInstanceID = effect.auraInstanceID
	local aura = pet.auras[auraInstanceID]
	if not aura then
		print(\"ERROR: unknown aura instance ID \" .. auraInstanceID)
		return
	end

	if (cancel == true) or (effect.auraTurnsRemaining < 1) then
		RemoveAura(pet, auraInstanceID)
	else
		aura.turnsRemaining = effect.auraTurnsRemaining
	end

end
"	0	0
757	"PetBattle(3.0) - Effect Status Change"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (target and target.status) then
		targetPet.status = target.status
	end

	-- check if we need to perform a special trap visual
	local player = nil
	if (effect.casterPlayerID > 0) then
		player = GetTeamByIndex(effect.casterPlayerID)
	end

	if (player and player.trapPrecastID) then
		TrapCast(effect)
	end
end
"	0	0
758	"PetBattle(3.0) - EffectSet State"	"--------------------------------------------------------------------------------
-- STATUS CHANGE
local debugStates = false
function EffectSetState(effect)
	if (not effect) then
		return
	end

	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (target and target.stateID and target.value) then
		if (debugStates == true) then
			print(\"STATE CHANGE: Player \" .. target.playerID .. \", Pet \" .. target.petSlot .. \" - \" .. \"State \" .. target.stateID .. \" = \" .. target.value )
		end
	end
end
"	0	0
759	"PetBattle(3.0) - Effect Processing"	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false

function ProcessAllRoundResults(allEffects)

	if (debugOn == true) then
		print(\"== Round Result Grouping ==\")
	end

	-- group on (turnInstanceID, effectID, stackDepth)

	-- build an effect tree, taking into account procs
	local turnGroups = { }
	local effectGroups = { }
	
	-- top level turns that we will process
	local topLevelTurnGroups = { }
	
	-- generate groups, and a  mapping from effectIndex
	local lastEffect = nil
	for effectIndex, effect in pairs(allEffects) do
		local turnKey
		local effectKey
		turnKey, effectKey = GenerateUniqueGroupKeys(effect)

		-- find or build a turn group as necessary
		local turnGroup = turnGroups[turnKey]
		if (not turnGroup) then
			turnGroup =
			{
				key = turnKey;
				firstEffect = effect;
				effects = { };
			}
			turnGroups[turnKey] = turnGroup
			
			if (effect.stackDepth <= 1) or (not lastEffect) then
				if (not table) then
					topLevelTurnGroups[#topLevelTurnGroups + 1] = turnGroup
				else
					table.insert(topLevelTurnGroups, turnGroup)
				end
			else
				-- this is a proc off of the last effect, and should be attached as a child
				lastEffect.procGroup = turnGroup
			end

			if (debugOn == true) then
				print(\"+ New Turn Group, turnID = \" .. effect.turnInstanceID .. \", depth = \" .. effect.stackDepth)
			end
		end
		
		-- find or build an effect group as necessary
		local effectGroup = effectGroups[effectKey]
		if (not effectGroup) then
			effectGroup =
			{
				key = efffectKey;
				firstEffect = effect;
				results = { };
			}
			effectGroups[effectKey] = effectGroup
			
			-- this is a new effect group, link it to the end of our parent turn group
			if (not table) then
				turnGroup.effects[#turnGroup.effects + 1] = effectGroup
			else
				table.insert(turnGroup.effects, effectGroup)
			end

			if (debugOn == true) then
				print(\"+   New Effect Group, effectID = \" .. effect.effectID)
			end
		end
		
		-- add this effect to the end of the group list
		if (not table) then
			effectGroup.results[#effectGroup.results + 1] = effect
		else
			table.insert(effectGroup.results, effect)
		end

		if (debugOn == true) then
			print(\"+     New Result, instanceID = \" .. effect.instanceID)
		end
		
		lastEffect = effect
	end

	if (debugOn == true) then
		print(\"  \")
		print(\"== Start Round Playback ==\")
	end
	
	-- process top level turns in order
	for index, turnGroup in pairs(topLevelTurnGroups) do
		ProcessRoundTurnGroup(turnGroup)
	end

	if (debugOn == true) then
		print(\"== End Round Playback ==\")
		print(\"  \")
	end

end

--------------------------------------------------------------------------------
function ProcessRoundTurnGroup(turnGroup)
	if (debugOn == true) then
		print(\"- Processing Turn \" .. turnGroup.firstEffect.turnInstanceID)
	end

	-- use a custom script handler if we have one
	local abilityEffect = GetAbilityEffect(turnGroup.firstEffect.effectID)
	local abilityTurn = nil
	if (abilityEffect) then
		abilityTurn = GetAbilityTurn(abilityEffect.turnID)
	end

	local turnVisual = nil
	if (abilityTurn) then
		turnVisual = GetAbilityVisual(abilityTurn.visualID)
	end

	local processed = false
	if (turnVisual and turnVisual.scriptFunction) then
		if ( turnVisual.scriptFunction( turnGroup ) ) then
			processed = true
		end
	end

	-- fallback processing
	if (processed ~= true) then
		for index, effectGroup in pairs(turnGroup.effects) do
			ProcessRoundEffectGroup(effectGroup)
		end
	end
end

--------------------------------------------------------------------------------
function ProcessRoundEffectGroup(effectGroup)
	if (debugOn == true) then
		print(\"-   Processing Effect \" .. "	0	760
760	"[1] PetBattle(3.0) - Effect Processing"	"effectGroup.firstEffect.effectID)
	end

	-- use a custom script handler if we have one
	local abilityEffect = GetAbilityEffect(effectGroup.firstEffect.effectID)
	local effectVisual = nil
	if (abilityEffect) then
		effectVisual = GetAbilityVisual(abilityEffect.visualID)
	end

	local processed = false
	if (effectVisual and effectVisual.scriptFunction) then
		if ( effectVisual.scriptFunction( effectGroup ) ) then
			processed = true
		end
	end

	-- fallback handling
	if (processed ~= true) then
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Process an individula Round Effect Result
function ProcessRoundResult(event)

	if (debugOn == true) then
		print(\"-     Processing Result \" .. event.instanceID)
	end

	local eventType = event.eventType
	local effectType = event.effectType

	if not (eventType == PetBattleEvent.RoundResult) then
		return
	end

	-- battle round effects
	if (effectType == PetBattleEffect.SetHealth) then
		EffectSetHealth(event)
	elseif (effectType == PetBattleEffect.AuraApply) then
		EffectAuraApply(event)
	elseif (effectType == PetBattleEffect.AuraCancel) then
		EffectAuraChange(event, true)
	elseif (effectType == PetBattleEffect.AuraChange) then
		EffectAuraChange(event, false)
	elseif (effectType == PetBattleEffect.PetSwap) then
		EffectSwap(event.casterPlayerID, event.targetPetSlot)
	elseif (effectType == PetBattleEffect.StatusChange) then
		EffectStatusChange(event)
	elseif (effectType == PetBattleEffect.SetState) then
		EffectSetState(event)
	end

end

--------------------------------------------------------------------------------
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn

--------------------------------------------------------------------------------
function GenerateUniqueGroupKeys(effect)	
	local stackDepth = effect.stackDepth or 0
	local turnInstanceID = effect.turnInstanceID or 0
	local effectID = effect.effectID or 0
	if (stackDepth > maxStackDepth) then
		print (\"WARNING: stack depth exceeded \" .. maxStackDepth)
	end
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then
		print (\"WARNING: max turn instanceIDs exceeded \" .. maxTurnInstanceIDs)
	end
	
	local turnKey = turnInstanceID*maxStackDepth + stackDepth
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey
	return turnKey, effectKey
end

"	759	0
761	"PetBattle(3.0) - Event Reward"	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = GetTeamByIndex(reward.playerID)
			local playerPet = player.pets[reward.petSlot]
			if (playerPet) then
				local rewardedPet =
				{
					pet = playerPet;
					newXP = reward.newXP;
					newLevel = reward.newLevel;
				}
				rewardedPets[rewardIndex] = rewardedPet

				-- resurrect and move this pet up
				if (playerPet.deathAnimKit) then
					playerPet.deathAnimKit:Stop()
					playerPet.deathAnimKit = nil		
				end

				playerPet.actor:Fade(1.0, backlineFadeTime)
				MoveToRadius(playerPet, idleRadius, playerPet.currentOffset)
			end
		end
	end

	-- wait until all pets have stopped moving
	local waitCondition = function()
		-- all actors must be renderable
		for prewardIndex,rewardedPet in pairs(rewardedPets) do
			if rewardedPet.pet.actor:IsMoving() then
				return false
			end
		end
		return true
	end
	scene:WaitCondition(waitCondition)

	-- apply the rewards
	for rewardIndex,rewardedPet in pairs(rewardedPets) do
		SetXP(rewardedPet.pet, rewardedPet.newXP, rewardedPet.newLevel, false)
	end
end
"	0	0
762	"PetBattle(3.0) - Event Move Ability Selected"	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityID)

	local player = nil
	local pet = nil
	if (observingPlayerIndex > 0) then
		player = GetTeamByIndex(observingPlayerIndex)
		if (player) then
			pet = player.pets[player.activePet]
		end
	end

	if (not pet) then
		return
	end

	local radius = readyRadius
	WaitMoveToRadius(pet, radius)

end
"	0	0
763	"PetBattle(3.0) - Event Move Pet Swap Selected"	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\"Move Selected: Pet Swap Slot: \" .. petSlot)

end"	0	0
764	"PetBattle(3.0) - Event Move Trap Selected"	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected(trapAbilityID)

	-- print(\"Move Selected: Trap\")
	StartTrapPrecast(observingPlayerIndex)

end

function GetTrapVisuals(playerID)

	local player = nil
	local playerDisplay = nil
	if (playerID and (playerID > 0)) then
		player = GetTeamByIndex(playerID)
		if (player) then
			playerDisplay = player.playerDisplay
		end
	end
	
	if (not playerDisplay) then
		return
	end

	local trapVisual = GetAuraAbilityVisual(player.trapAbilityID)
	local trapSpellVisualID = nil
	if (trapVisual) then
		trapSpellVisualID = trapVisual.spellVisualID
	end

	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then
		return
	end

	return player, playerDisplay, trapVisual, trapSpellVisualID
end

function StartTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (playerDisplay) then
		if (not player.trapPrecastID) then
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID)
		end
	end

end

function ClearTrapPrecast(playerID)

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)
	if (not player) then
		return
	end

	if (player.trapPrecastID) then
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)
		player.trapPrecastID = nil
	end

end

function TrapCast(effect)

	local playerID = effect.casterPlayerID

	local player
	local playerDisplay
	local trapVisual
	local trapSpellVisualID
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)

	if (not player) then
		return
	end

--	print(\"Casting Trap...\")

	StartTrapPrecast(playerID)
	scene:WaitTimer(trapVisual.castTime)
	ClearTrapPrecast()


	local targetPlayer = GetTeamByIndex(effect.targetPlayerID)
	local targetPet = targetPlayer.pets[effect.targetPetSlot]

	if (targetPet) then
		local trapSuccess = false
		if (targetPet.status) then
			trapSuccess = targetPet.status.isTrapped
		end

		castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})
		scene:WaitTimer(trapVisual.impactTime)

		local waitCondition = function()
			return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)
		end
		scene:WaitCondition(waitCondition)

		if (trapSuccess) then
			--print(\"Succesful Trap\")
			targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)
		else
			print(\"Failed Trap\")
		end
	end

end
"	0	0
765	"PetBattle(3.0) - Event Processing"	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.value)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.targetPetSlot)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected(event.value)
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\"WARNING: processing round result outside of RoundStart/End\")
		ProcessRoundResult(event)
	elseif (eventType == PetBattleEvent.RoundStart) then

		-- pull off all round effects
		local allEffects = { }
		local effectNum = 0
		local done = false
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do
			event = battleScene:GetPendingEffect()
			eventType = event.eventType
			if (eventType == PetBattleEvent.RoundComplete) then
				done = true
			else
				effectNum = effectNum + 1
				allEffects[effectNum] = event
			end
		end
		
		-- if we have at least one effect or we\'re done, make sure
		-- process the round start then batch process effects
		-- NOTE: the event we are left with will be RoundComplete
		if (done == true or #allEffects > 0) then
			SignalEffectProcessed()
			ProcessAllRoundResults(allEffects)

			-- switch to the next pendign event
			StartEffectProcessing(event)
		end
	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (eventType == PetBattleEvent.RoundComplete) then
		for playerID, player in pairs(teams) do
			ClearTrapPrecast(playerID)
		end
		ResetActivePets()
	end

	return true
end

function StartEffectProcessing(event)
	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID
end

function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(effects)
  local customFunc = function(effects)
    return %s
  end
  customFunc(effects)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString
	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\"ERROR: loading script on BattlePetVisual ID=\" .. abilityVisual.ID .. \" failed: \" .. createString)
			print(\"ERROR: \" .. result)
		"	0	766
766	"[1] PetBattle(3.0) - Event Processing"	"end
	end

end

"	765	0
767	"PetBattle(3.0) - Cameras"	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \"arenaCameraBunny\"
	cameraBunnyCreate.model = padModel
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()
	cameraBunnyCreate.transform.facing = player.teamFacing
	cameraBunnyCreate.interactible = false

	cameraBunny = scene:SpawnActor(cameraBunnyCreate)
	cameraBunny:SetFacingToAbs(BuildVector(player.teamFacing, playerRadius, 0.0))
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)
	
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)
end

function StopCameraBunny(transitionTime)
	if ( not cameraBunny ) or ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	-- return to the player
	local player = teams[observingPlayerIndex]
	scene:ResetGameCameraZoom()

	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)
	scene:WaitTimer(transitionTime)
	scene:SetGameCameraTarget(nil, 0.0, 0.0)
end

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 2.0, observedTeam.pad.actor, otherTeam.pad.actor)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad.actor, arenaRing)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0
768	"PetBattle(3.0) - Intro"	"
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(1.5)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(1.6)
		scene:SetCamera(0, 0.75, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end

	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0
769	"PetBattle(3.0) - Arena"	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \"arenaRing\"
arenaCreateData.model = arenaRingModel
arenaCreateData.scale = arenaRingScale
arenaCreateData.interactible = false
arenaRing = scene:SpawnActor(arenaCreateData)
arenaRing:Fade(0, 0)
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)

scene:WaitTimer(0.25)
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)
"	0	0
770	"PetBattle(3.0) - Placeholder Players"	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \"placeHolder\" .. playerID
					createData.interactible = false
					createData.floatingTooltip = false

					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)
					local transform = Transform:New(pos, player.teamFacing)
					createData.transform = transform

					placeHolderActor = scene:SpawnActor(createData)
					placeHolderActors[playerID] = placeHolderActor
				end

				-- keep using the placeholder
				player.playerDisplay = placeHolderActor
			else
				-- done with this placeholder, despawn it
				local placeHolderActor = placeHolderActors[playerID]
				if (placeHolderActor) then
					placeHolderActor:Despawn()
				end

				placeHolderActors[playerID] = nil
			end
		end
	end
end

placeHolderActors = nil
"	0	0
771	"PetBattle(3.0) - Main"	"
--------------------------------------------------------------------------------
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

InitStaticData(initialBattleState)

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[0].teamFacing = 0
initialBattleState.players[1].teamFacing = 0
initialBattleState.players[2].teamFacing = 180

teams = { }
teams[0] = initialBattleState.players[0]
teams[1] = initialBattleState.players[1]
teams[2] = initialBattleState.players[2]

if (teams[1]) then
	teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
end
if (teams[2]) then
	teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
end

if (teams[2].isNPC == true) and (#teams[2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(0, teams[0])
InitTeam(1, teams[1])
InitTeam(2, teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		if (useFreelookCamera) then
			StartCameraBunny(0)
		else
			SetCamera(3)
		end
	end
	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle, winnerID = ProcessEvent(event)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
			-- move backline up to celebrate
			pet.actor:Fade(1.0, backlineFadeTime)
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.25)
	else
		SetCamera(4)
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0
772	"[1] Flying - Cocoon Strike"	"turn.effects[index];
			DefaultDoEffectProcessing( nil, \"effect\", effect ); 
		end
	end

	if ( turnVisualPlayed ) then 
		DefaultTurnCleanUp(ROID);
	end

end"	737	0
773	"Brazie\'s PetBattle - Result Event Filtering"	"
-- Used for the Brazie Event Filtering System
function FilterResultEventsByType(event)
	local filteredEvent = FilteredEventMetaTable({});
	
	local eventType = event.eventType
	local effectType = event.effectType

	-- What kind of result
	filteredEvent.eventType = event.eventType;
	filteredEvent.resultType = event.effectType;
	filteredEvent.instanceID = event.instanceID;

	-- Procs
	filteredEvent.procGroup = event.procGroup;

	-- Targetting
	filteredEvent.targetPlayerID = event.targetPlayerID;
	filteredEvent.targetPetSlot = event.targetPetSlot;

	-- Failure reasons
	if ( event.failureReason and event.failureReason > 0 ) then
		filteredEvent.failureReason =  event.failureReason;
	end

	if ( event.flags ) then

		filteredEvent.invalidTarget = event.flags.invalidTarget;
		filteredEvent.miss = event.flags.miss;
		filteredEvent.crit = event.flags.crit;
		filteredEvent.blocked = event.flags.blocked;
	end

	-- battle round effects
	if ( effectType == PetBattleEffect.SetHealth)  then

		filteredEvent.value = event.value;

	elseif (
		effectType == PetBattleEffect.AuraApply or
		effectType == PetBattleEffect.AuraChange or
		effectType == PetBattleEffect.AuraCancel ) then

		filteredEvent.auraAbilityID = event.auraAbilityID
		filteredEvent.auraInstanceID = event.auraInstanceID
		filteredEvent.auraTurnsRemaining = event.auraTurnsRemaining

	elseif ( effectType == PetBattleEffect.PetSwap ) then

		filteredEvent.targetPlayerID = event.targetPlayerID;
		filteredEvent.targetPetSlot = event.targetPetSlot;

	elseif ( effectType == PetBattleEffect.SetState ) then

		filteredEvent.stateID = event.stateID
		filteredEvent.stateValue = event.value;

	elseif ( effectType == PetBattleEffect.StatusChange ) then
		filteredEvent.isTrapped = event.status.isTrapped;
		filteredEvent.isStunned = event.status.isStunned;
		filteredEvent.isSwapLocked = event.status.isSwapLocked;

	elseif ( effectType == PetBattleEffect.SetMaxHealth ) then 

		filteredEvent.value = event.value;

	elseif ( effectType == PetBattleEffect.SetSpeed ) then 

		filteredEvent.value = event.value;

	elseif ( effectType == PetBattleEffect.SetPower ) then 

		filteredEvent.value = event.value;

	end

	return filteredEvent;
end

function FilteredEventMetaTable(newTable)

	setmetatable(newTable, { __tostring = FilteredEventMetaTablePrinter })
	
	return newTable;
end
function FilteredEventMetaTablePrinter (tableRef, depth) 
	local output = \"{\n\";
	local indent = depth or 1;
	local indentText = \"\";

	-- Safety valve
	if ( indent > 100 ) then
		return \"Depth Error\";
	end

	for i=1,indent do 
		indentText = indentText..\"  \";
	end

	for key,val in pairs( tableRef ) do 
		local text = tostring(val);
		if ( key == \"resultType\" ) then 
			for name,id in pairs( PetBattleEffect ) do 
				if ( val == id ) then 
					text = name;
				end
			end

		elseif ( key  == \"playerID\" or key  == \"targetPlayerID\" or key  == \"swapPlayerID\" ) then 
			text = tostring(val);
			for name,id in pairs( PetBattlePlayerID ) do 
				if ( val == id ) then 
					text = name;
				end
			end

		elseif (key  == \"petSlot\" or key  == \"targetPetSlot\" or key == \"oldFrontPet\" or key == \"newFrontPet\" ) then 
			text = tostring(val);

			for name,id in pairs( PetBattlePetID ) do 
				if ( val == id ) then 
					text = name;
				end
			end			

		elseif (key  == \"stateID\" ) then 
			text = tostring(val);
			for name,id in pairs( STATE_LOOKUP ) do 
				if ( val == id ) then 
					text = name;
				end
			end			

		elseif ( type(val) == \"table\" ) then 
			text = FilteredEventMetaTablePrinter(tableRef, indent + 1);
		else
			text = tostring(val);
		end
		output = output..indentText..\"K: \"..key..\" V: \"..text..\"\n\";
	end

	output = output..\"}\n\";

	return output
end


	--
	-- Effect Types:
	--
	"	0	774
774	"[1] Brazie\'s PetBattle - Result Event Filtering"	"-- 

	-- EventTypes
	--
	-- This list is primarily for my own edification
	--
	-- PetBattleEvent.BattleOver
	--	params:
	--		event.winnerID - ID of the winner
	--
	-- PetBattleEvent.BattleResults
	--  params:
	--		event.rewards {
	--				playerID
	--				petSlot 
	--				wasCaptured
	--				newLevel
	--				newXP
	--			}
	--
	--	PetBattleEvent.ObserverChange
	--   param:
	--		- none -
	--
	--	PetBattleEvent.MoveAbilitySelected
	--	 params:
	--		event.abilityVisualID
	--
	--	PetBattleEvent.MovePetSwapSelected
	-- 	 params:
	--		event.newFrontPet
	--  
	-- PetBattleEvent.MoveTrapSelected
	-- 	 params:
	--		event.abilityVisualID - the trap ability visual id
	-- 
	-- PetBattleEvent.RoundEffect
	-- 	 params:
	-- 		- MANY -
	-- 
	-- PetBattleEvent.RoundStart
	--	 params:
	--		roundNumber - the round starting
	--
	-- PetBattleEvent.RoundComplete
	-- 	 params:
	-- 		roundNumber - the round ending
	--		stateChange - the battle state



--DEBUG_TABLE(event);
--[[
for k,v in pairs (PetBattleEffect) do 
	if ( v == effectType ) then 
		print(\" ::\",k);
	end
end
--]]
"	773	0
775	"PetBattle - Ability Data"	"
local petAbilities = { }
local petAbilityTurns = { }
local petAbilityEffects = { }
local petAbilityEffectTypes = { }
local petAbilityVisuals = { }

local debugStaticData = false
local debugEffectVisualSearch = false 

function InitStaticData(initialBattleState)
	if (debugStaticData) then
		print(\"Init Static Data\")
	end

	for index,ability in pairs(initialBattleState.abilityDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY \" .. ability.ID)
		end
		petAbilities[ability.ID] = ability
	end

	for index,abilityTurn in pairs(initialBattleState.abilityTurnDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY TURN \" .. abilityTurn.ID)
		end
		petAbilityTurns[abilityTurn.ID] = abilityTurn
	end

	for index,abilityEffect in pairs(initialBattleState.abilityEffectDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT \" .. abilityEffect.ID)
		end
		petAbilityEffects[abilityEffect.ID] = abilityEffect
	end

	for index,abilityEffectType in pairs(initialBattleState.abilityEffectTypeDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY EFFECT TYPE \" .. abilityEffectType.ID)
		end
		petAbilityEffectTypes[abilityEffectType.ID] = abilityEffectType
	end

	for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
		if (debugStaticData) then
			print(\"Adding ABILITY VISUAL \" .. abilityVisual.ID)
		end

		petAbilityVisuals[abilityVisual.ID] = abilityVisual

		-- add any custom script function
		LoadCustomVisualScript(abilityVisual)
	end

end

function GetAbility(abilityID)
	if (abilityID) then
		return petAbilities[abilityID]
	end
end

function GetAbilityTurn(abilityTurnID)
	if (abilityTurnID) then
		return petAbilityTurns[abilityTurnID]
	end
end

function GetAbilityEffect(abilityEffectID)
	if (abilityEffectID) then
		return petAbilityEffects[abilityEffectID]
	end
end

function GetAbilityEffectType(abilityEffectTypeID)
	if (abilityEffectTypeID) then
		return petAbilityEffectTypes[abilityEffectTypeID]
	end
end

function GetAbilityVisual(abilityVisualID)
	if (abilityVisualID) then
		return petAbilityVisuals[abilityVisualID]
	end
end

function GetAllAbilityVisualsFromEffectID(effectID)
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil

	local abilityEffect = GetAbilityEffect(effectID)
	if (abilityEffect) then
		effectVisual = GetAbilityVisual(abilityEffect.visualID)

		-- check parents: turn and then ability
		local abilityTurn = GetAbilityTurn(abilityEffect.turnID)
		if (abilityTurn) then
			turnVisual = GetAbilityVisual(abilityTurn.visualID)

			local ability = GetAbility(abilityTurn.abilityID)
			if (ability) then
				abilityVisual = GetAbilityVisual(ability.visualID)		
			end			
		end

		-- check fallback: effect properties
		local effectType = GetAbilityEffectType(abilityEffect.effectType)
		if (effectType) then
			effectTypeVisual = GetAbilityVisual(effectType.visualID)
		end
	end

	return effectVisual, turnVisual, abilityVisual, effectTypeVisual
end

function GetAbilityVisualFromEffectID(effectID)
	-- Priority rules for picking visuals for an EFFECT:
	--   1. Effect Visual
	--   2. Turn Visual (if not scripted)
	--   3. Ability Visual (if not scripted)
	--   4. Effect Type Visual
	local effectVisual = nil
	local turnVisual = nil
	local abilityVisual = nil
	local effectTypeVisual = nil
	effectVisual, turnVisual, abilityVisual, effectTypeVisual = GetAllAbilityVisualsFromEffectID(effectID)

	if (effectVisual) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT Visual ID \" .. effectVisual.ID)
		end
		return effectVisual
	end

	if (turnVisual and turnVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" "	0	776
776	"[1] PetBattle - Ability Data"	"Visual: Using TURN Visual ID \" .. turnVisual.ID)
		end
		return turnVisual
	end

	if (abilityVisual and abilityVisual.scriptFunction == nil) then
		if (debugEffectVisualSearch) then
			print(\"Effect \" .. effectID .. \" Visual: Using ABILITY Visual ID \" .. abilityVisual.ID)
		end
		return abilityVisual
	end

	if (debugEffectVisualSearch) then
		if (effectTypeVisual) then
			print(\"Effect \" .. effectID .. \" Visual: Using EFFECT TYPE visual ID \" .. effectTypeVisual.ID)
		else
			print(\"Effect \" .. effectID .. \" Visual: NONE FOUND\")
		end
	end

	return effectTypeVisual
end

function GetAuraAbilityVisualID(auraAbilityID)
	-- in the absence of any other info, search down to the first turn
	local visualID = nil
	local ability = petAbilities[auraAbilityID]
	if (not ability) then
		return visualID
	end

	if (ability.visualID and ability.visualID ~= 0) then
		visualID = ability.visualID
	end

	if (#ability.turnIDs < 1) then
		return visualID
	end

	local abilityTurn = petAbilityTurns[ability.turnIDs[1]]
	if (not abilityTurn) then
		return visualID
	end

	if (abilityTurn.visualID and abilityTurn.visualID ~= 0) then
		visualID = abilityTurn.visualID
	end

	return visualID
end

function GetAuraAbilityVisual(auraAbilityID)
	local abilityVisualID = GetAuraAbilityVisualID(auraAbilityID)
	if (not abilityVisualID) then
		return nil
	end

	return petAbilityVisuals[abilityVisualID]
end
"	775	0
777	"[1] PetBattle - Result - Aura Apply"	"--------------------------------------------------------------------------------
function GetAuraOwnerPet(auraInstanceID)
	if (auraInstanceID) then
		return activeAuraPets[auraInstanceID]
	end
end

"	565	0
779	"Lorewalker Story - S13: Ballad of Liu Lang - MASTER - Lorewalker Cho - ZTO"	"--OnScene start

--Wait (2)
--lorewalker: StopLoopingSplitBodyAnim( Animations.EmoteReadLoop )
--PlayOneShotSplitBodyAnim( lorewalker, Animations.EmoteBow )
--Wait (2)
--SendTrigger( \"Spawn Face\" )
--RunToLocation( lorewalker, 2, 1465.6, 368.785, 550.221, 205.073 ) -- Cross UR
"	0	0
780	"Lorewalker Story - S13: Ballad of Liu Lang - Init - Scene 1 Actors - ZTO"	"-- Well of Eternity Test
wellID = \"world\\dungeon\\wellofeternity\\well_vortex_01.m2\"
well1 = SpawnModelActor( wellID, 1452.1, 372.201, 550.222, 219.019, .01, true )
Wait(10)
well1: Despawn()"	0	0
782	"Brazie\'s PetBattle - Turn - Trap Target"	"function Trap_Target(ROID, isTurn, turn)
	-- Only handle \"effect\" objects
	if ( isTurn ~= \"turn\" ) then
		print (\"ERROR: Object of type \"..isTurn..\" passed to Trap_Target\");

		return;
	end

	local visuals = true;

	-- If this is not being performed by a specific pet, skip the casting effects
	if ( not ROIDISAPET( ROID ) ) then
		visuals = false;
		userROID = nil;
	end

	-- Move into position
	--DefaultTurnPreEffectMovement(ROID, turn )

	local turnVisualPlayed = false;

	local turnVisualID = turn.turnVisualID ;
	local turnVisual = petAbilityVisuals[turnVisualID]

	if ( turnVisual ) then 
		
		-- Perform the Turn Visual
		local masterTargets = {}

		for index=1,#turn.effects do 
			local effect = turn.effects[index];
			local targets = EffectToROIDs ( effect );

			for k,v in pairs(targets) do 
				table.insert(masterTargets, v);
			end
		end

		--Dispatcher_PerformMultiTargetVisual(ROID, masterTargets, turnVisualID )
		local success = turn.effects[1].results[1].isTrapped;

		Dispatcher_OwnerTrap( ROID, masterTargets[1], success, turn )

		return true;
	end
end"	0	0
783	"Brazie\'s PetBattle - Victory Ceremony"	"function VictoryCeremony(winnerID)
print(\"Victory Ceremony - WINNER: \",winnerID);
	if (winnerID == 1) or (winnerID == 2) then
		local winnerTeam = teams[winnerID]
		for petIndex, pet in pairs(winnerTeam.pets) do
			if ( not pet.isPad ) then 
				print(\"PET: \"..petIndex..\" Health: \"..pet.currentHealth);
			end 
			if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
			end
		end
	
		Dispatcher_OwnerEmote( GETROIDFROMPLAYERID( winnerID ), Animations.EmoteCheer )

	
		scene:WaitTimer(3.0)
	end
end"	0	0
784	"---- Libraries ----"	""	0	0
785	"----- Parallel Dispatcher -----"	""	0	0
786	"Brazie\'s PetBattle - Victory Ceremony - Kirby Dance"	"function VictoryCeremony_PerformDance(player)
	local loc1 = player.home + BACKROW_PET_OFFSETS[1] + Vector:New(1,0,0)
	local loc2 = player.home + BACKROW_PET_OFFSETS[2] + Vector:New(1,0,0)
	local loc3 = player.home + BACKROW_PET_OFFSETS[3] + Vector:New(1,0,0)

	local actor1
	local actor2
	local actor3

	if ( player.pets[1] ) then 
		actor1 = player.pets[1].actor;
	end
	if ( player.pets[2] ) then 
		actor2 = player.pets[2].actor;
	end
	if ( player.pets[3] ) then 
		actor3 = player.pets[3].actor;
	end

	
	Dance_HopLeft(actor1, loc1);
	Dance_HopLeft(actor2, loc2);
	Dance_HopLeft(actor3, loc3);

	Dance_Recover(actor1, loc1);
	Dance_Recover(actor2, loc2);
	Dance_Recover(actor3, loc3);

	Dance_StepRight(actor1, loc1);
	Dance_StepRight(actor2, loc2);
	Dance_StepRight(actor3, loc3);

	Dance_Recover(actor1, loc1);
	Dance_Recover(actor2, loc2);
	Dance_Recover(actor3, loc3);

	Dance_HopRight(actor1, loc1);
	Dance_HopRight(actor2, loc2);
	Dance_HopRight(actor3, loc3);

	Dance_Recover(actor1, loc1);
	Dance_Recover(actor2, loc2);
	Dance_Recover(actor3, loc3);

	Dance_StepLeft(actor1, loc1);
	Dance_StepLeft(actor2, loc2);
	Dance_StepLeft(actor3, loc3);

	Dance_Recover(actor1, loc1);
	Dance_Recover(actor2, loc2);
	Dance_Recover(actor3, loc3);

	local t = 0;
	local step = 0.01;

	actor1:ClearFacing();
	actor2:ClearFacing();
	actor3:ClearFacing();

	while ( t < 1 ) do
		t = t + step;
		local rate = 360*10

		Dance_Spin(actor1, rate, step);
		Dance_Spin(actor2, rate, step);
		Dance_Spin(actor3, rate, step);

		scene:WaitTimer(step);
	end

end


function Dance_StepLeft(actor, loc)
	local time = 0.5;
	actor:SetFacingToAbs( loc + Vector:New (100,0,0) );
	actor:MoveToAbs( actor:GetPosition()+Vector:New(0,2,0) , time )
end

function Dance_StepRight(actor, loc)
	local time = 0.5;
	actor:SetFacingToAbs( loc + Vector:New (100,0,0) );
	actor:MoveToAbs( actor:GetPosition()+Vector:New(0,-2,0) , time )
end

function Dance_HopLeft(actor, loc)
	local time = 0.5;
	local spline = BuildKnockbackSpline(actor:GetPosition(), actor:GetPosition()+Vector:New(0,2,0) , time)

	actor:SetSnapToGround(false)
	actor:SetFacingToAbs( loc + Vector:New (100,0,0) );
	actor:MoveSplineAbs( spline , time )
end

function Dance_HopRight(actor, loc)
	local time = 0.5;
	local spline = BuildKnockbackSpline(actor:GetPosition(), actor:GetPosition()+Vector:New(0,-2,0) , time)

	actor:SetSnapToGround(false)
	actor:SetFacingToAbs( loc + Vector:New (100,0,0) );
	actor:MoveSplineAbs( spline , time )
end

function Dance_Recover(actor, loc)
	actor:WaitMovementComplete()
	actor:SetSnapToGround(false)
end

function Dance_Spin(actor, rate, deltaT)
	local transform = actor:GetTransform();
	local yaw = transform.yaw + rate * deltaT;

	local x,y,z = math.cos(yaw/180*math.pi), math.sin(yaw/180*math.pi), 0 
print(yaw);
	actor:SetTransform(transform);
	actor:SetFacingToAbs(actor:GetPosition() + Vector:New(x,y,z) );
end"	0	0
