field0	field1	field2	field3	field4				
4	Global Functions - Scene	"--
-- Scene Functions
--
Scene.__meta.__index = function(table, key)
	if Scene[key] == nil and type(key) == \string\"" and string.sub(key,1,4) == \""Wait\"" then"						
5	PetBattle - Main	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	if (battleScene.GetUIObservingPlayer) then
		observingPlayerIndex = battleScene:GetUIObservingPlayer()
		if (observingPlayerIndex > 0) then
			isObserved = true
		end
	end
else
	-- no battle scene implies a manually created test battle
	isObserved = true
	observingPlayerIndex = 1
end

--------------------------------------------------------------------------------
-- see if we\'re using test teams
if (battleScene and battleScene:UseTestPlayerData() == true) or (not initialBattleState) then
	initialBattleState = InitTestTeams()
end

--------------------------------------------------------------------------------
-- build ability and abilityTurn map
petAbilities = { }
petAbilityTurns = { }
for j,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
	for i,abilityTurn in pairs(ability.turns) do
		petAbilityTurns[abilityTurn.ID] = abilityTurn
	end
end

--------------------------------------------------------------------------------
-- spawn teams
if (isObserved == true) then
	-- backwards compatibility
	initialBattleState.players[observingPlayerIndex].teamFacing = 0
	initialBattleState.players[3-observingPlayerIndex].teamFacing = 180
else
	initialBattleState.players[1].teamFacing = 0
	initialBattleState.players[2].teamFacing = 180
end

teams = { initialBattleState.players[1], initialBattleState.players[2] }
InitTeam(teams[1])
InitTeam(teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		SetCamera(3)
	end

	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local effect = nil
	if (battleScene:IsTestBattle() == true) then
		effect = GenerateTestBattleEvent()
		if (not effect) then
			scene:WaitTimer(0)
		end
	else
		-- poll for round effects
		local waitForEffects = function()
			return battleScene:HasPendingEffects()
		end
		scene:WaitCondition(waitForEffects)
		effect = battleScene:GetPendingEffect()
	end

	inBattle, winnerID = ProcessEffect(effect)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if winnerTeam.activePet ~= petIndex and pet.currentHealth > 0 then
			-- move backline up to celebrate
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	SetCamera(4);
end

scene:WaitTimer(0.75)
battleScene:SignalBattleComplete()
"	0	0				
6	PetBattle - Functions	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(4)
			pet.actor:Fade(GetAlpha(pet), 2)
			scene:WaitTimer(2)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function GetAlpha(pet)
	
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end

end
"	0	0				
7	Darren\'s Test Scene Script 1	"print(\START: Darren\'s Test Script 2!!\"")"						
16	Darren\'s Math Test	"print(\Darren\'s Math Test\"")"						
18	Darren\'s Follower	"print(\-- START: Darren\'s Follower --\"")"						
30	Kun Lai Summit - Horde Hub Swap Scene - Worker 02 - JSB	"
-- small tent panda 02
-- wait a little before running in
Wait(2)
FadeIn( panda02, 1 )

-- run to the tents
RunToLocation( panda02, 5.5, 2298.76, 922.011, 481.216, 28.7984 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda02, fire16.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire04, smokeFadeOutTime )
PutOutFire( fire08, smokeFadeOutTime )
PutOutFire( fire16, smokeFadeOutTime )

Wait(1)

RunToLocation( panda02, 3, 2301.44, 926.885, 481.203, 57.6166 )

PlayLoopingSplitBodyAnim( panda02, Animations.EmoteWork )

Wait(2)

FadeOut( fire04.smoke )
FadeOut( fire08.smoke )
FadeOut( fire16.smoke )

Wait(1)

FadeIn( workDust02, 5 )


WaitForTrigger( \flagPlant\"" )"						
33	Darren\'s Test Scene Script 6	"print(\-- START: Darren\'s Test Script 6 --\"")"						
36	Test - Alex\'s Battle Pet - Move Library 2	"-- Variables

backwardSpeedMulti = 0.8

function PerformTripleAttack(pet, opponent, damage)
	local points = {
	}

	local numPoints = 5;
	local offset=270
	local step= 720/numPoints;

	for i=offset+step,offset+720,step do 
		local sin = math.s"						
38	Test - Alex\'s Battle Pet - Boundary Guy	"

--[[
local fireCreateData2 = ActorCreateData:NewModel(
	\Fireworks\"","						
40	Kun Lai Summit - Hub Swap Scene - Util - JSB	"
fireBunnyCreatureID = 60291
fireCreatureID = 60157
smokeCreatureID = 60406


-- custom stuff for this scene
function SpawnFire( x, y, z, scale )

	local fireSet = { }
	fireSet.bunny = SpawnActor( fireBunnyCreatureID, x, y, z, 0, scale )
	fireSet.fire = SpawnActor( fireCreatureID, x, y, z, 0, scale )
	fireSet.smoke = SpawnActor( smokeCreatureID, x, y, z, 0, scale )
	
	-- start with smokes invisible
	fireSet.smoke:Fade(0, 0)

	return fireSet

end

function SpawnSmoke( x, y, z, scale )

	-- visible smoke
	local smoke = SpawnActor( smokeCreatureID, x, y, z, 0, scale )
	return smoke

end

function PutOutFire( fire )

	fire.fire:Fade( 0, 1 ) -- fire fade out
	fire.smoke:Fade( 1, 3 ) -- smoke  fade in

end
"	0	0				
41	Cinematic Framework	"
-- default all cinematics to non relative
scene:SetRelativeCoords(false) -- set to absolute worlld coords

function Wait( time )
	scene:WaitTimer( time )
end

--
-- SpawnActor( creatureID, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnActor( creatureID, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local spawnPos = Vector:New( x, y, z )
	local spawnTransform = Transform:New( spawnPos, facing )
	createData = ActorCreateData:New( creatureID, spawnTransform, scale )
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actor = scene:SpawnActor( createData )
	actor:SetInteractible( false )
	return actor

end

--
-- SpawnModelActor( modelFileName, x, y, z, facing [default 0], scale [default 1] )
--   Spawn an uninteractible actor
--
function SpawnModelActor( modelFileName, x, y, z, facing, scale, snapToGround )
	if not facing then
		facing = 0
	end

	if not scale then
		scale = 1
	end

	local pos = Vector:New( x, y, z )
	local transform = Transform:New( pos, facing )
	createData = ActorCreateData:NewModel( \dummy\"", modelFileName, transform, scale )"						
48	Test - Alex\'s Battle Pet - CoreMove	"
function PerformMove(pet, opponent, effect)

		local opponentLocation = opponent.actor:GetPosition();
		local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
		local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
		local leftVector = UnitVectorCrossProduct(frontVector, upVector);

		local meleePoint = frontVector * 1*battleScale;
		local rangedPoint = frontVector * 3*battleScale;

		local meleeAttackPoint = opponentLocation + meleePoint;
		local rangedAttackPoint = opponentLocation + rangedPoint;

		pet.actor:ClearFacing(); 

		local move = 1--math.random(1,6);

		local melee = true; 
		local ranged = false;

		if ( move == 4 or move == 5 ) then
			melee = false;
		elseif ( move == 6 ) then 
			melee = false;
			ranged = true;
		end

		if ( melee ) then 
			local distance = meleeAttackPoint:Dist( pet.actor:GetPosition() );
			moveTime = distance/battleScale/(pet.moveSpeed);
			pet.actor:WaitMoveToAbs(meleeAttackPoint, moveTime)
		elseif ( ranged ) then 
			local distance = rangedAttackPoint:Dist( pet.actor:GetPosition() );
			moveTime = distance/battleScale/(pet.moveSpeed);
			pet.actor:WaitMoveToAbs(rangedAttackPoint, moveTime)
		else
			pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
		end

	local damage = opponent.health - effect.targets[1].newHealth;
	opponent.health = opponent.health - damage;
		
		if ( move == 6 ) then
			PerformRuptureLine(pet, opponent, damage)
		elseif ( move == 5 ) then 
			PerformArcaneBarrage(pet, opponent, damage);
		elseif ( move == 4 ) then 
			PerformWaveAttack( pet,opponent, damage );
		elseif ( move == 1 ) then
			PerformTripleAttack( pet, opponent, damage );
		elseif ( move == 2 ) then 
			PerformDodge(opponent, pet);
			pet.actor:CastSpell( 122, opponent.actor );
		else
			pet.actor:CastSpell( 122, opponent.actor );

			PerformKnockback(opponent, pet, damage);
		end
		
		pet.actor:WaitCastingComplete(true, 122)
		scene:WaitTimer(0.25)

		ReturnOrResetCheck( pet, opponent );

		--pet.actor:SetFacingToAbs(pet.currentLocation)
end

function ReturnOrResetCheck (pet, opponent)
	local newFrontVector = UnitVectorFromAtoB(opponent.actor:GetPosition(), pet.actor:GetPosition()  );
	local returnPoint = newFrontVector * 1.5*battleScale;

	local petLoc = returnPoint;
	local petHome = HOME_LIST[pet.team].position;
	local newDist = petLoc:Dist ( petHome );

	local returnDistance = pet.actor:GetPosition():Dist(petLoc)

	if ( newDist > 3 * battleScale ) then 
		petLoc = HOME_LIST[pet.team].position;
		returnDistance = petHome:Dist(pet.actor:GetPosition());
		print ( \reset\"" );"						
49	Kun Lai Summit - Horde Hub Swap Scene - Worker 03 - JSB	"
-- tower fire panda
-- wait a little before running in
Wait(3)
FadeIn( panda03, 1 )

-- run to the tents
RunToLocation( panda03, 5.5, 2294.56, 906.778, 480.939, 346.291 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda03, fire10.bunny, throwBucketSpellID )

-- wait for missile to hit
-- Wait(2)
PutOutFire( fire10, smokeFadeOutTime )
PutOutFire( fire05, smokeFadeOutTime )
PutOutFire( fire06, smokeFadeOutTime )
PutOutFire( fire09, smokeFadeOutTime )
PutOutFire( fire17, smokeFadeOutTime )

Wait(1)

RunToLocation( panda03, 3, 2286.12, 903.9, 481.107, 204.091 )

PlayLoopingSplitBodyAnim( panda03, Animations.EmoteWork )

-- Wait(2)

FadeOut( fire10.smoke )
FadeOut( fire05.smoke )
FadeOut( fire06.smoke )
FadeOut( fire09.smoke )
FadeOut( fire17.smoke )

FadeIn( workDust04, 5 )
FadeIn( workDust06, 5 )

-- nazgrim trigger
WaitForTrigger( \flagPlant\"" )"						
50	Kun Lai Summit - Horde Hub Swap Scene - Worker 04 - JSB	"
-- northern banner panda
-- wait a little before running in
Wait(10)
FadeIn( panda04, 1 )

-- run to north post
RunToLocation( panda04, 5.5, 2294.89, 972.168, 484.038, 262.369 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda04, fire01.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire01, smokeFadeOutTime )
PutOutFire( fire15, smokeFadeOutTime )

Wait(1)

RunToLocation( panda04, 5, 2295.67, 968.115, 484.196, 257.869 )

PlayLoopingSplitBodyAnim( panda04, Animations.EmoteWork )

Wait(2)

FadeOut( fire01.smoke )
FadeOut( fire15.smoke )"	0	0				
51	Kun Lai Summit - Horde Hub Swap Scene - Worker 05 - JSB	"
-- large tent panda
-- wait a little before running in
Wait(2)
FadeIn( panda05, 1 )

-- run to the tents
RunToLocation( panda05, 5.5, 2279.65, 959.75, 481.641, 287.309 )
RunToLocation( panda05, 5.5, 2269.5, 922.868, 481.587, 273.584 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda05, fire11.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(3.5)
PutOutFire( fire11, smokeFadeOutTime )
PutOutFire( fire07, smokeFadeOutTime )
PutOutFire( fire12, smokeFadeOutTime )
PutOutFire( fire13, smokeFadeOutTime )

Wait(1)

RunToLocation( panda05, 3, 2268.36, 914.467, 481.184, 210.584 )

PlayLoopingSplitBodyAnim( panda05, Animations.EmoteWork )

Wait(2)

FadeOut( fire11.smoke )
FadeOut( fire07.smoke )
FadeOut( fire12.smoke )
FadeOut( fire13.smoke )

-- Wait(1)

FadeIn( workDust03, 5 )

WaitForTrigger( \flagPlant\"" )"						
52	Test - Alex\'s Battle Pet - CoreSwap	"
function PerformSwap ( pet, newPet, opponent )
	local currentPetLoc = pet.actor:GetPosition();
	local currentBacklineLoc = newPet.actor:GetPosition();

	local distance = currentPetLoc:Dist(currentBacklineLoc);

	-- New guy faces the enemy
	newPet.actor:SetFacingToAbs(opponent.actor:GetPosition())

	-- Swap locations
	pet.actor:ClearFacing();
	pet.actor:MoveToAbs(currentBacklineLoc, distance/pet.moveSpeed)
	newPet.actor:WaitMoveToAbs(currentPetLoc, distance/newPet.moveSpeed)

	ReturnOrResetCheck( newPet, opponent );

	-- Make all of your pets look at their teammate

	for k,v in pairs( allPlayers[pet.team].pets ) do 
		if ( k ~= allPlayers[pet.team].activePet ) then 
			v.actor:SetFacingToTarget(newPet.actor, Vector:New());
		end
	end
end "	0	0				
53	Test - Alex\'s Battle Pet - Init	"print(\|cFFCCFFccAlex\'s Battle Pet Stage|r\"")"						
56	Test - Alex\'s Battle Pet - Move Library 3	"
-- Barrage of Moonfires
function PerformArcaneBarrage (pet, opponent, damage)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition(), opponentLocation   );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);


print(\barrage\"");"						
58	Kun Lai Summit - Horde Hub Swap Scene - Nazgrim 01 - JSB	"

-- wait before running in
Wait(20)

FadeIn( nazgrim01, 5 )

-- run to tent
RunToLocation( nazgrim01, 5, 2284.52, 921.019, 481.976, 272 )

Wait(1)

-- plant banner - NEED EMOTE HERE
-- CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )


-- tent swap
PlayOneShotSplitBodyAnim( nazgrim01, Animations.Attack1H )
Wait(0.5)
FadeIn( banner01, 0 )

FadeIn( tent04, 1 )
FadeIn( tent05, 1 )
FadeIn( tent06, 1 )
FadeOut( tent01, 0 )
FadeOut( tent02, 0 )
FadeOut( tent03, 0 )

Wait(1)

FadeOut( workDust01, 2 )
FadeOut( workDust02, 2 )
FadeOut( workDust03, 2 )
FadeOut( workDust04, 2 )
FadeOut( workDust05, 2 )
FadeOut( workDust06, 2 )

SendTrigger( \flagPlant\"" )"						
60	Kun Lai Summit - Horde Hub Swap Scene - Kiryn 01 - JSB	"
-- wait before running in
Wait(22)

FadeIn( kiryn01, 0 )

-- run into scene
RunToLocation( kiryn01, 5, 2284.09, 957.011, 481.36, 248.193 )
RunToLocation( kiryn01, 5, 2271.45, 940.75, 481.629, 300 )

-- nazgrim trigger
WaitForTrigger( \flagPlant\"" )"						
61	Global Functions - Actor Movement	"
function Actor:WaitMovementComplete()
	local waitCondition = function()
		return not self:IsMoving()
	end
	self:WaitCondition(waitCondition)
end

function Actor:WaitMoveToRel(...)
	self:MoveToRel(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveSplineRel(...)
	self:MoveSplineRel(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveToAbs(...)
	self:MoveToAbs(...)
	self:WaitMovementComplete()
end

function Actor:WaitMoveSplineAbs(...)
	self:MoveSplineAbs(...)
	self:WaitMovementComplete()
end
"	0	0				
62	Global Functions - Actor Animation	"--
-- Animation Helper Functions
--
function Actor:PlayLoopingAnimKit(animKitID)	return self:PlayAnimKit(animKitID, true, Animations.None)			end
function Actor:PlayLoopingSplitBodyAnim(anim)	return self:PlayAnimKit(AnimKits.LoopingSplitBody, false, an"	0	0				
63	PetBattle - Test Events	"
--------------------------------------------------------------------------------
-- A Random Battle To The Death
local testBattleCurrentPlayer = 1
function GenerateTestBattleEvent()

	local event = nil

	local attacker = GetActivePetByIndex(testBattleCurrentPlayer)
	local victim = GetActivePetByIndex(3-testBattleCurrentPlayer)
	local turnType
	if (victim.currentHealth <= 0) then
		-- force swap victim
		turnType = 1
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
	elseif (attacker.currentHealth <= 0) then
		-- force swap my pet (killed self somehow)
		turnType = 1
	else
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
		turnType = math.random(2)
	end

	local playerID = testBattleCurrentPlayer
	attacker = GetActivePetByIndex(playerID)
	victim = GetActivePetByIndex(3-playerID)

	if (turnType == 1) then
		local team = GetTeamByIndex(playerID)
		-- find a living pet to swap to
		local aliveBacklinePets = { }
		local numAlive = 0
		for petIndex, pet in pairs(team.pets) do
			if (petIndex ~= team.activePet) and (pet.currentHealth > 0) then
				numAlive = numAlive + 1
				aliveBacklinePets[numAlive] = petIndex
			end
		end

		if (numAlive > 0) then
			local petIndex = aliveBacklinePets[math.random(#aliveBacklinePets)]

			event =
			{
				type = PetBattleEffect.PetSwap;
				casterPlayerID = playerID;
				newFrontPet = petIndex;
			}
		end
	elseif (turnType == 2) then
		local abilityIndex = math.random(#attacker.desc.abilityIDs)
		local abilityID = attacker.desc.abilityIDs[abilityIndex]
		local usedAbilityTurnID = petAbilities[abilityID].turns[1].ID
		local abilityDamage = math.random(40,60)
		local targetHealth = victim.currentHealth - abilityDamage
		local attackerPlayerID = playerID

		event =
		{
			type = PetBattleEffect.Ability;
			casterPlayerID = attackerPlayerID;
			casterPetSlot = attacker.slot;
			abilityTurnID = usedAbilityTurnID;
			targets =
			{
				{
					playerID = 3 - attackerPlayerID;
					petSlot = victim.slot;
					newHealth = targetHealth;
				}
			};
		}
	end

	if (event) then
		scene:WaitTimer(0.25)
	end

	return event

end
"	0	0				
64	PetBattle - Effect Ability	"
--------------------------------------------------------------------------------
-- ABILITY

function EffectAbility(effect)
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, effect.abilityTurnID)
	if (not spellVisualID) then
		print(\ERROR: no spellVisual found for abilityTurn \"" .. effect.abilityTurnID)"						
66	PetBattle - Init Player	"
allPlayers = { }

function InitTeam(team)

	-- save the team
	allPlayers[#allPlayers + 1] = team

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, -idleRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\pad\"", padModel, padTransform, padScale*battleScale)"						
68	Townlong Steppes - Ring worm Intro - Camera	"
scene:WaitTimer(1)

scene:SetCamera(400,10,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(14)
scene:SetCamera(0,4,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(4)"	0	0				
69	Townlong Steppes - Ring worm Intro - Bunny 01	"
-- small tent panda 01
-- wait a little before running in
Wait(1)
FadeIn( RingWormBoss, 1 )"	0	0				
70	Kun Lai Summit - Alliance Hub Swap Scene - Init - Generic Actors 01 - JSB	"
smokeFadeOutTime = 10
throwBucketSpellID = 115882

-- Spawn all tents
smallPandaTentCreatureID = 60522
largePandaTentCreatureID = 60525
smallAllianceTentCreatureID = 60820
largeAllianceTentCreatureID = 60821
tent01 = SpawnActor( smallPandaTentCreatureID, 2152.409, 1501.663, 487.742, 268.5 ) -- PANDA small tent 01
tent02 = SpawnActor( smallPandaTentCreatureID, 2138.757, 1500.734, 487.761, 284.5 ) -- PANDA small tent 02
tent03 = SpawnActor( smallPandaTentCreatureID, 2148.100, 1435.750, 487.660, 108.5 ) -- PANDA small tent 03
tent04 = SpawnActor( largePandaTentCreatureID, 2168.000, 1472.986, 480, 211.5 ) -- PANDA Large tent
tent05 = SpawnActor( smallAllianceTentCreatureID, 2152.409, 1501.663, 487.742, 268.5 ) -- ALLIANCE small tent 01
tent06 = SpawnActor( smallAllianceTentCreatureID, 2138.757, 1500.734, 487.761, 284.5 ) -- ALLIANCE small tent 02
tent07 = SpawnActor( smallAllianceTentCreatureID, 2148.100, 1435.750, 487.660, 108.5 ) -- ALLIANCE small tent 03
tent08 = SpawnActor( largeAllianceTentCreatureID, 2168.000, 1472.986, 480, 211.5 ) -- ALLIANCE Large tent
FadeOut( tent05, 0 )
FadeOut( tent06, 0 )
FadeOut( tent07, 0 )
FadeOut( tent08, 0 )

-- Spawn all worker pandas
pandaCreatureID = 60152
panda01 = SpawnActor( pandaCreatureID, 2103.91, 1417.33, 484.7, 74.5427 )
panda02 = SpawnActor( pandaCreatureID, 2096.83, 1418.82, 483.977, 68.0177 )
panda03 = SpawnActor( pandaCreatureID, 2098.09, 1414.32, 484.135, 51.8177 )
panda04 = SpawnActor( pandaCreatureID, 2103.89, 1412.06, 484.121, 65.5426 )
panda05 = SpawnActor( pandaCreatureID, 2087.87, 1438.84, 484.083, 119.093 )
panda06 = SpawnActor( pandaCreatureID, 2099.66, 1417.14, 484.388, 53.8431 )
FadeOut( panda01, 0 )
FadeOut( panda02, 0 )
FadeOut( panda03, 0 )
FadeOut( panda04, 0 )
FadeOut( panda05, 0 )
FadeOut( panda06, 0 )

-- Spawn all the fires to be put out
-- SpawnFire( x, y, z, scale )
fire01 = SpawnFire( 2159.96, 1476.05, 487.886, 3 ) -- Large panda tent, 3x fire
fire02 = SpawnFire( 2168.71, 1476.88, 487.886, 3 ) -- Large panda tent, 3x fire
fire03 = SpawnFire( 2110.28, 1485.25, 487.913, 3 ) -- Near Tower, 3x fire
fire04 = SpawnFire( 2122.64, 1493.68, 515.617, 3 ) -- Tower, 3x fire
fire05 = SpawnFire( 2125.73, 1490.26, 509.835, 1 ) -- Tower, 1x fire
fire06 = SpawnFire( 2122.71, 1496.35, 501.108, 1 ) -- Tower, 1x fire
fire07 = SpawnFire( 2124.03, 1491.26, 488.064, 1 ) -- Tower, 1x fire
fire08 = SpawnFire( 2143.5, 1508.59, 487.921, 1 ) -- Small Tents, 1x fire
fire09 = SpawnFire( 2138.67, 1499.58, 493.044, 1 ) -- Small Tents, 1x fire 
fire10 = SpawnFire( 2150.04, 1498.04, 490.246, 1 ) -- Small Tents, 1x fire 
fire11 = SpawnFire( 2120.79, 1483.48, 497.618, 1 ) -- Tower, 1x fire
fire12 = SpawnFire( 2176.27, 1470.22, 487.886, 1 ) -- Large panda tent, 1x fire
fire13 = SpawnFire( 2101.56, 1457.59, 487.886, 1 ) -- Banners, 1x fire
fire14 = SpawnFire( 2147.09, 1439, 487.886, 1 ) -- Small Tent, 1x fire
fire15 = SpawnFire( 2124.7, 1434.41, 490.16, 0.5 ) -- Banner, 0.5x fire
fire16 = SpawnFire( 2143.98, 1427.61, 487.886, 0.5 ) -- Small Tent, 0.5x fire
fire17 = SpawnFire( 2140.25, 1436.31, 488.941, 0.5 ) -- Small Tent, 0.5x fire
fire18 = SpawnFire( 2136.92, 1450.06, 488.658, 0.5 ) -- Bonfire, 0.5x fire
fire19 = SpawnFire( 2136.95, 1425.65, 487.886, 0.5 ) -- Banner, 0.5x fire
fire20 = SpawnFire( 2158.72, 1435.44, 489.272, 0.5 ) -- Small Tent, 0.5x fire
fire21 = SpawnFire( 2163.96, 1437.02, 489.037, 0.5 ) -- Small Tent, 0.5x fire
fire22 = SpawnFire( 2177.94, 1444.31, 487.903, 0.5 ) -- Small Tent, 0.5x fire
fire23 = SpawnFire( 2154.34, 1464.3, 509.851, 0.5 ) -- Large panda tent, 0.5x fire

"	0	0				
71	Kun Lai Summit - Alliance Hub Swap Scene - Init - Generic Actors 02 - JSB	"
-- Spawn Dust Clouds
workDustModel = \spells\\xplosion_dust_impact_noflash.m2\"""						
72	Kun Lai Summit - Alliance Hub Swap Scene - Init - Named Actors - JSB	"
-- Spawn all actors
taylorCreatureID = 60828
mishkaCreatureID = 60829
sullyCreatureID = 60861
bannerCreatureID = 60830
taylor01 = SpawnActor( taylorCreatureID, 2096.16, 1417.78, 483.821, 58 ) -- Taylor
mishka01 = SpawnActor( mishkaCreatureID, 2106.12, 1417.89, 484.903, 58 ) -- Mishka
sully01 = SpawnActor( sullyCreatureID, 2108.15, 1429.34, 486.384, 58 ) -- Sully
banner01 = SpawnActor( bannerCreatureID, 2144.02, 1472.73, 487.886, 214 ) -- Banner

-- Initial fade
FadeOut( taylor01, 0 )
FadeOut( mishka01, 0 )
FadeOut( sully01, 0 )
FadeOut( banner01, 0 )"	0	0				
73	Kun Lai Summit - Alliance Hub Swap Scene - Master Script - JSB	"
scene:WaitTimer(2)

scene:SetCamera(314,0,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:SetCamera(315,26,nil,nil)
-- left off here
scene:WaitTimer(18) --was 28
scene:SetCamera(326,25,nil,nil)

scene:WaitTimer(18) --was 28

scene:SetCamera(327,10,nil,nil)

scene:WaitTimer(10)

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0				
74	Kun Lai Summit - Alliance Hub Swap Scene - Worker 01 - JSB	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( panda01, 1 )

-- run to the tents
RunToLocation( panda01, 5.5, 2124.77, 1439.72, 487.887, 13.4 )
RunToLocation( panda01, 5.5, 2142.83, 1443.31, 487.887, 311.3 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda01, fire14.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire14 )
PutOutFire( fire16 )
PutOutFire( fire17 )
PutOutFire( fire20 )
PutOutFire( fire21 )
PutOutFire( fire22 )
PutOutFire( fire18 )
PutOutFire( fire19 )

Wait(1)

RunToLocation( panda01, 3, 2142.27, 1441.6, 487.886, 319.625 )

PlayLoopingSplitBodyAnim( panda01, Animations.EmoteWork )

Wait(2)

FadeOut( fire14.smoke )
FadeOut( fire16.smoke )
FadeOut( fire17.smoke )
FadeOut( fire20.smoke )
FadeOut( fire21.smoke )
FadeOut( fire22.smoke )
FadeOut( fire18.smoke )
FadeOut( fire19.smoke )

Wait(1)

FadeIn( workDust01, 5 )

-- taylor trigger
WaitForTrigger( \flagPlant\"" )"						
75	Kun Lai Summit - Alliance Hub Swap Scene - Worker 02 - JSB	"
-- small tents panda 02
-- wait a little before running in
Wait(1)
FadeIn( panda02, 1 )

-- run to the tents
-- RunToLocation( panda02, 5.5, 2129.01, 1466.96, 487.886, 47.8317 )
RunToLocation( panda02, 5.5, 2152.03, 1484.51, 487.886, 91.0317 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda02, fire10.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire09, smokeFadeOutTime )
PutOutFire( fire08, smokeFadeOutTime )
PutOutFire( fire10, smokeFadeOutTime )

Wait(1)

RunToLocation( panda02, 3, 2149.38, 1493.51, 487.886, 86.5315 )

PlayLoopingSplitBodyAnim( panda02, Animations.EmoteWork )

Wait(2)

FadeOut( fire09.smoke )
FadeOut( fire08.smoke )
FadeOut( fire10.smoke )

Wait(1)

FadeIn( workDust02, 5 )
FadeIn( workDust04, 5 )
FadeIn( workDust05, 5 )


WaitForTrigger( \flagPlant\"" )"						
76	Kun Lai Summit - Alliance Hub Swap Scene - Worker 03 - JSB	"
-- tower fire panda
-- wait a little before running in
Wait(3)
FadeIn( panda03, 1 )

-- run to the tents
RunToLocation( panda03, 5.5, 2119.68, 1473.66, 487.886, 98.231 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda03, fire03.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire03, smokeFadeOutTime )
PutOutFire( fire05, smokeFadeOutTime )
PutOutFire( fire06, smokeFadeOutTime )
PutOutFire( fire04, smokeFadeOutTime )
PutOutFire( fire11, smokeFadeOutTime )
PutOutFire( fire07, smokeFadeOutTime )

Wait(1)

RunToLocation( panda03, 3, 2148.77, 1477.56, 487.887, 339.207 )

PlayLoopingSplitBodyAnim( panda03, Animations.EmoteWork )

-- Wait(2)

FadeOut( fire03.smoke )
FadeOut( fire05.smoke )
FadeOut( fire06.smoke )
FadeOut( fire04.smoke )
FadeOut( fire11.smoke )
FadeOut( fire07.smoke )

FadeIn( workDust03, 5 )

-- nazgrim trigger
WaitForTrigger( \flagPlant\"" )"						
77	Kun Lai Summit - Alliance Hub Swap Scene - Worker 04 - JSB	"
-- banner panda
-- wait a little before running in
Wait(10)
FadeIn( panda04, 1 )

-- run to north post
RunToLocation( panda04, 5.5, 2099.62, 1447.23, 487.911, 69.189 )


Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda04, fire13.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire13, smokeFadeOutTime )
PutOutFire( fire15, smokeFadeOutTime )

Wait(1)

RunToLocation( panda04, 5, 2098.87, 1447.92, 487.936, 123.639 )

PlayLoopingSplitBodyAnim( panda04, Animations.EmoteWork )

Wait(2)

FadeOut( fire13.smoke )
FadeOut( fire15.smoke )"	0	0				
78	Kun Lai Summit - Alliance Hub Swap Scene - Worker 05 - JSB	"
-- large tent panda
-- wait a little before running in
Wait(3)
FadeIn( panda05, 1 )

-- run to the tents
-- RunToLocation( panda05, 5.5, 2134.59, 1451.11, 487.886, 34.7651 )
RunToLocation( panda05, 5.5, 2152.82, 1462.71, 487.886, 30.484 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda05, fire01.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(3.5)
PutOutFire( fire01, smokeFadeOutTime )
PutOutFire( fire02, smokeFadeOutTime )
PutOutFire( fire12, smokeFadeOutTime )
PutOutFire( fire23, smokeFadeOutTime )

Wait(1)

RunToLocation( panda05, 3,  2159.28, 1460.91, 487.886, 5.73899 )

PlayLoopingSplitBodyAnim( panda05, Animations.EmoteWork )

Wait(2)

FadeOut( fire01.smoke )
FadeOut( fire02.smoke )
FadeOut( fire12.smoke )
FadeOut( fire23.smoke )

-- Wait(1)

FadeIn( workDust06, 5 )

WaitForTrigger( \flagPlant\"" )"						
80	Kun Lai Summit - Alliance Hub Swap Scene - Taylor 01 - JSB	"

-- wait before running in
Wait(20)

FadeIn( taylor01, 5 )

-- run to tent
RunToLocation( taylor01, 5,  2141.59, 1470.78, 487.886, 44 )

Wait(1)

-- plant banner - NEED EMOTE HERE
-- CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )


-- tent swap
PlayOneShotSplitBodyAnim( taylor01, Animations.Attack1H )
Wait(0.5)
FadeIn( banner01, 0 )

FadeIn( tent05, 0 )
FadeIn( tent06, 0 )
FadeIn( tent07, 0 )
FadeIn( tent08, 0 )
FadeOut( tent01, 0 )
FadeOut( tent02, 0 )
FadeOut( tent03, 0 )
FadeOut( tent04, 0 )

Wait(1)

FadeOut( workDust01, 2 )
FadeOut( workDust02, 2 )
FadeOut( workDust03, 2 )
FadeOut( workDust04, 2 )
FadeOut( workDust05, 2 )
FadeOut( workDust06, 2 )

SendTrigger( \flagPlant\"" )"						
82	Kun Lai Summit - Alliance Hub Swap Scene - Sully 01 - JSB	"
-- wait before running in
Wait(24)

FadeIn( sully01, 0 )

-- run into scene
RunToLocation( sully01, 5, 2117.5, 1443.63, 487.887, 30.1199 )
RunToLocation( sully01, 3, 2136.57, 1454.03, 487.886, 13.4693 )

-- taylor trigger
WaitForTrigger( \flagPlant\"" )"						
85	PetBattle - Constants	"--------------------------------------------------------------------------------
-- event types
PetBattleEvent = 
{
	RoundEffect = 0;
	RoundComplete = 1;
	BattleOver = 2;
	ObserverChange = 3;
}

--------------------------------------------------"						
87	PetBattle - Effect Aura Remove	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraRemove(effect)

	local casterPlayerID = effect.casterPlayerID
	local casterPetSlot = effect.casterPetSlot

	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterPet = casterPlayer.pets[casterPetSlot]

	if not casterPet then
		return
	end

	RemoveAura(casterPet, effect.auraInstanceID)

end

--------------------------------------------------------------------------------
function RemoveAura(pet, auraInstanceID)

	RemoveAuraVisual(pet, pet.auras[auraInstanceID])
	pet.auras[auraInstanceID] = nil

end

--------------------------------------------------------------------------------
function RemoveAuraVisual(pet, aura)

	if aura and aura.spellVisualInstanceID then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		aura.spellVisualInstanceID = nil
	end

end

--------------------------------------------------------------------------------
function RemoveAllAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		RemoveAuraVisual(pet, aura)
	end

end
"	0	0				
92	Kun Lai Summit - Reclaiming the Thunder God - Init - Generic Actors 01 - JSB	"
-- Spawn Clone
playerCloneCreatureID = 61079
playerClone01 = SpawnActor( playerCloneCreatureID, 3630.21, 1780.71, 742.973, 221.07 ) -- player clone
FadeOut( playerClone01, 0 )

-- Spawn Mogu Door
moguDoorCreatureID = 61129
moguDoor01 = SpawnActor( moguDoorCreatureID, 3674.03, 1657.67, 742.974, 353 ) -- mogu door

-- Spawn Priest
trollPriestCreatureID = 61075
trollPriest01 = SpawnActor( trollPriestCreatureID, 3605.16, 1622.07, 742.666, 85.6491 ) -- troll priest
FadeOut( trollPriest01, 0 )

-- Spawn PriestGrunt 01
-- trollGruntACreatureID = 61148
-- trollPriestGrunt01 = SpawnActor( trollGruntACreatureID, 3606.02, 1600, 742.973, 81.5797 ) -- troll priest grunt a
-- FadeOut( trollPriestGrunt01, 0 )

-- Spawn PriestGrunt 02
-- trollGruntBCreatureID = 61149
-- trollPriestGrunt02 = SpawnActor( trollGruntBCreatureID, 3599.39, 1600, 742.973, 81.5797 ) -- troll priest grunt b
-- FadeOut( trollPriestGrunt02, 0 )

-- Spawn Grunts

-- Spawn Grunt 01
trollGruntCreatureID = 61074

trollGrunt01 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt02 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt03 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt04 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt05 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt06 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt07 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt08 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
trollGrunt09 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )

"	0	0				
93	Kun Lai Summit - Reclaiming the Thunder God - Init - Generic Actors 02 - JSB	"
-- Spawn Fire Wall
-- fireWallModel = \WORLD\\EXPANSION03\\DOODADS\\GRIMBATOLRAID\\GrimBatolRaid_Fire_Wall_01.M2\"""						
95	Kun Lai Summit - Reclaiming the Thunder God - Master Script - JSB	"
scene:WaitTimer(1)

scene:SetCamera(345,4,nil,nil) -- (camera, transition time, primary target, secondary target)


scene:WaitTimer(2)

scene:SetCamera(346,3,nil,nil)

scene:WaitTimer(2)

scene:SetCamera(347,2.2,nil,nil) -- down the hall

scene:WaitTimer(1.2)

scene:SetCamera(337,4,nil,nil) -- turn
scene:WaitTimer(1.5) -- wait for doors to open

scene:SetCamera(338,15,nil,nil)

scene:WaitTimer(5.5) 
scene:SetCamera(339,5,nil,nil)

scene:WaitTimer(2) 

scene:SetCamera(340,6,nil,nil) -- look at thunder king

scene:WaitTimer(5)

scene:SetCamera(338,2.5,nil,nil) -- backing up

scene:WaitTimer(1)

SendTrigger( \cloneTrigger\"" )"						
117	Kun Lai Summit - Reclaiming the Thunder God - Troll Priest 01 - JSB	"-- clone trigger
WaitForTrigger( \cloneTrigger\"" )"						
120	Kun Lai Summit - Reclaiming the Thunder God - Grunt 01 - JSB	"-- path 01
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
121	Kun Lai Summit - Resurrecting the Thunder God - Master Script - JSB	"
scene:WaitTimer(1)

scene:SetCamera(359,3,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(348,5,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(349,5,nil,nil)
scene:WaitTimer(2)

scene:SetCamera(350,5,nil,nil) -- aiming at island
scene:WaitTimer(1.5)

scene:SetCamera(351,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(352,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(353,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(354,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(358,5,nil,nil)
scene:WaitTimer(1.5)

scene:SetCamera(355,6,nil,nil)
scene:WaitTimer(2.5)

scene:SetCamera(356,16,nil,nil)
scene:WaitTimer(14)

scene:SetCamera(357,26,nil,nil)
scene:WaitTimer(23)

scene:SetCamera(0,0,nil,nil)
"	0	0				
122	Kun Lai Summit - Resurrecting the Thunder God - Init - Generic Actors 01 - JSB	"
-- Spawn Priest
trollUnderlingCreatureID = 61309
trollGuard01CreatureID = 61292
trollGuard02CreatureID = 61300
trollGuard03CreatureID = 61301
moguGuardCreatureID = 61304
trollPriestCreatureID = 61310

-- Spawn Underlings
trollUnderling01 = SpawnActor( trollUnderlingCreatureID, 4931.42, 66.8542, 6.84169, 25 ) -- first drum
trollUnderling02 = SpawnActor( trollUnderlingCreatureID, 4928.74, 22.5174, 1.05685, 317.344 )
trollUnderling03 = SpawnActor( trollUnderlingCreatureID, 5103.04, 25.6123, 6.4546, 287.645 )
trollUnderling04 = SpawnActor( trollUnderlingCreatureID, 5102.15, 18.2928, 5.92104, 54.319 )
trollUnderling05 = SpawnActor( trollUnderlingCreatureID, 5171.84, 15.3511, 12.9757, 104.494 )
trollUnderling06 = SpawnActor( trollUnderlingCreatureID, 5242.5, 44.022, 31.9608, 279.659 ) -- scene drum right
trollUnderling07 = SpawnActor( trollUnderlingCreatureID, 5250.12, 70.2691, 31.9608, 60.0603 ) -- scene drum left
trollUnderling08 = SpawnActor( trollUnderlingCreatureID, 4840.43, 39.5383, 2.19625, 292.79 ) -- kneeling
trollUnderling09 = SpawnActor( trollUnderlingCreatureID, 4832.77, 33.9119, 1.61703, 227.54 ) -- reading
trollUnderling10 = SpawnActor( trollUnderlingCreatureID, 4814.25, 65.1461, 3.15087, 56.99 ) -- working
trollUnderling11 = SpawnActor( trollUnderlingCreatureID, 5251.9, 66.0285, 31.9608, 24.2841 ) -- scene drum middle

-- Spawn Mogu
moguGuard01 = SpawnActor( moguGuardCreatureID, 5153.18, 87.0011, 13.2936, 152.085 ) -- base of stairs 01
moguGuard02 = SpawnActor( moguGuardCreatureID, 5167.13, 104.879, 15.1742, 144.21 ) -- base of stairs 02
moguGuard03 = SpawnActor( moguGuardCreatureID, 4883.96, 46.1186, 6.17683, 168.735 )
moguGuard04 = SpawnActor( moguGuardCreatureID, 4856.31, 63.453, 5.6103, 216.21 )

-- Spawn Troll Guards
trollGuard01 = SpawnActor( trollGuard01CreatureID, 4949.93, 50.9107, 1.9036, 187.411 ) -- first patroller




-- Spawn Grunt 01
-- trollGruntCreatureID = 61074

-- trollGrunt01 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt02 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt03 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt04 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt05 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt06 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt07 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt08 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )
-- trollGrunt09 = SpawnActor( trollGruntCreatureID, 3611.88, 1560.07, 757.963, 186.491 )

"	0	0				
123	Kun Lai Summit - Resurrecting the Thunder God - Troll Patroller 01	"
Wait(3)

RunToLocation( trollGuard01, 4, 4905.35, 48.013, 3.56636, 151.861 )
RunToLocation( trollGuard01, 4, 4885.88, 56.5586, 4.25848, 156.811 )"	0	0				
124	Kun Lai Summit - Resurrecting the Thunder God - Trolls at Dock	"
PlayLoopingSplitBodyAnim( trollUnderling08, Animations.KneelLoop )
PlayLoopingSplitBodyAnim( trollUnderling09, Animations.EmoteReadLoop )
PlayLoopingSplitBodyAnim( trollUnderling10, Animations.EmoteWork )

-- trollUnderling08 =  -- kneeling
-- trollUnderling09 =  -- reading
-- trollUnderling10 = -- working"	0	0				
125	Kun Lai Summit - Resurrecting the Thunder God - Troll Drummers	"
PlayLoopingSplitBodyAnim( trollUnderling01, Animations.Attack1H )
PlayLoopingSplitBodyAnim( trollUnderling06, Animations.Attack1H )
PlayLoopingSplitBodyAnim( trollUnderling07, Animations.Attack1H )

scene:WaitTimer(0.5)

PlayLoopingSplitBodyAnim( trollUnderling11, Animations.Attack1H )"	0	0				
126	Kun Lai Summit - Reclaiming the Thunder God - Grunt 02 - JSB	"-- path 02
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
127	Kun Lai Summit - Reclaiming the Thunder God - Grunt 03 - JSB	"-- path 03
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
128	Kun Lai Summit - Reclaiming the Thunder God - Grunt 04 - JSB	"-- path 04
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
129	Kun Lai Summit - Reclaiming the Thunder God - Grunt 09 - JSB	"-- path 09
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
130	Kun Lai Summit - Reclaiming the Thunder God - Grunt 08 - JSB	"-- path 08
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
131	Kun Lai Summit - Reclaiming the Thunder God - Grunt 07 - JSB	"-- path 07
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
132	Kun Lai Summit - Reclaiming the Thunder God - Grunt 06 - JSB	"-- path 06
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
133	Kun Lai Summit - Reclaiming the Thunder God - Grunt 05 - JSB	"-- path 05
-- priest trigger
WaitForTrigger( \priestTrigger\"" )"						
134	Test - Alex\'s Battle Pet - Init Library	"--- Pad Setup
-- pad: temp
--padModel = \world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"""						
135	Test - Alex\'s Battle Pet - Camera Mode Library	"-- Manual Target

local camModel = \world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"";"						
136	Test - Alex\'s Battle Pet - Setup Team Actors	"function SetupTeamActors()

	local radius = 2
	local facing = 0

	home1 = Vector:New( radius*battleScale, 0, 0)
	home2 = Vector:New(-radius*battleScale, 0, 0)

	homeTransform1 = Transform:New(home1, 180)
	homeTransform2 = Transform:New(home2, 0)


	-- Camera Targets
	pad1 = DoPadInit(homeTransform1);
	pad2 = DoPadInit(homeTransform2);


	master1Loc = Vector:New( 6, -6, 3);
	master1Transform = Transform:New(master1Loc, 180);
	
	master1 = scene:SpawnActor(ActorCreateData:New(55242, master1Transform, battleScale) );
	master1:SetFacingToAbs(Vector:New());

	master1petloc = home1;

	local master1frontVector = UnitVectorFromAtoB(master1Loc, Vector:New());
	local master1upVector = UnitVectorFromAtoB(master1Loc, VectorSum(master1Loc, Vector:New(0,0,1) ) );
	local master1leftVector = UnitVectorCrossProduct(master1frontVector, master1upVector);

	master1backpet1loc = master1Loc  + master1leftVector *  2  + master1frontVector*-1;
	master1backpet2loc = master1Loc  + master1leftVector * -2  + master1frontVector*-1;

	-- Pet Loc
	master1pet = scene:SpawnActor(ActorCreateData:New(40295, homeTransform1, battleScale))

	-- Armadillo
	master1backupPet1 = scene:SpawnActor(ActorCreateData:New(48242, Transform:New(master1backpet1loc,0), battleScale));
	master1backupPet1:SetFacingToTarget(master1pet, Vector:New())
	-- Parrot
	master1backupPet2 = scene:SpawnActor(ActorCreateData:New(11236, Transform:New(master1backpet2loc,0), battleScale));
	master1backupPet2:SetFacingToTarget(master1pet, Vector:New())

	-- Set the home point
	current1 = VectorCopy(master1pet:GetPosition());

	master2Loc = Vector:New( -6, 6, 3);
	master2Transform = Transform:New(master2Loc, 0);

	master2 = scene:SpawnActor(ActorCreateData:New(53828, master2Transform, battleScale/3) );
	master2:SetFacingToAbs(Vector:New());

	master2petloc = home2;


	local master2frontVector = UnitVectorFromAtoB(master1Loc, Vector:New());
	local master2upVector = UnitVectorFromAtoB(master1Loc, VectorSum(master1Loc, Vector:New(0,0,1) ) );
	local master2leftVector = UnitVectorCrossProduct(master1frontVector, master1upVector);

	master2backpet1loc = master2Loc  + master1leftVector *  2  + master2frontVector*-1;
	master2backpet2loc = master2Loc  + master1leftVector * -2  + master2frontVector*-1;


	-- Pet Loc
	master2pet = scene:SpawnActor(ActorCreateData:New(45340, homeTransform2, battleScale))

	-- Frog
	master2backupPet1 = scene:SpawnActor(ActorCreateData:New(14878, Transform:New(master2backpet1loc,0), battleScale));
	master2backupPet1:SetFacingToTarget(master2pet, Vector:New())

	-- Croc
	master2backupPet2 = scene:SpawnActor(ActorCreateData:New(24388, Transform:New(master2backpet2loc,0), battleScale));
	master2backupPet2:SetFacingToTarget(master2pet, Vector:New())

	-- Set the home point
	current2 = VectorCopy(master2pet:GetPosition());

end"	0	0				
138	Test - Alex\'s Battle Pet - Move Library 4	"-- Earthen explosion
function PerformRuptureLine (pet, opponent, damage ) 

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition() , opponentLocation );
	local upVector = UnitVectorFrom"						
139	Test - Alex\'s Battle Pet - Move Library 5	"function BuildKnockbackSpline(pet, petFinalPoint, duration)
	local gravity = -9.8; -- M / sec / sec
	local points = 10;  

	local dx = petFinalPoint.x - pet.actor:GetPosition().x;
	local dy = petFinalPoint.y - pet.actor:GetPosition().y;
	local xVelocity = dx / duration;  -- M / sec
	local yVelocity = dy / duration;  -- M / sec

	local zVelocity = ( gravity * duration * duration ) * -2;

	local list = {};
	local timeStep = duration / points

	for i=0, points do 
		local time = timeStep * i; 
		local x = time * xVelocity;
		local y = time * yVelocity;
		local u = gravity*time*time + zVelocity*time;
--print(\t: \"",time,\"" x: \"",x,\""u: \"",u);"						
140			0	0				
142	Test - Alex\'s Battle Pet - ProcessEffect	"function ProcessEffect(effect)
	if ( not effect ) then 
		return;
	end

	if ( effect.type == PetBattleEffect.PetSwap	) then

		print(\Process SWAP\"");"						
144	PetBattle - Cameras	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 3.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.5, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0				
145	Test - Alex\'s Battle Pet - Move Library 6	"
function PerformWaveAttack(pet, opponent, damage)
	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(pet.actor:GetPosition(), opponentLocation  );
	local upVector = UnitVectorFromAtoB(pet.actor:GetPosition(), (pet.actor:GetPosition() + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

print(\wave\"");"						
149	Jade Forest - Fresco Scene - Master Script - JSB	"
-- scene:WaitTimer(2)

scene:SetCamera(363,7,nil,nil) -- (camera, transition time, primary target, secondary target)


scene:WaitTimer(10) 


scene:SetCamera(364,7,nil,nil) 

scene:WaitTimer(5) 

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0				
150	Jade Forest - Horde Intro Scene - Master - JSB	"
local sceneOrigin = scene:GetPosition()
scene:SetCamera(0, 0.0, nil, nil)

Wait(1.0)

-- initial pan
-- scene:SetCamera(365, 0.0, nil, nil)

--CameraPosFollowPath( 370, 3095, 10 )
--CameraTgtFollowPath( 370, 3096, 10 )
SetCameraFollowPath( 370, 0.0, 3095, 3096, 15 )

local shakeY
local shakeZ
if Scene.AddCameraShake then
	shakeY = scene:AddCameraShake(203, sceneOrigin)
	shakeZ = scene:AddCameraShake(204, sceneOrigin)
end


--scene:SetCamera(366, 15.0, nil, nil)
Wait(8)
SendTrigger( \gorrokMove\"" )"						
151	Jade Forest - Horde Intro Scene - Zeppelin - JSB	"
-- PlayLoopingSplitBodyAnim( zeppelin, Animations.ShipMoving )

zeppelin:PlayLoopingAnimKit(2272)


zeppelinDest = Vector:New(3292.78, -337.059, 266.204)
zeppelinMoveSpeed = 6
zeppelinSrc = zeppelin:GetPosition()
zeppelinMoveOffset = zeppelinDest - zeppelinSrc

-- force the ship to face a direction
zeppelin:SetFacingToAbs(Vector:New(3969.94, -99.27, 259.995))

WaitForTrigger( \zeppelinMove\"" )"						
152	Jade Forest - Horde Intro Scene - Init - JSB	"
-- spawn zeppelin
local zeppelinModel = \world\\expansion03\\doodads\\generic\\flying_horde_zeppelin.m2\"""						
155	Cinematic Framework - Camera	"
--
-- Internal variables
--
local cameraDummyDefaultPos = scene:GetPosition()
local cameraDummyModel = \creature\\invisiblestalker\\invisiblestalker.m2\"""						
162	PetBattle - Prototype 2.0 - Init Player	"
allPlayers = { }

function InitTeam(team)

	-- save the team
	allPlayers[#allPlayers + 1] = team

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, -idleRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\pad\"", padModel, padTransform, padScale*battleScale)"						
165	PetBattle - Prototype 2.0 - Effect Swap	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local "	0	0				
166	PetBattle - Prototype 2.0 - Effect Set Health	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisualID = effect.abilityVisualID
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\WARNING: no abilityVisual for SetHealth\"")"						
170	PetBattle - Prototype 2.0 - Test Events	"
--------------------------------------------------------------------------------
-- A Random Battle To The Death
local testBattleCurrentPlayer = 1
function GenerateTestBattleEvent()

	local event = nil

	local attacker = GetActivePetByIndex(testBattleCurrentPlayer)
	local victim = GetActivePetByIndex(3-testBattleCurrentPlayer)
	local turnType
	if (victim.currentHealth <= 0) then
		-- force swap victim
		turnType = 1
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
	elseif (attacker.currentHealth <= 0) then
		-- force swap my pet (killed self somehow)
		turnType = 1
	else
		testBattleCurrentPlayer = 3 - testBattleCurrentPlayer
		turnType = math.random(2)
	end

	local playerID = testBattleCurrentPlayer
	attacker = GetActivePetByIndex(playerID)
	victim = GetActivePetByIndex(3-playerID)

	if (turnType == 1) then
		local team = GetTeamByIndex(playerID)
		-- find a living pet to swap to
		local aliveBacklinePets = { }
		local numAlive = 0
		for petIndex, pet in pairs(team.pets) do
			if (petIndex ~= team.activePet) and (pet.currentHealth > 0) then
				numAlive = numAlive + 1
				aliveBacklinePets[numAlive] = petIndex
			end
		end

		if (numAlive > 0) then
			local petIndex = aliveBacklinePets[math.random(#aliveBacklinePets)]

			event =
			{
				type = PetBattleEffect.PetSwap;
				casterPlayerID = playerID;
				newFrontPet = petIndex;
			}
		end
	elseif (turnType == 2) then
		local abilityIndex = math.random(#attacker.desc.abilityIDs)
		local abilityID = attacker.desc.abilityIDs[abilityIndex]
		local usedAbilityTurnID = petAbilities[abilityID].turns[1].ID
		local abilityDamage = math.random(40,60)
		local targetHealth = victim.currentHealth - abilityDamage
		local attackerPlayerID = playerID

		event =
		{
			type = PetBattleEffect.Ability;
			casterPlayerID = attackerPlayerID;
			casterPetSlot = attacker.slot;
			abilityTurnID = usedAbilityTurnID;
			targets =
			{
				{
					playerID = 3 - attackerPlayerID;
					petSlot = victim.slot;
					newHealth = targetHealth;
				}
			};
		}
	end

	if (event) then
		scene:WaitTimer(0.25)
	end

	return event

end
"	0	0				
171	PetBattle - Prototype 2.0 - Cameras	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

function SetCamera(camera)
	if ( not isObserved ) then
		return
	end

	local observedTeam = teams[observingPlayerIndex]
	local otherTeam = teams[3 - observingPlayerIndex]

	if ( camera == 1 ) then 
		scene:SetCamera(battleCameraIDs.intro, 3.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 2 ) then 
		scene:SetCamera(battleCameraIDs.idle, 2.5, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 3 ) then 
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad, otherTeam.pad)
	elseif ( camera == 4 ) then
		scene:SetCamera(0, 0.75, nil, nil)
	end
end"	0	0				
172	PetBattle - Prototype 2.0 - Intro	"
--------------------------------------------------------------------------------
function BattleIntro()

	SetCamera(1)
	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	scene:WaitTimer(0.25)
	SetCamera(2)
	scene:WaitTimer(0.75)
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0				
173	PetBattle - Prototype 2.0 - Main	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
else
	-- no battle scene implies a manually created test battle
	isObserved = true
	observingPlayerIndex = 1
end

--------------------------------------------------------------------------------
-- see if we\'re using test teams
if (battleScene and battleScene:UseTestPlayerData() == true) or (not initialBattleState) then
	initialBattleState = InitTestTeams()
end

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
if (isObserved == true) then
	-- backwards compatibility
	initialBattleState.players[observingPlayerIndex].teamFacing = 0
	initialBattleState.players[3-observingPlayerIndex].teamFacing = 180
else
	initialBattleState.players[1].teamFacing = 0
	initialBattleState.players[2].teamFacing = 180
end

teams = { initialBattleState.players[1], initialBattleState.players[2] }
InitTeam(teams[1])
InitTeam(teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		SetCamera(3)
	end

	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local effect = nil
	if (battleScene:IsTestBattle() == true) then
		effect = GenerateTestBattleEvent()
		if (not effect) then
			scene:WaitTimer(0)
		end
	else
		-- poll for round effects
		local waitForEffects = function()
			return battleScene:HasPendingEffects()
		end
		scene:WaitCondition(waitForEffects)
		effect = battleScene:GetPendingEffect()
	end

	inBattle, winnerID = ProcessEffect(effect)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if winnerTeam.activePet ~= petIndex and pet.currentHealth > 0 then
			-- move backline up to celebrate
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	SetCamera(4);
end

scene:WaitTimer(0.75)
battleScene:SignalBattleComplete()
"	0	0				
189	Jade Forest - Horde Intro Scene - Alliance Captain - JSB	"allianceCaptain:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCaptain -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
191	Jade Forest - Horde Intro Scene - Gorrok - JSB	"
WaitForTrigger( \gorrokMove\"" )"						
197	Lorewalker Story - S1: Grummle - Trogg01 - ZTO	"-- Wandering Trogg
-- meander around
WaitForTrigger( \Spawn Troggs\"" )"						
198	Lorewalker Story - S1: Grummle - Trogg02 - ZTO	"-- Wandering Trogg
-- meander around
WaitForTrigger( \Spawn Troggs\"" )"						
199	Lorewalker Story - S1: Grummle - Trogg03 - ZTO	"-- Wandering Trogg
-- meander around
WaitForTrigger( \Spawn Troggs\"" )"						
200	Lorewalker Story - S1: Grummle - TroggMain - ZTO	"-- Wandering Trogg
-- meander around
WaitForTrigger( \Spawn Troggs\"" )"						
201	Lorewalker Story - S1: Grummle - MoguMain - ZTO	"-- Mogu enters stage right
-- cross to slightly center stage right
WaitForTrigger( \Spawn Mogu\"" )"						
202	Lorewalker Story - S1: Grummle - MoguGrunt01 - ZTO	"-- MoguGrunts enter stage right
-- Remain at attention
WaitForTrigger(\Spawn Mogu\"")"						
203	Lorewalker Story - S1: Grummle - MoguGrunt02 - ZTO	"-- MoguGrunts enter stage right
-- Remain at attention
WaitForTrigger(\Spawn Mogu\"")"						
205	Stormwind - Varian Gets Punched - Master - PRK	"scene:SetCamera(376, 0.5, nil, nil)

Wait(5.0)

scene:SetCamera(377, 0, nil, nil)

Wait(3.0)

scene:SetCamera(378, 0, nil, nil)

Wait(3.0)

scene:SetCamera(0, 1, nil, nil) -- sets camera back to game-cam"	0	0				
206	Jade Forest - Horde Intro Scene - Snuff - JSB	"
WaitForTrigger( \rivettTalk\"" )"						
207	Lorewalker Story - S1: Grummle - GrummleMain - ZTO	"-- Grummle spawns where trogg got tacknuked
WaitForTrigger( \grummleTransform\"" )"						
209	Lorewalker Story - S1: Grummle - Init - Scene 2 Actors - ZTO	"-- Spawn Pack 1 group
pandarenSlaveID = 61904
--pandarenSlave01 = SpawnActor(pandarenSlaveID, 1448.95, 358.934, 550.222, 268.352 ) -- Pandaren Slave
--moguSlaver01 = SpawnActor(moguGruntID, 1450.02, 356.149, 550.222, 90.8269 ) -- Mogu Slaver
--FadeOut"	0	0				
210	Lorewalker Story - S1: Grummle - Scene 2 - pandarenSlave01 - ZTO	"-- Wait until scene 2 begins
-- pandarenSlave01: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
-- pandarenSlave01: PlayLoopingAnimKit( 2312 )

-- WaitForTrigger(\scene2Trigger\"")"						
211	Lorewalker Story - S1: Grummle - Scene 2 - moguSlaver01 - ZTO	"-- Wait until scene 2 begins
-- moguSlaver01: SetFacingToAbs(Vector:New(1448.66, 601.672, 550.222)) 
-- moguSlaver01:PlayLoopingFullBodyAnim(Animations.EmoteLaugh)

-- WaitForTrigger(\scene2Trigger\"")"						
212	Lorewalker Story - S1: Grummle - Scene 3 - pandarenSlave02 - ZTO	"-- Wait until scene 3 begins
--pandarenSlave02: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
pandarenSlave02: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\scene3Trigger\"")"						
213	Lorewalker Story - S1: Grummle - Scene 3 - pandarenSlave03 - ZTO	"-- Wait until scene 3 begins
--pandarenSlave03: SetFacingToAbs(Vector:New(1739.47, 358.197, 550.222)) 
Wait (1)
pandarenSlave03: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\scene3Trigger\"")"						
214	Lorewalker Story - S1: Grummle - Scene 3 - moguSlaver02 - ZTO	"-- Wait until scene 3 begins
moguSlaver02: SetFacingToAbs(Vector:New(1448.66, 601.672, 550.222)) 
moguSlaver02: PlayLoopingAnimKit( 2316 )

WaitForTrigger(\scene3Trigger\"")"						
215	Lorewalker Story - S1: Grummle - Scene 4 - hozen01 - ZTO	"-- Wait until scene 4 begins
-- hozen01: SetFacingToAbs(Vector:New(1483.4, 227.516, 550.222)) 
-- hozen01: PlayLoopingAnimKit( 2315 )

-- WaitForTrigger(\scene4Trigger\"")"						
216	Lorewalker Story - S1: Grummle - Scene 5 - shadopan01 - ZTO	"-- Wait until scene 5 begins
--shadopan01: SetFacingToAbs(Vector:New(1281.7, 556.612, 536.167)) 
--shadopan01: PlayLoopingAnimKit( 2315 )

WaitForTrigger(\scene5Trigger\"")"						
217	Lorewalker Story - S1: Grummle - Scene 4 - hozen02 - ZTO	"-- Wait until scene 3 begins
-- hozen02: SetFacingToAbs(Vector:New(1739.47, 358.197, 550.222)) 
-- Wait (1)
-- hozen02: PlayLoopingAnimKit( 2315 )

-- WaitForTrigger(\scene4Trigger\"")"						
218	Jade Forest - Horde Intro Scene - Cannon01 - JSB	"cannon01:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
219	Jade Forest - Horde Intro Scene - Cannon02 - JSB	"cannon02:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
220	Jade Forest - Horde Intro Scene - Mists - JSB	"WaitForTrigger( \shipSpotted\"" )"						
221	Jade Forest - Horde Intro Scene - Vangard01 - JSB	"-- COPY STARTS HERE
--
local relativeMover = vanguard01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDe"						
228	Jade Forest - Horde Intro Scene - Zeppelin Cannon01 - JSB	"zeppelinCannon01:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship

WaitForTrigger( \zeppelinMove\"" )"						
235	Jade Forest - Horde Intro Scene - Cannon04 - JSB	"cannon04:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
236	Lorewalker Story - S1: Grummle - Fog Bunnies - ZTO DEPRECATED	"-- DEPRECATED
-- local actorAuraVisual = fogbunny1:PlaySpellStateVisual(24841) --Cast Actor Visual
-- local actorAuraVisual = fogbunny2:PlaySpellStateVisual(24841) --Cast Actor Visual
-- local actorAuraVisual = fogbunny3:PlaySpellStateVisual(24841) --C"						
237	Jade Forest - Horde Intro Scene - Ship Cannon Target - JSB	"
WaitForTrigger( \zeppelinMove\"" )"						
243	Lorewalker Story - S1: Grummle - grummlePacker2 - ZTO	"-- Wait until called
WaitForTrigger(\addGrummle2\"")"						
244	Lorewalker Story - S1: Grummle - Init - Scene 4 Actors - ZTO	"-- Spawn Pack 1 group
lamppostID = 62032
lamppost1 = SpawnActor(lamppostID, 1454.04, 369.326, 550.221, 268.352 ) -- Lamppost spawn stage left
FadeOut( lamppost1, 0 )

-- Spawn Pandaren group
richPandarenID = 62053
richPandaren1 = SpawnActor(richPan"	0	0				
245	Lorewalker Story - S1: Grummle - Scene 1 - lamppost1 - ZTO	"-- Wait until scene 3 begins
WaitForTrigger(\callSmack\"")"						
246	PetBattle Template - Custom Turn	"print(\PetBattle: Custom Turn Script Template\"")"						
250	Stormstout Brewery - Cinematic Framework - Spawning	"--
-- SpawnModelActor( modelFileName, pointsPathID, snapToGround [=true] )
--   Spawn an uninteractible actor
--
function SpawnModelActorsAtPoints( modelFileName, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.mod"	0	0				
251	Stormstout Brewery - Cinematic Framework	"-- default all cinematics to non relative
scene:SetRelativeCoords(false) -- set to absolute worlld coords

function Wait( time )
	scene:WaitTimer( time )
end

--
-- SpawnActor( creatureID, x, y, z, facing [default 0], scale [default 1] )
--   Spa"						
253	Stormstout Brewery - Virmen Keg Scene - Init 1	"-- spawn Virmen
local virmenCreatureID = 60205

virmen1 = SpawnActor( virmenCreatureID, -726, 1250, 165, 0, 1.0, false )
virmen2 = SpawnActor( virmenCreatureID, -728, 1250, 165, 10, 1.0, false )
virmen3 = SpawnActor( virmenCreatureID, -730, 1250, 165"	0	0				
254	Jade Forest - Horde Intro Scene - Celebration - JSB	"
WaitForTrigger( \shipMove\"" )"						
256	Stormstout Brewery - Virmen Keg Scene - Init 3	"local virmenCreatureID = 60205

virmen88 = SpawnActor( virmenCreatureID, -729, 1258, 165, 150, 1.0, false )
virmen89 = SpawnActor( virmenCreatureID, -725, 1258, 165, 160, 1.0, false )
virmen90 = SpawnActor( virmenCreatureID, -723, 1258, 165, 170, 1.0, false )

virmen91 = SpawnActor( virmenCreatureID, -731, 1258, 165, 180, 1.0, false )
virmen92 = SpawnActor( virmenCreatureID, -733, 1258, 165, 190, 1.0, false )
virmen93 = SpawnActor( virmenCreatureID, -735, 1258, 165, 200, 1.0, false )
virmen94 = SpawnActor( virmenCreatureID, -737, 1258, 165, 300, 1.0, false )

virmen95 = SpawnActor( virmenCreatureID, -728, 1260, 165, 210, 1.0, false )
virmen96 = SpawnActor( virmenCreatureID, -726, 1260, 165, 230, 1.0, false )
virmen97 = SpawnActor( virmenCreatureID, -730, 1260, 165, 250, 1.0, false )
virmen98 = SpawnActor( virmenCreatureID, -732, 1260, 165, 260, 1.0, false )
virmen99 = SpawnActor( virmenCreatureID, -734, 1260, 165, 270, 1.0, false )
virmen100 = SpawnActor( virmenCreatureID, -736, 1260, 165, 280, 1.0, false )
virmen101 = SpawnActor( virmenCreatureID, -724, 1258, 165, 240, 1.0, false )

Wait(604800)"	0	0				
257	Siege of Niuzao Temple - The Mantid Army - Master - SLG	"-- Make the flyers play their flying anims
flyer00:PlayLoopingAnimKit(1380)
flyer01:PlayLoopingAnimKit(1380)
flyer02:PlayLoopingAnimKit(1380)
flyer03:PlayLoopingAnimKit(1380)
flyer04:PlayLoopingAnimKit(1380)

flyer10:PlayLoopingAnimKit(1380)
flyer"	0	0				
258	Jade Forest - Horde Intro Scene - Zeppelin Fires - JSB	"zeppelinFire:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))
zeppelinFire01:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))
zeppelinFire02:SetFacingToAbs(Vector:New(2972.01, -45.2662, 337.945))

WaitForTrigger( \zeppelinMove\"" )"						
282	Lorewalker Story - S1: Grummle - MoguFace - ZTO	"-- Bring on the mighty mogu face!
WaitForTrigger( \Spawn Face\"" )"						
283	Lorewalker Story - Stage Lights and Cho Setup - Init - ZTO	"-- Spawn Stage Light bunnies
bunnyID = 62026
light_ul = SpawnActor( bunnyID, 1449.33, 358.926, 550.221, 317.347 )  -- Upstage Left bunny
light_uc = SpawnActor( bunnyID, 1457.57, 365.7, 550.221, 221.947 )  -- Upstage Center bunny
light_ur = SpawnActor("	0	0				
284	Lorewalker Story - Stage Lights - UL - ZTO	"-- Light - Upstage Left - When Called
WaitForTrigger( \cueLight_UL\"" )"						
289	Lorewalker Story - Stage Lights - CR - ZTO	"-- Light - Center Left - When Called
WaitForTrigger( \cueLight_CR\"" )"						
290	Lorewalker Story - S1: Grummle - Lorewalker Cho - ZTO	"--OnScene start

Wait (2)
lorewalker: StopLoopingSplitBodyAnim( Animations.EmoteReadLoop )
PlayOneShotSplitBodyAnim( lorewalker, Animations.EmoteBow )
Wait (2)
SendTrigger( \Spawn Face\"" )"						
292	Orgrimmar - MoP Horde Intro Scene - Init - JSB	"
-- spawn zeppelin
local zeppelinModel = \world\\expansion03\\doodads\\generic\\flying_horde_zeppelin.m2\"""						
294	Lorewalker Story - S1: Grummle - incense - ZTO	"-- Wait until called
WaitForTrigger(\smokingGrummle\"")"						
295	Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer1 - ZTO	"-- Wait until scene 3 begins
WaitForTrigger(\scene3Trigger\"")"						
296	Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer1 - ZTO	"-- Wait until scene 3 begins
WaitForTrigger(\scene3Trigger\"")"						
297	Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer3 - ZTO	"-- Wait until scene 3 begins
WaitForTrigger(\scene3Trigger\"")"						
298	Lorewalker Story - S1: Grummle - Scene 3 - grummleCheer4 - ZTO	"-- Wait until scene 3 begins
WaitForTrigger(\scene3Trigger\"")"						
299	Lorewalker Story - S1: Grummle - Scene 4 - grummleVendor1 - ZTO	"-- Wait until called by GrummleMainBag
WaitForTrigger(\scene4Trigger\"")"						
300	Lorewalker Story - S1: Grummle - Init - Scene 5 Actors - ZTO	"-- Spawn Pandaren group
shadopanID = 61908
shadopan01 = SpawnActor(shadopanID, 1462.94, 376.842, 550.221, 199.45 ) -- Spawns downstage left
FadeOut( shadopan01, 0 )

"	0	0				
301	Lorewalker Story - S1: Grummle - Scene 4 - grummleVendor2 - ZTO	"-- Wait until called by GrummleMainBag
WaitForTrigger(\scene4Trigger\"")"						
302	Lorewalker Story - S1: Grummle - Scene 4 - whiteyak - ZTO	"-- Wait until called by GrummleMainBag
WaitForTrigger(\scene4Trigger\"")"						
303	Lorewalker Story - S1: Grummle - Init - Scene 6 Actors - ZTO	"-- Spawn Grummle Vendors
grummleVendor3 = SpawnActor(grummleID, 1454.06, 365.674, 550.222, 99.7705 ) -- Spawns downstage left
grummleVendor4 = SpawnActor(grummleBagID, 1457.42, 369.071, 550.222, 175.146) -- Spawn second vendor
grummleVendor5 = SpawnAct"	0	0				
304	Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor3 - ZTO	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\scene6Trigger\"")"						
305	Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor4 - ZTO	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\scene6Trigger\"")"						
306	Lorewalker Story - S1: Grummle - Scene 6 - grummleVendor5 - ZTO	"-- Wait until called by Lorewalker Cho
WaitForTrigger(\scene6Trigger\"")"						
307	Orgrimmar - MoP Horde Intro Scene - Master - JSB	"
Wait( 2 )

SetCameraFollowPath( 390, 0.0, 3155, nil, 43 )

Wait( 37 )

SendTrigger( \zeppelinLeave\"" )"						
312	Orgrimmar - MoP Horde Intro Scene - Kiryn - JSB	"
WaitForTrigger( \zeppelinReady\"" )"						
314	Orgrimmar - MoP Horde Intro Scene - Zin\'jun - JSB	"

-- board zepp

WaitForTrigger( \zeppelinReady\"" )"						
315	Orgrimmar - MoP Horde Intro Scene - Shokia - JSB	"
WaitForTrigger( \zeppelinReady\"" )"						
320	Orgrimmar - MoP Horde Intro Scene - Vanguard03 - JSB	"WaitForTrigger( \zeppelinReady\"" )"						
330	PetBattle(fallback) - Constants	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------"						
332	PetBattle(fallback) - Init Player	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\pad\"", padModel, padTransform, padScale*battleScale)"						
335	PetBattle(fallback) - Effect Swap	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

--	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	loca"	0	0				
336	PetBattle(fallback) - Effect Set Health	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect)

	local abilityVisualID = effect.abilityVisualID
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\WARNING: no abilityVisual for SetHealth\"")"						
342	PetBattle(fallback) - Intro	"
local cameraBunny

--------------------------------------------------------------------------------
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(1.5)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()


	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(1.6)
		scene:SetCamera(0, 0.75, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0				
343	PetBattle(fallback) - Main	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[0].teamFacing = 0
initialBattleState.players[1].teamFacing = 0
initialBattleState.players[2].teamFacing = 180

teams = { }
teams[0] = initialBattleState.players[0]
teams[1] = initialBattleState.players[1]
teams[2] = initialBattleState.players[2]

if (PetBattleScene.GetActivePlayerDisplay) then
	if (teams[1]) then
		teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
	end
	if (teams[2]) then
		teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
	end
end

if (teams[2].isNPC == true) and (#teams[2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(0, teams[0])
InitTeam(1, teams[1])
InitTeam(2, teams[2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		if (useFreelookCamera) then
			StartCameraBunny(0)
		else
			SetCamera(3)
		end
	end
	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle, winnerID = ProcessEvent(event)
end

if (winnerID == 1) or (winnerID == 2) then
	local winnerTeam = teams[winnerID]
	for petIndex, pet in pairs(winnerTeam.pets) do
		if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
			-- move backline up to celebrate
			pet.actor:Fade(1.0, backlineFadeTime)
			MoveToRadius(pet, idleRadius, pet.currentOffset)
		end
	end
	scene:WaitTimer(1.0)
end

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.25)
	else
		SetCamera(4)
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0				
345	PetBattle(fallback) - Arena	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \arenaRing\"""						
347	Lorewalker Story - S2: Saurok - MASTER - Lorewalker Cho - ZTO	"--OnScene start

--Wait (2)
lorewalker: StopLoopingSplitBodyAnim( Animations.EmoteReadLoop )
--PlayOneShotSplitBodyAnim( lorewalker, Animations.EmoteBow )
Wait (2)
SendTrigger( \Spawn Face\"" )"						
348	Lorewalker Story - S2: Saurok - End - Clean Up - ZTO	"WaitForTrigger( \endScene\"" )"						
349	Lorewalker Story - S2: Saurok - Init - Scene 1 Actors - ZTO	"-- Spell preloads
TransformSpellID = 120566
TransformEffectSpellID = 120704

--Spawn and hide Mogu
moguID1 = 62426
moguID2 = 62427
moguID3 = 62428
moguBoss = 62169

moguPoleArm1 = SpawnActor( moguID1, 1461.08, 361.964, 550.222, 129.022 ) -- Mogu"	0	0				
350	Lorewalker Story - S2: Saurok - MoguFace - ZTO	"-- Bring on the mighty mogu face!
WaitForTrigger( \Spawn Face\"" )"						
351	Lorewalker Story - S2: Saurok - Scene 1 - MoguMace1 - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
352	Lorewalker Story - S2: Saurok - Scene 1 - MoguPolearm1 - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
353	Lorewalker Story - S2: Saurok - Scene 1 - Tian - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
354	Lorewalker Story - S2: Saurok - Scene 1 - lizard1 - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
355	Lorewalker Story - S2: Saurok - Scene 1 - lizard2 - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
356	Lorewalker Story - S2: Saurok - Scene 1 - lizard3 - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
357	Lorewalker Story - S2: Saurok - Scene 1 - egg - ZTO	"-- Wait until called
WaitForTrigger( \cueMogu\"" )"						
358	Lorewalker Story - S2: Saurok - Scene 1 - littlesaurok - ZTO	"-- Wait until called
WaitForTrigger( \eggBreak\"" )"						
359	Lorewalker Story - S2: Saurok - Init - Scene 2 Actors - ZTO	"--Spawn and hide saurok
hackID = 61935
healID = 61934
tankID = 61933

saurok_hack = SpawnActor( hackID, 1463.6, 372.819, 550.221, 129.915 ) -- Hacky saurok
saurok_heal = SpawnActor( healID, 1449.86, 361.5, 550.221, 129.915 ) -- Healy saurok
saurok_"	0	0				
360	Lorewalker Story - S2: Saurok - Scene 2 - saurok_hack - ZTO	"-- Wait until called
WaitForTrigger( \hack\"" )"						
361	Lorewalker Story - S2: Saurok - Scene 2 - saurok_heal - ZTO	"-- Wait until called
WaitForTrigger( \heal\"" )"						
362	Lorewalker Story - S2: Saurok - Scene 2 - saurok_tank - ZTO	"-- Wait until called
WaitForTrigger( \tank\"" )"						
363	Lorewalker Story - S2: Saurok - Init - Scene 3 Actors - ZTO	"--Spawn and hide saurok
--hackID = 61935
--healID = 61934
--tankID = 61933

saurok_hack2 = SpawnActor( hackID, 1447.03, 364.472, 550.221, 246.69 ) -- Hacky saurok
saurok_heal2 = SpawnActor( healID, 1453.51, 361.922, 550.221, 195.84 ) -- Healy saurok"	0	0				
364	Lorewalker Story - S2: Saurok - Scene 3 - saurok_tank2 - ZTO	"-- Wait until called
WaitForTrigger( \scene3\"" )"						
365	Lorewalker Story - S2: Saurok - Scene 3 - saurok_heal2 - ZTO	"-- Wait until called
WaitForTrigger( \scene3\"" )"						
366	Lorewalker Story - S2: Saurok - Scene 3 - saurok_hack2 - ZTO	"-- Wait until called
WaitForTrigger( \scene3\"" )"						
367	Lorewalker Story - S2: Saurok - Scene 3 - yaungols - ZTO	"-- Wait until called
WaitForTrigger( \scene3\"" )"						
368	Lorewalker Story - S2: Saurok - Init - Scene 4 Actors - ZTO	"--Spawn in saurok
saurok_hack3 = SpawnActor( hackID, 1456.74, 376.654, 550.221, 12.9099 ) -- Hacky saurok
saurok_heal3 = SpawnActor( healID, 1461.95, 369.217, 550.221, 62.8614 ) -- Healy saurok
saurok_tank3 = SpawnActor( tankID, 1458.37, 371.162, 550.2"	0	0				
369	Lorewalker Story - S2: Saurok - Scene 4 - saurok_hack3 - ZTO	"-- Wait until called
WaitForTrigger( \scene4\"" )"						
370	Lorewalker Story - S2: Saurok - Scene 4 - saurok_heal3 - ZTO	"-- Wait until called
WaitForTrigger( \scene4\"" )"						
371	Lorewalker Story - S2: Saurok - Scene 4 - saurok_tank3 - ZTO	"-- Wait until called
WaitForTrigger( \scene4\"" )"						
372	Lorewalker Story - S2: Saurok - Init - Scene 5 Actors - ZTO	"--Spell Effects
fieryExplosionSpellID = 99977
trollExplosionSpellID = 52565
bloodyExplosionSpellID = 3240

--Spawn in saurok
saurok_hack4 = SpawnActor( hackID, 1457.85, 356.834, 550.222, 133.284, 1, false ) -- Hacky saurok
saurok_hack5 = SpawnActor"	0	0				
373	Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack4 - ZTO	"-- Wait until called
WaitForTrigger( \scene5\"" )"						
374	Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack5 - ZTO	"-- Wait until called
WaitForTrigger( \scene5\"" )"						
375	Lorewalker Story - S2: Saurok - Scene 5 - saurok_hack6 - ZTO	"-- Wait until called
WaitForTrigger( \scene5\"" )"						
376	Shen-zin Su - Healing Cinematic - Init	"
FlashHealModel = \Spells\FlashHeal_Base.mdx\"""						
377	Shen-zin Su - Healing Cinematic - Bunny 01	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( FlashHeal01, 1 )"	0	0				
378	Shen-zin Su - Healing Cinematic - Camera	"
scene:WaitTimer(2)

scene:SetCamera(316,8,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(2)
scene:SetCamera(328,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(329,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(330,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(331,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(332,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(333,8,nil,nil)
scene:WaitTimer(2)
scene:SetCamera(0,4,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(4)"	0	0				
379	Jade Forest - Horde Intro Scene - Alliance Crewman01 - JSB	"allianceCrewman01:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
382	Jade Forest - Horde Intro Scene - Alliance Crewman04 - JSB	"allianceCrewman04:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
383	Jade Forest - Horde Intro Scene - Alliance Crewman05 - JSB	"allianceCrewman05:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman05 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"						
384	Lorewalker Story - S2: Saurok - Scene 5 - terrorcotta1 - ZTO	"-- Wait until called
WaitForTrigger( \scene5\"" )"						
385	Lorewalker Story - S2: Saurok - Scene 5 - terrorcotta2 - ZTO	"-- Wait until called
WaitForTrigger( \scene5\"" )"						
386	Townlong Steppes - Finale Spyglass Intro - Init	"
local Boss1ID = 62579
local Boss2ID = 62580
local Boss3ID = 62581
Boss1 = SpawnActor( Boss1ID, 1369.76, 4394.86, 211.106, 263, 1.0, false )
Boss2 = SpawnActor( Boss2ID, 1594.94, 4500.88, 148.093, 11, 1.0, false )
Boss3 = SpawnActor( Boss3ID, 1648.42, 4800.84, 150.908, 60, 1.0, false )"	0	0				
387	Townlong Steppes - Finale Spyglass Intro - Bunny 01	"
Wait(1)
FadeIn( Boss1, 1 )
FadeIn( Boss2, 1 )
FadeIn( Boss3, 1 )"	0	0				
388	Townlong Steppes - Finale Spyglass Intro - Camera	"
scene:WaitTimer(1)

scene:SetCamera(403,1,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:WaitTimer(7)
scene:SetCamera(404,4,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(405,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(406,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(407,3,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(408,5,nil,nil)
scene:WaitTimer(7)
scene:SetCamera(0,1,nil,nil) -- sets camera back to game-cam
scene:WaitTimer(1)"	0	0				
389	PetBattle(fallback) - Event Reward	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = Get"	0	0				
390	PetBattle(fallback) - Event Move Ability Selected	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)

	-- print(\Move Selected: Ability Visual ID: \"" .. abilityVisualID)"						
414	PetBattle(fallback) - Placeholder Players	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \placeHolder\"" .. playerID"						
427	PetBattle(fallback) - Event Move Trap Selected	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected()

	-- print(\Move Selected: Trap\"")"						
536	[1] PetBattle(fallback) - Functions	"return attackRadius
end

"	331	0				
538	Jade Forest - Stay a While Scene - Init - JSB	"
-- spawn cho
local choCreatureID = 55768
cho = SpawnActor( choCreatureID, 2130.74, -474.679, 392.885, 29, 1.0, false )
cho:PlayLoopingFullBodyAnim(Animations.SitGround)

-- spawn Mist
local mistModel = \world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"""						
541	Jade Forest - Stay a While Scene - Mogu - JSB	"
WaitForTrigger( \moguAppear\"" )"						
542	Great Wall - Mantid Army - Init 1	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213



mantid1 = SpawnActor( mantidCreatureID, 1106.48, 2541.46, 325.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 1116.48, 2541.46, 325.392, 270.609, 1."	0	545				
543	Great Wall - Mantid Army - Init 2	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 1061.51, 2554.46, 305.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 1051.51, 2554.46, 305.392, 270.609, 1.0, t"	0	546				
544	Great Wall - Mantid Army - Init 3	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 995.17, 2554.46, 300.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID, 980.17, 2554.46, 300.392, 270.609, 1.0, tru"	0	0				
545	[1] Great Wall - Mantid Army - Init 1	"mantidCreatureID, 1106.48, 2401.46, 328.244, 279.294, 1.0, true )
mantid44 = SpawnActor( mantidCreatureID, 1116.48, 2401.46, 328.198, 279.294, 1.0, true )
mantid45 = SpawnActor( mantidCreatureID, 1126.48, 2401.46, 328.108, 279.294, 1.0, true )
mantid46 = SpawnActor( mantidCreatureID, 1106.48, 2391.46, 327.811, 279.294, 1.0, true )
mantid47 = SpawnActor( mantidCreatureID2, 1116.48, 2391.46, 327.493, 279.294, 1.0, true )
mantid48 = SpawnActor( mantidCreatureID, 1126.48, 2391.46, 327.196, 279.294, 1.0, true )"	542	0				
546	[1] Great Wall - Mantid Army - Init 2	"mantidCreatureID, 1061.51, 2401.46, 305.244, 279.294, 1.0, true )
mantid44 = SpawnActor( mantidCreatureID, 1051.51, 2401.46, 305.198, 279.294, 1.0, true )
mantid45 = SpawnActor( mantidCreatureID, 1041.51, 2401.46, 305.108, 279.294, 1.0, true )
mantid46 = SpawnActor( mantidCreatureID, 1061.51, 2391.46, 305.811, 279.294, 1.0, true )
mantid47 = SpawnActor( mantidCreatureID2, 1051.51, 2391.46, 305.493, 279.294, 1.0, true )
mantid48 = SpawnActor( mantidCreatureID, 1041.51, 2391.46, 305.196, 279.294, 1.0, true )
"	543	0				
548	Great Wall - Mantid Army - Init 4	"-- spawn mantid
local mantidCreatureID = 56890
local mantidCreatureID2 = 61213

mantid1 = SpawnActor( mantidCreatureID, 876.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID2, 856.724, 2554.46, 311.392, 270.609, 1.0, "	0	0				
550	Great Wall - Mantid Army - Init 5	"-- spawn mantid
local mantidCreatureID = 63560
local mantidCreatureID2 = 63561

mantid1 = SpawnActor( mantidCreatureID, 776.724, 2554.46, 311.392, 270.609, 1.0, true )
mantid2 = SpawnActor( mantidCreatureID2, 756.724, 2554.46, 311.392, 270.609, 1.0, "	0	0				
551	[1] PetBattle(fallback) - Init Player	"			end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	332	0				
554	[1] PetBattle(fallback) - Effect Processing	"(effectGroup.firstEffect.abilityVisualID) then
		effectVisual = petAbilityVisuals[effectGroup.firstEffect.abilityVisualID]
	end
	local processed = false
	if (effectVisual and effectVisual.scriptFunction) then
		if ( effectVisual.scriptFunction( effectGroup ) ) then
			processed = true
		end
	end

	-- fallback handling
	if (processed ~= true) then
		for index, effectResult in pairs(effectGroup.results) do
			StartEffectProcessing(effectResult)
			
			ProcessRoundResult(effectResult)
			
			SignalEffectProcessed()

			if (effectResult.procGroup) then
				ProcessRoundTurnGroup(effectResult.procGroup)
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Process an individula Round Effect Result
function ProcessRoundResult(event)

	local eventType = event.eventType
	local effectType = event.effectType

	if not (eventType == PetBattleEvent.RoundEffect) then
		return
	end

	if (debugOn == true) then
		print(\-     Processing Result \"" .. event.instanceID)"						
556	Valley of the Four Winds - Stoneplow Finale - Init Friends - PRK	"paradeSpeed = 6

-- wall cap
local wallModel = \WORLD\\EXPANSION04\\DOODADS\\VALEOFETERNALBLOSSOMS\\GREATWALL_CAP\\PA_GreatWall_Cap_01.M2\"""						
560	PetBattle - Init Player	"
allPlayers = { }

function InitTeam(playerID, team)

	-- save the team
	allPlayers[playerID] = team

	local padRadius = -idleRadius
	if (playerID == PetBattlePlayerID.Weather) then
		padRadius = 0
		team.isWeather = true
	else
		team.isWeather = false
	end

	-- spawn a pad for this team
	local padPos = BuildVector(team.teamFacing, padRadius, 0)
	local padTransform = Transform:New(padPos, team.teamFacing)
	local padCreateData = ActorCreateData:NewModel(\pad\"", padModel, padTransform, padScale*battleScale)"						
561	[1] PetBattle - Init Player	"pet
						targetAlpha = GetAlpha(pet)
					end

					pet.actor:Fade(targetAlpha, fadeInTime)
				end
			end
		end
	end

	-- wait until faded in
	if fadeInTime > 0 then
		scene:WaitTimer( fadeInTime )
	end

	-- make everything interactible again
	for playerID, player in pairs( allPlayers ) do
		if (player.isWeather == false) then
			for slot, pet in pairs ( player.pets ) do
				if (pet.isPad == false) then
					pet.actor:SetInteractible( true )
				end
			end
		end
	end

end
"	560	0				
562	PetBattle - Play Spell Effect	"
--------------------------------------------------------------------------------
function SpellEffectPlayShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]

	local targetPlayerID = targetData.playerID;
	local targetPlayer = GetTeamByIndex(targetPlayerID)
	local targetPet = targetPlayer.pets[targetData.petSlot]

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local casterCastingPet, spellVisualID = PerformSpellVisual(casterCastingPet, abilityVisualID, targetPet)

	return casterCastingPet, spellVisualID 
end

--------------------------------------------------------------------------------
function MovePetToFrontLines(pet, opponent, range )
--[[
	-- Move pet if its the current pet
	if ( (casterPlayer.activePet == effect.casterPetSlot) and (not casterFrontPet.deathAnimKit) ) then 
		MovePetToFrontLines(casterFrontPet, opponentFrontPet, abilityVisual.range )
	end

	-- Wait for opponent
	WaitForOpponentPet(opponentFrontPet)
]]--
	PetMoveToAttackPosition(pet, opponent, range );
end

function WaitForOpponentPet(opponent)
	-- make sure the opponent pet is at the correct radius
	if not opponent.deathAnimKit then
		WaitMoveToRadius(opponent, readyRadius)
	end
end

function PerformSpellVisual(casterCastingPet, abilityVisualID, targetPet)
	--
	-- Actually cast
	--	

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end
	local spellVisualID = abilityVisual.spellVisualID

	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\WARNING: no abilityVisual for PerformSpellVisual\"")"						
563	PetBattle - Result - Swap	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

--	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	loca"	0	0				
564	PetBattle - Result - Set Health	"
--------------------------------------------------------------------------------
-- SET HEALTH

function EffectSetHealth(effect, dontWait)

	local abilityVisualID = effect.abilityVisualID
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)
	if (not abilityVisualID) or (abilityVisualID == 0) then
		print(\WARNING: no abilityVisual for SetHealth\"")"						
568	PetBattle - 2. Pre-Playback Processing	"--------------------------------------------------------------------------------
-- Group and process all round effects

local processDebug = false;

function ProcessAllRoundResults(allEvents)

	if ( processDebug ) then 
		DebugPrint(\== Round Res"						
570	PetBattle - Reward XP and Level	"--------------------------------------------------------------------------------
-- REWARD
function EventReward(rewards)

	local rewardedPets = {}
	for rewardIndex,reward in pairs(rewards) do
		if not (reward.wasCaptured) then
			local player = Get"	0	0				
571	PetBattle - Selected - Ability Selected Movement	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)

	-- print(\Move Selected: Ability Visual ID: \"" .. abilityVisualID)"						
573	PetBattle - Selected - Trap Selected Movement	"--------------------------------------------------------------------------------
-- MOVE (trap) SELECTED
function EventMoveTrapSelected()

	-- print(\Move Selected: Trap\"")"						
576	PetBattle - Cameras	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \arenaCameraBunny\"""						
577	PetBattle - Intro	"
local cameraBunny

--------------------------------------------------------------------------------
function BattleIntro()

	scene:WaitTimer(0.25)
	SetCamera(1)
	StartCameraBunny(3.0)

	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()


	if (useFreelookCamera) then
		scene:WaitTimer(0.5)
		SetCamera(2)
		scene:WaitTimer(2.6)
		scene:SetCamera(0, 2.0, nil, nil)
	else
		scene:WaitTimer(0.25)
		SetCamera(2)
		scene:WaitTimer(0.75)
	end
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0				
578	PetBattle - Arena	"
--------------------------------------------------------------------------------
-- Spawn Client Side Arena Visuals
local arenaCreateData = ActorCreateData:Default()
arenaCreateData.name = \arenaRing\"""						
579	PetBattle - Placeholder Players	"
--------------------------------------------------------------------------------
-- Placeholder opponents for cross-realm etc battles
--  - script runs in parallel and pings for a player to become valid

local placeHolderCreatureIDs =
{
	62409;	-- Lorewalker Cho
}

local needPlaceHolder = true
if not (PetBattleScene.GetActivePlayerDisplay) then
	needPlaceHolder = false
end

local placeHolderPingTime = 0.5
local placeHolderActors = { }

while (needPlaceHolder) do
	scene:WaitTimer(placeHolderPingTime)

	needPlaceHolder = false
	for playerID, player in pairs(teams) do
		if (playerID ~= PetBattlePlayerID.Weather) and (player.isNPC ~= true) then
			player.playerDisplay = battleScene:GetActivePlayerDisplay(playerID)
			if (not player.playerDisplay) then
				-- still need a placeholder
				needPlaceHolder = true

				-- create it if we haven\'t already
				local placeHolderActor = placeHolderActors[playerID]
				if (not placeHolderActor) then
					local createData = ActorCreateData:Default()
					createData.creatureID = placeHolderCreatureIDs[1] -- TODO: randomize
					createData.name = \placeHolder\"" .. playerID"						
581	Valley of the Four Winds - Stoneplow Finale - Camera - PRK	"--Wall shot
local genericFOV90 = 368
SetCameraFollowPath( genericFOV90, 0, 3421, 3422, 10)
Wait(2)

--Loon looks at wall
SendTrigger(\LoonShot1\"")"						
582	Global Functions - Actor Sound	"--
-- Sound Helper Functions
--
function Actor:WaitSoundKitComplete(soundKit)
	if not soundKit then
		return
	end
	local waitCondition = function()
		return soundKit:IsStopped()
	end
	self:WaitCondition(waitCondition)
end
"	0	0				
583	Valley of the Four Winds - Stoneplow Finale - Wall - PRK	"WaitForTrigger(\BreakWall\"")"						
584	Valley of the Four Winds - Stoneplow Finale - Loon Mai - PRK	"WaitForTrigger(\LoonShot1\"")"						
587	Valley of the Four Winds - Stoneplow Finale - Shado-Pan - PRK	"WaitForTrigger(\FarmersAssemble\"")"						
588	Valley of the Four Winds - Stoneplow Finale - Init Enemies - PRK	"-- mantid - leven
mantidLeven01 = SpawnFadedActorAtPoint( 63402, 3453, false )
mantidLeven02 = SpawnFadedActorAtPoint( 63402, 3454, false )
mantidLeven03 = SpawnFadedActorAtPoint( 63403, 3455, false )
mantidLeven04 = SpawnFadedActorAtPoint( 63402, 345"	0	0				
589	Valley of the Four Winds - Stoneplow Finale - Chen - PRK	"local kickSpell = 124002

--Fade in
WaitForTrigger(\KidsShot\"")"						
590	Valley of the Four Winds - Stoneplow Finale - Mantid (Flankers) - PRK	"WaitForTrigger(\KidsShot\"")"						
593	Brazie\'s PetBattle - Init Player	"
function InitTeam(playerID, team)

	-- Save the team
	allPlayers[playerID] = team;
	team.playerID = playerID;

	-- Spawn a Pad
	local homeTransform = HOME_LIST[playerID];
	team.pad = InitPad(homeTransform);

	-- Save the home loc
	team.home = homeTransform.position;

	-- Weather is neutral, so set it up then eject
	if (playerID == PetBattlePlayerID.Weather) then
		team.isWeather = true
print(\Weather\'s Pets: \"",#team.petDescs);"						
595	PetBattle - Victory Ceremony	"function VictoryCeremony(winnerID)
	if (winnerID == 1) or (winnerID == 2) then
		local winnerTeam = teams[winnerID]
		for petIndex, pet in pairs(winnerTeam.pets) do
			if (winnerTeam.activePet ~= petIndex) and (pet.isPad == false) and (pet.currentHealth > 0) then
				-- move backline up to celebrate
				pet.actor:Fade(1.0, backlineFadeTime)
				MoveToRadius(pet, idleRadius, pet.currentOffset)
			end
		end
		scene:WaitTimer(1.0)
	end
end"	0	0				
596	Brazie\'s PetBattle - Effect Swap	"function EffectSwap(teamId, petIndex)
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local lastPet = team.pets[team.activePet]
	local nextPet = team.pets[petIndex]
	if not nextPet then
		return
	end

	-- make the player or npc point
	if (team.master) then
		team.master:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmotePoint)
	end

	local nextTeam = math.fmod(teamId,2)+1;
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]

	-- Handle the cosmetic swap
	PerformSwap( lastPet, nextPet, opponent );

	team.activePet = petIndex
end

function PerformSwap ( pet, newPet, opponent )
	local currentPetLoc = pet.actor:GetPosition();
	local currentBacklineLoc = newPet.actor:GetPosition();

	local distance = currentPetLoc:Dist(currentBacklineLoc);

	-- New guy faces the enemy
	newPet.actor:SetFacingToAbs(opponent.actor:GetPosition())

	-- If dead despawn it
	if ( pet.currentHealth <= 0 ) then 
		pet.actor:Fade(0, backlineFadeTime);

	else
		-- Swap locations
		pet.actor:ClearFacing();
		pet.actor:MoveToAbs(currentBacklineLoc, distance/pet.moveSpeed)
	end

	newPet.actor:MoveToAbs(currentPetLoc, distance/newPet.moveSpeed)

	-- If dead, fade corpse in
	if ( pet.currentHealth <= 0 ) then 
		pet.actor:Fade(backlineAlpha, backlineFadeTime)

	-- If alive wait for it to move to the end
	else
		pet.actor:WaitMovementComplete()
	end
	newPet.actor:WaitMovementComplete()


	ReturnOrResetCheck( newPet, opponent );

	-- Make all of your pets look at their teammate

	for k,v in pairs( allPlayers[pet.team].pets ) do 
		if ( k ~= allPlayers[pet.team].activePet ) then 
			v.actor:SetFacingToTarget(newPet.actor, Vector:New());
		end
	end
end "	0	0				
597	Brazie\'s PetBattle - Event Reward	"function MoveToVictoryLocation(pet)
	print(\You won! Fill me in later, Alex!!\"")"						
599	[1] Cinematic Framework	"scene:WaitCondition(waitCondition)
end

function Actor:FollowPathAtSpeed( pathID, speed )
	local path = scene:LoadPath( pathID )
	local totalDist = 0
	local currentVector = Vector:New()
	local i

	for i = 1, (#path.nodes)-1 do
		local v1 = path.nodes[i].pos
		local v2 = path.nodes[i+1].pos
		currentVector = v1 - v2 -- Vector.Sub( v1 , v2 )
		totalDist = totalDist + Vector.Magnitude(currentVector)
	end

	self:FollowPath( pathID, totalDist/speed )
end
"	41	0				
600	PetBattle - 3. Playback Turn	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false

function PlaybackAllTurns(topLevelTurnGroups)

	if (debugOn == true) then
		print(\  \"")"						
602	Brazie\'s PetBattle - Pet Movement - Core Library	"
function CalculateLocationFacingRelativeOffset(pet, location, front, left, up)
	FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );

	return FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );
end

function CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 
	local opponentLocation = opponent.actor:GetPosition();

	return CalculateLocationFacingRelativeOffset(opponent, pet.actor:GetPosition(), front, left, up);
end

function PerformRelativeSlide( opponent, pet, front, left, up ) 
	local newDrift = CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 

	local opponentDriftPoint = newDrift;
	local driftDistance = opponentDriftPoint:Dist( opponent.actor:GetPosition() )

	opponent.actor:MoveToAbs(opponentDriftPoint, driftDistance/opponent.moveSpeed );

end

function BuildKnockbackSpline(petStartPosition, petFinalPoint, duration)
	local gravity = -9.8/2; -- M / sec / sec
	local points = 10;  

	local dx = petFinalPoint.x - petStartPosition.x;
	local dy = petFinalPoint.y - petStartPosition.y;
	local xVelocity = dx / duration;  -- M / sec
	local yVelocity = dy / duration;  -- M / sec

	local zVelocity = ( gravity * duration * duration ) * -2;

	local list = {};
	local timeStep = duration / points

	for i=0, points do 
		local time = timeStep * i; 
		local x = time * xVelocity;
		local y = time * yVelocity;
		local u = gravity*time*time + zVelocity*time;
--print(\t: \"",time,\"" x: \"",x,\""u: \"",u);"						
603	Valley of the Four Winds - Stoneplow Finale - Zhu\'s Wardens - PRK	"WaitForTrigger(\TriggerParade\"")"						
608	Valley of the Four Winds - Stoneplow Finale - Night Elves - PRK	"WaitForTrigger(\TriggerParade\"")"						
611	Global Functions - Debug	"
-- Alias
Broadcast = print;
Print = print;

-- Debug stuff
--
function DEBUG_TABLE(table, depth, lookup)
	if ( not depth ) then
		depth = 0;
	end

	if ( depth > 20 ) then
		return;
	end

	local prefix = \\"";"						
614	[1] PetBattle - 2. Pre-Playback Processing	"maxTurnInstanceIDs)
	end
	
	local turnKey = turnInstanceID*maxStackDepth + stackDepth
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey
	return turnKey, effectKey
end

"	568	0				
620	Brazie\'s PetBattle - Selected Ability Selected Movement	"--------------------------------------------------------------------------------
-- MOVE (ability) SELECTED
function EventMoveAbilitySelected(abilityVisualID)
	-- print(\Move Selected: Ability Visual ID: \"" .. abilityVisualID)"						
623	Brazie\'s PetBattle - Constant Overrides	"-- Replace Arena Ring Size
arenaRingScale = 1.0

-- Replace Home Locations

HOME_LIST = {
	-- Weather
	[0] = Transform:New(Vector:New( 0, 0, 1), 180);
	-- Players
	[1] = Transform:New(Vector:New( -2, 0, 0), 0);
	[2] = Transform:New(Vector:New(  "	0	0				
624	Brazie\'s PetBattle - Dispatcher	"-- Responsible Object ID Tracking and Management
--
--ROID = 0xFFFF;

UNIT_ACTION_QUEUE = {
	--[ROID] = { 
	--  ROID = ROID;
	--  isProcessing = bool;
	--	commands = {
	--		{ func=function()end; args = {}; };
	--	};
	-- }
}

-- A global kill"						
626	Brazie\'s PetBattle - Dispatcher - Death and Respawn Check	"function Dispatcher_DeathAndRespawnCheck(ROID)
	local pet = ROIDTOPET( ROID )

	return DeathAndRespawnCheck(pet);
end

--
-- Returns:
--
--		nil - no change
--		\died\"" - pet just perished"						
627	Brazie\'s PetBattle - Dispatcher - Display XP	"function Dispatcher_SetXP(ROID, ...)
	local pet = ROIDTOPET( ROID )

	return SetXP(pet, ...)
end

function SetXP(pet, xp, level, dontDraw)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (dontDraw) then
		return
	end
	ShowXPGains(pet, xp, level, dontDraw)
end

function ShowXPGains(pet, xp, level, dontDraw)		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end"	0	0				
628	Brazie\'s PetBattle - Dispatcher - Pet Owner Emote	"function Dispatcher_OwnerEmote( ROID, emote )
	local player = ROIDTOPLAYER( ROID )
	if (player and player.playerDisplay) then
		player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, emote)
	end
end"	0	0				
630	Brazie\'s PetBattle - Dispatcher - Generic Stub Handler	"
function Dispatcher_DoFunction(result, dontWait, successEffect, failureEffect, func, ... )
	local casterCastingPet, targetPet, abilityVisualID = GetStandardData(result)


	-- If the attack misses - DODGE First!
	if ( result.failureReason and result.failureReason == PetBattleMoveFailureReason.Miss ) then
		if ( type(failureEffect) == \function\"" ) then "						
632	Brazie\'s PetBattle - Effect - GetStandardData	"function GetStandardData(result)
	local effectDebug = false;

	local casterPlayerID = result.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[result.casterPetSlot]

	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]

	if ( effectDebug == true ) then
		local castingTeamName = \Unknown\"";"						
633	Brazie\'s PetBattle - Dispatcher - Result Stub - Set Health	"function set_health_func(targetPet, casterPet, ...)

	local oldHealth = targetPet.currentHealth
	local newHealth = select(1,...)
	local hidden = false;

	result = SetHealth(targetPet, newHealth, hidden)

	-- This shouldn\'t be an inline response - convert to a dispatch later
	if ( result == \died\"" ) then"						
635	Brazie\'s PetBattle - Dispatcher - Result Stub - Aura Change	"function aura_change_func(targetPet, casterPet, ...)

	local auraInstanceID, turnsRemaining, cancel = ...
	local aura = targetPet.auras[auraInstanceID]
	if not aura then
		print(\ERROR: unknown aura instance ID \"" .. auraInstanceID)"						
637	Brazie\'s PetBattle - Dispatcher - Result Stub - Aura Apply	"function apply_aura_func(targetPet, casterPet, ...)
	local auraInstanceID, turnsRemaining, auraVisualID = ...
	local auraSpellVisualID 

	local auraVisual = petAbilityVisuals[auraVisualID]
	if (auraVisual) then
		auraSpellVisualID = auraVisual.spellVisualID
	end
	-- apply an aura, tracked by instance ID

print(\Applying aura to \"",targetPet.slot,\"" of \"",auraVisualID,\"" using spell visual ID: \"",auraSpellVisualID);"						
638	Brazie\'s PetBattle - Dispatcher - Result Stub - Swap 	"function swap_func(targetPet, casterPet, ...)
	swapPlayerID, newFrontPetIndex = ...
	
	local casterPlayerID = swapPlayerID
	local casterPlayer = GetTeamByIndex(swapPlayerID)
	local casterCastingPet = casterPlayer.pets[newFrontPetIndex]
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]

	local opponentPlayer = GetTeamByIndex(3-swapPlayerID)
	local opponentFrontPet = opponentPlayer.pets[opponentPlayer.activePet]

	local casterMasterROID = GETROIDFROMPLAYERID(casterPlayerID) + ROID_TYPE_PLAYER_MASTER;
	Dispatcher_AddCommandToQueue( casterMasterROID, Dispatcher_OwnerEmote, Animations.EmotePoint )

	casterPlayer.activePet = newFrontPetIndex

	-- This could probably be dispatched
	PerformSwap( casterFrontPet, casterCastingPet, opponentFrontPet );

end"	0	0				
639	Brazie\'s PetBattle - Dispatcher - Default Effect Behaviour	"
function Dispatcher_DefaultDoEffect(ROID, effect, handlerOverrides, skipCast) 
	DefaultDoEffect(ROID, \effect\"", effect, handlerOverrides, skipCast);"						
641	Brazie\'s PetBattle - BitLib	"function bit(p)
  return 2 ^ (p - 1)  -- 1-based indexing
end

-- Typical call:  if hasbit(x, bit(3)) then ...
function hasbit(x, p)
  return x % (p + p) >= p       
end

function setbit(x, p)
  return hasbit(x, p) and x or x + p
end

function clearbit(x, p)
  return hasbit(x, p) and x - p or x
end

function bitor(x, y)
  local p = 1; 
  local z = 0; 
  local limit = x > y and x or y
  while p <= limit do
    if hasbit(x, p) or hasbit(y, p) then
      z = z + p
    end
    p = p + p
  end
  return z
end

function bitand(x, y)
  local p = 1; 
  local z = 0; 
  local limit = x > y and x or y
  while p <= limit do
    if hasbit(x, p) and hasbit(y, p) then
      z = z + p
    end
    p = p + p
  end
  return z
end"	0	0				
642	Brazie\'s PetBattle - Dispatcher - ROID	"
-- Responsible Object ID
ROID_TYPE_PLAYER_PET_SLOT_1 = 0x0001;
ROID_TYPE_PLAYER_PET_SLOT_2 = 0x0002;
ROID_TYPE_PLAYER_PET_SLOT_3 = 0x0004;
ROID_TYPE_PLAYER_MASTER		= 0x0008;
ROID_TYPE_PLAYER_PAD		= 0x0010;
ROID_TYPE_PLAYER_PAD_OBJ_1	= 0x0020;
ROID_TYPE_PLAYER_PAD_OBJ_2	= 0x0040;
ROID_TYPE_PLAYER_PAD_OBJ_3	= 0x0080;

ROID_TYPE_WEATHER			= 0x0100;

ROID_TYPE_PLAYER_1 			= 0x1000;
ROID_TYPE_PLAYER_2 			= 0x2000;


function ROIDTOPLAYER( ROID ) 
	local playerID = 0;
	if ( bitand(ROID, 0xF000) == ROID_TYPE_PLAYER_1 ) then
		playerID = 1;
	elseif ( bitand(ROID, 0xF000) == ROID_TYPE_PLAYER_2 ) then
		playerID = 2;
	else
		return nil;
	end

	return GetTeamByIndex(playerID)
end

function ROIDTOPET( ROID ) 
--print(ROID,\ p1: \"",ROID_TYPE_PLAYER_1, \"" p2: \"",ROID_TYPE_PLAYER_2)"						
643	[1] PetBattle - 3. Playback Turn	"maxStackDepth)
	end
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then
		print (\WARNING: max turn instanceIDs exceeded \"" .. maxTurnInstanceIDs)"						
645	Turn Package - Multi-Attack	"function Dispatcher_MultiAttack( ROID, isTurn, turn )
	-- Only handle \effect\"" objects"						
646	Brazie\'s PetBattle - Dispatcher - Result Stub - SetState	"function set_state_func(caster, target, result) 
	local label = \Unknown State\"";"						
647	PetBattle(fallback) - EffectSet  State	"--------------------------------------------------------------------------------
-- STATUS CHANGE
local debugStates = true
function EffectSetState(effect)
	if (not effect) then
		return
	end

	for targetIndex, target in pairs(effect.targets) do
	"						
650	Brazie\'s PetBattle - Dispatcher - Thread Bot 2	"local myROID;
local myList=nil;

while(false and not BOT_KILL_SWITCH ) do
	for k,v in pairs(UNIT_ACTION_QUEUE) do
		if ( v.isProcessing == false and #v.commands > 0 ) then 
			myROID = k;
			myList = v;
			break;
		end
	end

	if ( myROID ) then 
		UNIT_ACTION_QUEUE[myROID].isProcessing = true;
		
		while myList.commands[1] ~= nil do
			local task = myList.commands[1];
			local result = task.func(myROID, unpack(task.args));

			print(\Bot1 Result: \"",result)"						
651	Brazie\'s PetBattle - Helper Functions	"allPetsShown = true;

function GetNaturalAlpha(ROID)
	local player = ROIDTOPLAYER( ROID ) 
	local pet = ROIDTOPET( ROID ) 

	if ( pet.slot == player.activePet ) then

		if ( pet.stealthed ) then 
			return 0.5;
		else
			return 1;
		end
	elseif ( allPetsShown ) then

		if ( pet.stealthed ) then 
			return 0.5;
		else
			return 0;
		end
	end
end"	0	0				
652	Turn Package - Only Animate The First N Effect	"function Dispatcher_OnlyAnimateTheEffects1toN( n, ROID, isTurn, turn )
	-- Only handle \effect\"" objects"						
653	Turn Package - Leap Into Range - Play N	"function Dispatcher_LeapIntoMeleeOnlyPlayN( n, ROID, isTurn, turn )
	-- Only handle \effect\"" objects"						
654	Brazie\'s PetBattle - Perform Move	"
-- Moves the unit to the correct location based on the ability
function PerformMove(ROID, range)
	local pet = ROIDTOPET(ROID);
	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	pet.actor:ClearFacing(); 

	--casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)
	local finalDestination = nil;

	-- Melee
	if ( range == PetBattleRange.Melee ) then 
		local meleePoint = frontVector * 1*battleScale;
		local meleeAttackPoint = opponentLocation + meleePoint;
		finalDestination = meleeAttackPoint;
	-- Ranged
	elseif ( range == PetBattleRange.Ranged ) then 
		local rangedPoint = frontVector * 2*battleScale;
		local rangedAttackPoint = opponentLocation + rangedPoint;
		finalDestination = rangedAttackPoint;
	-- Stationary
	elseif (range == PetBattleRange.InPlace ) then 
		pet.actor:SetFacingToAbs(opponentLocation)
	-- Do nothing
	else
		Print(\ERROR: No movement range specified!\"");"						
665	Global Constants - Animation Table 2	"AnimTable2 = {
	Submerge = 201;
	Submerged = 202;
	Cannibalize = 203; 
	ArrowBirth = 204;
	GroupArrowBirth = 205;
	CorpseArrowBirth = 206;
	GuideArrowBirth = 207;
	EmoteTalkNoSheathe = 208;
	EmotePointNoSheathe = 209;
	EmoteSaluteNoSheathe = 210;
	EmoteDanceSpecial = 211;
	Mutilate = 212;
	CustomSpell01 = 213;
	CustomSpell02 = 214;
	CustomSpell03 = 215;
	CustomSpell04 = 216;
	CustomSpell05 = 217;
	CustomSpell06 = 218;
	CustomSpell07 = 219;
	CustomSpell08 = 220;
	CustomSpell09 = 221;
	CustomSpell10 = 222;
	StealthRun = 223;
	Emerge = 224;
	Cower = 225;
	Grab = 226;
	GrabClosed = 227;
	GrabThrown = 228;
	FlyStand = 229;
	FlyDeath = 230;
	FlySpell = 231;
	FlyStop = 232;
	FlyWalk = 233;
	FlyRun = 234;
	FlyDead = 235;
	FlyRise = 236;
	FlyStandWound = 237;
	FlyCombatWound = 238;
	FlyCombatCritical = 239;
	FlyShuffleLeft = 240;
	FlyShuffleRight = 241;
	FlyWalkbackwards = 242;
	FlyStun = 243;
	FlyHandsClosed = 244;
	FlyAttackUnarmed = 245;
	FlyAttack1H = 246;
	FlyAttack2H = 247;
	FlyAttack2HL = 248;
	FlyParryUnarmed = 249;
	FlyParry1H = 250;
	FlyParry2H = 251;
	FlyParry2HL = 252;
	FlyShieldBlock = 253;
	FlyReadyUnarmed = 254;
	FlyReady1H = 255;
	FlyReady2H = 256;
	FlyReady2HL = 257;
	FlyReadyBow = 258;
	FlyDodge = 259;
	FlySpellPrecast = 260;
	FlySpellCast = 261;
	FlySpellCastArea = 262;
	FlyNPCWelcome = 263;
	FlyNPCGoodbye = 264;
	FlyBlock = 265;
	FlyJumpStart = 266;
	FlyJump = 267;
	FlyJumpEnd = 268;
	FlyFall = 269;
	FlySwimIdle = 270;
	FlySwim = 271;
	FlySwimLeft = 272;
	FlySwimRight = 273;
	FlySwimBackwards = 274;
	FlyAttackBow = 275;
	FlyFireBow = 276;
	FlyReadyRifle = 277;
	FlyAttackRifle = 278;
	FlyLoot = 279;
	FlyReadySpellDirected = 280;
	FlyReadySpellOmni = 281;
	FlySpellCastDirected = 282;
	FlySpellCastOmni = 283;
	FlyBattleRoar = 284;
	FlyReadyAbility = 285;
	FlySpecial1H = 286;
	FlySpecial2H = 287;
	FlyShieldBash = 288;
	FlyEmoteTalk = 289;
	FlyEmoteEat = 290;
	FlyEmoteWork = 291;
	FlyEmoteUseStanding = 292;
	FlyEmoteTalkExclamation = 293;
	FlyEmoteTalkQuestion = 294;
	FlyEmoteBow = 295;
	FlyEmoteWave = 296;
	FlyEmoteCheer = 297;
	FlyEmoteDance = 298;
	FlyEmoteLaugh = 299;
	FlyEmoteSleep = 300;
	FlyEmoteSitGround = 301;
	FlyEmoteRude = 302;
	FlyEmoteRoar = 303;
	FlyEmoteKneel = 304;
	FlyEmoteKiss = 305;
	FlyEmoteCry = 306;
	FlyEmoteChicken = 307;
	FlyEmoteBeg = 308;
	FlyEmoteApplaud = 309;
	FlyEmoteShout = 310;
	FlyEmoteFlex = 311;
	FlyEmoteShy = 312;
	FlyEmotePoint = 313;
	FlyAttack1HPierce = 314;
	FlyAttack2HLoosePierce = 315;
	FlyAttackOff = 316;
	FlyAttackOffPierce = 317;
	FlySheath = 318;
	FlyHipSheath = 319;
	FlyMount = 320;
	FlyRunRight = 321;
	FlyRunLeft = 322;
	FlyMountSpecial = 323;
	FlyKick = 324;
	FlySitGroundDown = 325;
	FlySitGround = 326;
	FlySitGroundUp = 327;
	FlySleepDown = 328;
	FlySleep = 329;
	FlySleepUp = 330;
	FlySitChairLow = 331;
	FlySitChairMed = 332;
	FlySitChairHigh = 333;
	FlyLoadBow = 334;
	FlyLoadRifle = 335;
	FlyAttackThrown = 336;
	FlyReadyThrown = 337;
	FlyHoldBow = 338;
	FlyHoldRifle = 339;
	FlyHoldThrown = 340;
	FlyLoadThrown = 341;
	FlyEmoteSalute = 342;
	FlyKneelStart = 343;
	FlyKneelLoop = 344;
	FlyKneelEnd = 345;
	FlyAttackUnarmedOff = 346;
	FlySpecialUnarmed = 347;
	FlyStealthWalk = 348;
	FlyStealthStand = 349;
	FlyKnockdown = 350;
	FlyEatingLoop = 351;
	FlyUseStandingLoop = 352;
	FlyChannelCastDirected = 353;
	FlyChannelCastOmni = 354;
	FlyWhirlwind = 355;
	FlyBirth = 356;
	FlyUseStandingStart = 357;
	FlyUseStandingEnd = 358;
	FlyCreatureSpecial = 359;
	FlyDrown = 360;
	FlyDrowned = 361;
	FlyFishingCast = 362;
	FlyFishingLoop = 363;
	FlyFly = 364;
	FlyEmoteWorkNoSheathe = 365;
	FlyEmoteStunNoSheathe = 366;
	FlyEmoteUseStandingNoSheathe = 367;
	FlySpellSleepDown = 368;
	FlySpellKneelStart = 369;
	
	
}
"	0	0				
670	Global Constants - Animation Table 3	"AnimTable3 = {
	FlyDruidCatRip = 400;
	FlyDruidCatRake = 401;
	FlyDruidCatRavage = 402;
	FlyDruidCatClaw = 403;
	FlyDruidCatCower = 404;
	FlyDruidBearSwipe = 405;
	FlyDruidBearBite = 406;
	FlyDruidBearMaul = 407;
	FlyDruidBearBash = 408;
	FlyDragonTail = 409; 
	FlyDragonStomp = 410;
	FlyDragonSpit = 411;
	FlyDragonSpitHover = 412;
	FlyDragonSpitFly = 413; 
	FlyEmoteYes = 414;
	FlyEmoteNo = 415;
	FlyJumpLandRun = 416;
	FlyLootHold = 417;
	FlyLootUp = 418;
	FlyStandHigh = 419;
	FlyImpact = 420;
	FlyLiftOff = 421;
	FlyHover = 422;
	FlySuccubusEntice = 423;
	FlyEmoteTrain = 424;
	FlyEmoteDead = 425;
	FlyEmoteDanceOnce = 426;
	FlyDeflect = 427;
	FlyEmoteEatNoSheathe = 428;
	FlyLand = 429;
	FlySubmerge = 430;
	FlySubmerged = 431;
	FlyCannibalize = 432;
	FlyArrowBirth = 433;
	FlyGroupArrowBirth = 434;
	FlyCorpseArrowBirth = 435;
	FlyGuideArrowBirth = 436;
	FlyEmoteTalkNoSheathe = 437;
	FlyEmotePointNoSheathe = 438;
	FlyEmoteSaluteNoSheathe = 439;
	FlyEmoteDanceSpecial = 440;
	FlyMutilate = 441;
	FlyCustomSpell01 = 442;
	FlyCustomSpell02 = 443;
	FlyCustomSpell03 = 444;
	FlyCustomSpell04 = 445;
	FlyCustomSpell05 = 446;
	FlyCustomSpell06 = 447;
	FlyCustomSpell07 = 448;
	FlyCustomSpell08 = 449;
	FlyCustomSpell09 = 450;
	FlyCustomSpell10 = 451;
	FlyStealthRun = 452;
	FlyEmerge = 453;
	FlyCower = 454;
	FlyGrab = 455;
	FlyGrabClosed = 456;
	FlyGrabThrown = 457;
	ToFly = 458;
	ToHover = 459;
	ToGround = 460;
	FlyToFly = 461;
	FlyToHover = 462;
	FlyToGround = 463;
	Settle = 464;
	FlySettle = 465;
	DeathStart = 466;
	DeathLoop = 467;
	DeathEnd = 468;
	FlyDeathStart = 469;
	FlyDeathLoop = 470;
	FlyDeathEnd = 471;
	DeathEndHold = 472;
	FlyDeathEndHold = 473;
	Strangulate = 474;
	FlyStrangulate = 475;
	ReadyJoust = 476;
	LoadJoust = 477;
	HoldJoust = 478;
	FlyReadyJoust = 479;
	FlyLoadJoust = 480;
	FlyHoldJoust = 481;
	AttackJoust = 482;
	FlyAttackJoust = 483;
	ReclinedMount = 484;
	FlyReclinedMount = 485;
	ToAltered = 486;
	FromAltered = 487;
	FlyToAltered = 488;
	FlyFromAltered = 489;
	InStocks = 490;
	FlyInStocks = 491;
	VehicleGrab = 492;
	VehicleThrow = 493;
	FlyVehicleGrab = 494;
	FlyVehicleThrow = 495;
	ToAlteredPostSwap = 496;
	FromAlteredPostSwap = 497;
	FlyToAlteredPostSwap = 498;
	FlyFromAlteredPostSwap = 499;
	ReclinedMountPassenger = 500;
	FlyReclinedMountPassenger = 501;
	Carry2H = 502;
	Carried2H = 503;
	FlyCarry2H = 504;
	FlyCarried2H = 505;
	EmoteSniff = 506;
	EmoteFlySniff = 507;
	AttackFist1H = 508;
	FlyAttackFist1H = 509;
	AttackFist1HOff = 510;
	FlyAttackFist1HOff = 511;
	ParryFist1H = 512;
	FlyParryFist1H = 513;
	ReadyFist1H = 514;
	FlyReadyFist1H = 515;
	SpecialFist1H = 516;
	FlySpecialFist1H = 517;
	EmoteReadStart = 518;
	FlyEmoteReadStart = 519;
	EmoteReadLoop = 520;
	FlyEmoteReadLoop = 521;
	EmoteReadEnd = 522;
	FlyEmoteReadEnd = 523;
	SwimRun = 524;
	FlySwimRun = 525;
	SwimWalk = 526;
	FlySwimWalk = 527;
	SwimWalkBackwards = 528;
	FlySwimWalkBackwards = 529;
	SwimSprint = 530;
	FlySwimSprint = 531;
	MountSwimIdle = 532;
	FlyMountSwimIdle = 533;
	MountSwimBackwards = 534;
	FlyMountSwimBackwards = 535;
	MountSwimLeft = 536;
	FlyMountSwimLeft = 537;
	MountSwimRight = 538;
	FlyMountSwimRight = 539;
	MountSwimRun = 540;
	FlyMountSwimRun = 541;
	MountSwimSprint = 542;
	FlyMountSwimSprint = 543;
	MountSwimWalk = 544;
	FlyMountSwimWalk = 545;
	MountSwimWalkBackwards = 546;
	FlyMountSwimWalkBackwards = 547;
	MountFlightIdle = 548;
	FlyMountFlightIdle = 549;
	MountFlightBackwards = 550;
	FlyMountFlightBackwards = 551;
	MountFlightLeft = 552;
	FlyMountFlightLeft = 553;
	MountFlightRight = 554;
	FlyMountFlightRight = 555;
	MountFlightRun = 556;
	FlyMountFlightRun = 557;
	MountFlightSprint = 558;
	FlyMountFlightSprint = 559;
	MountFlightWalk = 560;
}
"	0	0				
675	Global Constants - Animation Table 4	"AnimTable4 =
{

	FlySpellKneelLoop = 370;
	FlySpellKneelEnd = 371;
	FlySprint = 372;
	FlyInFlight = 373;
	FlySpawn = 374;
	FlyClose = 375;
	FlyClosed = 376;
	FlyOpen = 377;
	FlyOpened = 378;
	FlyDestroy = 379;
	FlyDestroyed = 380;
	FlyRebuild = 381;
	FlyCustom0 = 382;
	FlyCustom1 = 383;
	FlyCustom2 = 384;
	FlyCustom3 = 385;
	FlyDespawn = 386;
	FlyHold = 387;
	FlyDecay = 388; 
	FlyBowPull = 389;
	FlyBowRelease = 390;
	FlyShipStart = 391;
	FlyShipMoving = 392;
	FlyShipStop = 393;
	FlyGroupArrow = 394;
	FlyArrow = 395;
	FlyCorpseArrow = 396;
	FlyGuideArrow = 397;
	FlySway = 398;
	FlyDruidCatPounce = 399;
--
	BartenderEmoteTalk = 600;
	FlyBartenderEmoteTalk = 601;
	BartenderEmotePoint = 602;
	FlyBartenderEmotePoint = 603;
	BarmaidStand = 604;
	FlyBarmaidStand = 605;
	BarmaidWalk = 606;
	FlyBarmaidWalk = 607;
	BarmaidRun = 608;
	FlyBarmaidRun = 609;
	BarmaidShuffleLeft = 610;
	FlyBarmaidShuffleLeft = 611;
	BarmaidShuffleRight = 612;
	FlyBarmaidShuffleRight = 613;
	BarmaidEmoteTalk = 614;
	FlyBarmaidEmoteTalk = 615;
	BarmaidEmotePoint = 616;
	FlyBarmaidEmotePoint = 617;
	MountSelfIdle = 618;
	FlyMountSelfIdle = 619;
	MountSelfWalk = 620;
	FlyMountSelfWalk = 621;
	MountSelfRun = 622;
	FlyMountSelfRun = 623;
	MountSelfSprint = 624;
	FlyMountSelfSprint = 625;
	MountSelfRunLeft = 626;
	FlyMountSelfRunLeft = 627;
	MountSelfRunRight = 628;
	FlyMountSelfRunRight = 629;
	MountSelfShuffleLeft = 630;
	FlyMountSelfShuffleLeft = 631;
	MountSelfShuffleRight = 632;
	FlyMountSelfShuffleRight = 633;
	MountSelfWalkBackwards = 634;
	FlyMountSelfWalkBackwards = 635;
	MountSelfSpecial = 636;
	FlyMountSelfSpecial = 637;
	MountSelfJump = 638;
	FlyMountSelfJump = 639;
	MountSelfJumpStart = 640;
	FlyMountSelfJumpStart = 641;
	MountSelfJumpEnd = 642;
	FlyMountSelfJumpEnd = 643;
	MountSelfJumpLandRun = 644;
	FlyMountSelfJumpLandRun = 645;
	MountSelfStart = 646;
	FlyMountSelfStart = 647;
	MountSelfFall = 648;
	FlyMountSelfFall = 649;
	Stormstrike = 650;
	FlyStormstrike = 651;
	ReadyJoustNoSheathe = 652;
	FlyReadyJoustNoSheathe = 653;
	Slam = 654;
	FlySlam = 655;
	DeathStrike = 656;
	FlyDeathStrike = 657;
	SwimAttackUnarmed = 658;
	FlySwimAttackUnarmed = 659;
	SpinningKick = 660;
	FlySpinningKick = 661;
	RoundHouseKick = 662;
	FlyRoundHouseKick = 663;
	RollStart = 664;
	FlyRollStart = 665;
	Roll = 666;
	FlyRoll = 667;
	RollEnd = 668;
	FlyRollEnd = 669;
	PalmStrike = 670;
	FlyPalmStrike = 671;
	MonkOffenseAttackUnarmed = 672;
	FlyMonkOffenseAttackUnarmed = 673;
	MonkOffenseAttackUnarmedOff = 674;
	FlyMonkOffenseAttackUnarmedOff = 675;
	MonkOffenseParryUnarmed = 676;
	FlyMonkOffenseParryUnarmed = 677;
	MonkOffenseReadyUnarmed = 678;
	FlyMonkOffenseReadyUnarmed = 679;
	MonkOffenseSpecialUnarmed = 680;
	FlyMonkOffenseSpecialUnarmed = 681;
	MonkDefenseAttackUnarmed = 682;
	FlyMonkDefenseAttackUnarmed = 683;
	MonkDefenseAttackUnarmedOff = 684;
	FlyMonkDefenseAttackUnarmedOff = 685;
	MonkDefenseParryUnarmed = 686;
	FlyMonkDefenseParryUnarmed = 687;
	MonkDefenseReadyUnarmed = 688;
	FlyMonkDefenseReadyUnarmed = 689;
	MonkDefenseSpecialUnarmed = 690;
	FlyMonkDefenseSpecialUnarmed = 691;
	MonkHealAttackUnarmed = 692;
	FlyMonkHealAttackUnarmed = 693;
	MonkHealAttackUnarmedOff = 694;
	FlyMonkHealAttackUnarmedOff = 695;
	MonkHealParryUnarmed = 696;
	FlyMonkHealParryUnarmed = 697;
	MonkHealReadyUnarmed = 698;
	FlyMonkHealReadyUnarmed = 699;
	MonkHealSpecialUnarmed = 700;
	FlyMonkHealSpecialUnarmed = 701;
	FlyingKick = 702;
	FlyFlyingKick = 703;
	FlyingKickStart = 704;
	FlyFlyingKickStart = 705;
	FlyingKickEnd = 706;
	FlyFlyingKickEnd = 707;
	CraneStart = 708;
	FlyCraneStart = 709;
	CraneLoop = 710;
	FlyCraneLoop = 711;
	CraneEnd = 712;
	FlyCraneEnd = 713;
	Despawned = 714;
	FlyDespawned = 715;
}
"	0	0				
681	Global Constants - Animation Table 5	"AnimTable5 =
{
	FlyMountFlightWalk = 561;
	MountFlightWalkBackwards = 562;
	FlyMountFlightWalkBackwards = 563;
	MountFlightStart = 564;
	FlyMountFlightStart = 565;
	MountSwimStart = 566;
	FlyMountSwimStart = 567;
	MountSwimLand = 568;
	FlyMountSwimLand = 569;
	MountSwimLandRun = 570;
	FlyMountSwimLandRun = 571;
	MountFlightLand = 572;
	FlyMountFlightLand = 573;
	MountFlightLandRun = 574;
	FlyMountFlightLandRun = 575;
	ReadyBlowDart = 576;
	FlyReadyBlowDart = 577;
	LoadBlowDart = 578;
	FlyLoadBlowDart = 579;
	HoldBlowDart = 580;
	FlyHoldBlowDart = 581;
	AttackBlowDart = 582;
	FlyAttackBlowDart = 583;
	CarriageMount = 584;
	FlyCarriageMount = 585;
	CarriagePassengerMount = 586;
	FlyCarriagePassengerMount = 587;
	CarriageMountAttack = 588;
	FlyCarriageMountAttack = 589;
	BartenderStand = 590;
	FlyBartenderStand = 591;
	BartenderWalk = 592;
	FlyBartenderWalk = 593;
	BartenderRun = 594;
	FlyBartenderRun = 595;
	BartenderShuffleLeft = 596;
	FlyBartenderShuffleLeft = 597;
	BartenderShuffleRight = 598;
	FlyBartenderShuffleRight = 599;
	ThousandFists = 716;
	FlyThousandFists = 717;
	MonkHealReadySpellDirected = 718;
	FlyMonkHealReadySpellDirected = 719;
	MonkHealReadySpellOmni = 720;
	FlyMonkHealReadySpellOmni = 721;
	MonkHealSpellCastDirected = 722;
	FlyMonkHealSpellCastDirected = 723;
	MonkHealSpellCastOmni = 724;
	FlyMonkHealSpellCastOmni = 725;
	MonkHealChannelCastDirected = 726;
	FlyMonkHealChannelCastDirected = 727;
	MonkHealChannelCastOmni = 728;
	FlyMonkHealChannelCastOmni = 729;
	Torpedo = 730;
	FlyTorpedo = 731;
}
"	0	0				
682	Brazie\'s PetBattle - Dispatcher - Default Result Handlers	"
function GetDefaultHandlerTable(result, index)
	local handlerTable = {
		[PetBattleEffect.SetHealth] = {
			dontWait = true;

			successEffect = successEffect_visual;
			failureEffect = failureEffect_visual;

			func = set_health_func;
			args = { result.target.newHealth };
		};
		[PetBattleEffect.AuraApply] = {
			dontWait = true;

			successEffect = successEffect_visual;
			failureEffect = failureEffect_visual;

			func = apply_aura_func;
			args = { result.target.auraInstanceID, result.target.turnsRemaining, result.target.auraVisualID };
		};
		[PetBattleEffect.AuraCancel] = {
			dontWait = true;
			func = aura_change_func;
			args = { result.target.auraInstanceID, result.target.turnsRemaining, true };

		};	
		[PetBattleEffect.AuraChange] = {
			dontWait = true;
			func = aura_change_func;
			args = { result.target.auraInstanceID, result.target.turnsRemaining, false };

		};	
		[PetBattleEffect.PetSwap] = {

			dontWait = false;

			func = swap_func;
			args = { result.casterPlayerID, result.newFrontPet };
		};
		[PetBattleEffect.StatusChange] = {
			dontWait = true;
			func = status_change_func;
			args = { result };
		};
		[PetBattleEffect.SetState] = {
			dontWait = true;
			func = set_state_func;
			args = { result };
		};
	};

	return handlerTable;
end"	0	0				
683	Brazie\'s PetBattle - Dispatcher - Result Stub - ChangeStatus	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function status_change(effect)
	if (not effect) then
		return
	end
print(\Debugging Status Change Table\"");"						
685	[1] Turn Package - Stampede With Clones	"opponent.actor:GetPosition() );
				if ( remainder < 1 ) then
					petFirstHit = true;
					doEffect(false);
					petDelay = timeSpent + petStartingPoint:Dist( centerEndingPoint ) / cloneSpeed;
				else
					petDelay = 0.1;
				end
			elseif ( not petArrived ) then 

				local remainder = pet.actor:GetPosition():Dist( centerEndingPoint );

				if ( remainder < 4 or not pet.actor:IsMoving() ) then 
					--pet.actor:Fade(0,0.5); 
					petArrived = true;
					petDelay = timeSpent + 0.05
				else
					petDelay = timeSpent + 0.05
				end
			elseif ( not petTeleport ) then 

				pet.actor:MoveToAbs(centerStartingPoint, 0);
				petTeleport = true;
				petDelay = timeSpent + 0.05
			elseif ( pet.actor:GetPosition():Dist( centerStartingPoint ) < 1 and not pet.actor:IsMoving() ) then 
				pet.actor:MoveToAbs(petStartingPoint,  2);				
			end
		end

		if ( timeSpent >= nextWave ) then 
			for j = 1, cols do 
				local v = objectTable[(waveIndex-1)*#turn.effects+j];

				if ( v ) then
					createData.transform = Transform:New(centerStartingPoint + Vector:New(v.f,v.l,0),0);
					local actor = scene:SpawnActor(createData);

					v.actor = actor;
					v.destination = FastLocalFacingCoordinates(opponent.actor:GetPosition(), petStartingPoint, Vector:New(-8+v.f,v.l,0) );
					v.actor:Fade(1,0.5);

					local moveTime = v.actor:GetPosition():Dist( v.destination ) / cloneSpeed;

					v.actor:MoveToAbs( v.destination, moveTime )
				end
			end

			waveIndex = waveIndex + 1;
			nextWave = timeSpent + waveDelay			
		end
	

		-- Used to filter effects
		if ( timeSpent > effectDelay ) then
			doEffect(true);
		end

		scene:WaitTimer(delay)
		timeSpent = timeSpent + delay;
		cleanUpCheck(false);
	end

	pet.actor:MoveToAbs(petStartingPoint, pet.actor:GetPosition():Dist( petStartingPoint ) / cloneSpeed);
	
	while ( #objectTable > 0 ) do
		cleanUpCheck(true);
		scene:WaitTimer(0.1)
	end

	-- Wait until the pet is home
	pet.actor:WaitMovementComplete()
	pet.actor:SetFacingToAbs(opponent.actor:GetPosition())
	pet.actor:Fade(1,0);

	-- Reset/reposition
	Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );

end"	684	0				
686	Turn Package - Huge Knockback on Multi Hit	"function Dispatcher_HugeKnockbackOnMultiHit( ROID, isTurn, turn )

	-- Only handle \effect\"" objects"						
691	Turn Package - Use Secondary Spell Visual on Multi Hit	"function Dispatcher_AlternateVisualOnMultiHit( secondaryVisualID, ROID, isTurn, turn )

	-- Only handle \effect\"" objects"						
693	Dispatcher_IonCannon	"function Dispatcher_IonCannon( ROID, isTurn, turn )
	-- Only handle \effect\"" objects"						
--								
--								
--								
--								
--								
--								
--	nazgrim:PlaySoundKit(13169, true)							
--								
--								
--	transform.position = transform.position + Vector:New(0, 0.1, 0)							
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--								
--	"print(\""Casting Trap...\"")"							
--	"print(\""Casting Trap...\"")"							
--		"\""dead\"" - pet was dead and remained dead"						
--		"\""respawn\"" - pet was dead and is now alive"						
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
--------------------------------------------------------------------------------								
 								
 								
 								
-- 								
  	return Vector:New(							
    return %s								
    return %s								
"    STATE_Condition_WasDamagedThisTurn = 28;"								
"    STATE_healthBonus = 17;"								
"    STATE_Is_Dead = 1;"								
"    STATE_Last_HitDealt = 32;"								
"    STATE_Last_HitTaken = 31;"								
"    STATE_maxHealthBonus = 2;"								
"    STATE_Mechanic_IsBurning = 34;"								
"    STATE_Mechanic_IsChilled = 52;"								
"    STATE_Mechanic_IsFlying = 33;"								
"    STATE_Mechanic_IsInvisible = 67;"								
"    STATE_Mechanic_IsPoisoned = 21;"								
"    STATE_Mechanic_IsStunned = 22;"								
"    STATE_Mechanic_IsUnderground = 30;"								
"    STATE_Mechanic_IsWebbed = 64;"								
"    STATE_Mod_DamageDealtPercent = 23;"								
"    STATE_Mod_DamageTakenPercent = 24;"								
"    STATE_Mod_HealingDealtPercent = 65;"								
"    STATE_Mod_HealingTakenPercent = 66;"								
"    STATE_Mod_SpeedPercent = 25;"								
"    STATE_Passive_Aquatic = 51;"								
"    STATE_Passive_Beast = 43;"								
"    STATE_Passive_Critter = 42;"								
"    STATE_Passive_Dragon = 46;"								
"    STATE_Passive_Elemental = 47;"								
"    STATE_Passive_Flying = 45;"								
"    STATE_Passive_Humanoid = 44;"								
"    STATE_Passive_Magic = 49;"								
"    STATE_Passive_Mechanical = 48;"								
"    STATE_Passive_Undead = 50;"								
"    STATE_Ramping_DamageID = 26;"								
"    STATE_Ramping_DamageUses = 27;"								
"    STATE_speedBonus = 3;"								
"    STATE_Stat_Accuracy = 41;"								
"    STATE_Stat_CritChance = 40;"								
"    STATE_Stat_Kharma = 4;"								
"    STATE_Stat_Power = 18;"								
"    STATE_Stat_Speed = 20;"								
"    STATE_Stat_Stamina = 19;"								
"    STATE_swapLock = 36;"								
"    STATE_turnLock = 35;"								
"    STATE_untargettable = 29;"								
"    STATE_Weather_ArcaneStorm = 54;"								
"    STATE_Weather_Blizzard = 58;"								
"    STATE_Weather_BurntEarth = 53;"								
"    STATE_Weather_Darkness = 56;"								
"    STATE_Weather_LightningStorm = 62;"								
"    STATE_Weather_Moonlight = 55;"								
"    STATE_Weather_Mud = 59;"								
"    STATE_Weather_Rain = 60;"								
"    STATE_Weather_Sandstorm = 57;"								
"    STATE_Weather_Sunlight = 61;"								
"    STATE_Weather_Windy = 63;"								
  customFunc(...)								
  customFunc(effects)								
  end								
  end								
  local customFunc = function(...)								
  local customFunc = function(effects)								
  return true								
  return true								
-- allianceShipDest = Vector:New(3603.17, -571.637, 0)								
-- Call in the Pandas, look at each, and then walk off with stinky one								
-- CastSpellAtActor( caster, target, spellID, faceTarget [default = false] )								
-- CastSpellAtActor( caster, target, spellID, faceTarget [default = false] )								
-- Clear scene 1, setup for scene 4								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
-- Done with War, queue merchants								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- Fade in on command, beckon at little grummle								
-- FadeIn( actor, fadeTime [ default = 0.5 ] )								
-- FadeIn( actor, fadeTime [ default = 0.5 ] )								
-- FadeIn( hozen01, 1)								
-- FadeIn( hozen02, 1)								
-- FadeIn( moguSlaver01, 1)								
-- FadeIn( pandarenSlave01, 1)								
-- FadeOut( actor, fadeTime [ default = 2 ] )								
-- FadeOut( actor, fadeTime [ default = 2 ] )								
-- FadeOut( fireWall01, 0 )								
-- FadeOut( hozen01, 1)								
-- FadeOut( hozen02, 1)								
-- FadeOut( mist, 5)								
-- FadeOut( moguSlaver01, 1)								
-- FadeOut( pandarenSlave01, 1)								
-- FadeOut(fogbunny1, 1)								
-- FadeOut(fogbunny2, 1)								
-- FadeOut(fogbunny3, 1)								
-- fireWall01 = SpawnModelActor( fireWallModel, 3617.5, 1754.9, 742.973, 45, 0.4 )								
"-- fogbunny3: Despawn()"""	0	0						
"-- hozen01: Despawn()"""	0	0						
-- hozen01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"-- hozen02: Despawn()"""	0	0						
-- hozen02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
-- if you have an actor somewhere in the global scope, follow it								
-- len = #v1 -- NOTE: this doesn\'t work in Lua 5.1!								
-- Let the talking happen then trigger scene 5								
-- Lua 5.1 at least								
-- Lua 5.1 at least								
"-- moguSlaver01: Despawn()"""	0	0						
-- moguSlaver01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
-- moguStatue01 = SpawnModelActor( moguStatueModel, 3739.53, 1657.26, 742.974, 180, 3 )								
"-- moguStatueModel = \""WORLD\\EXPANSION04\\DOODADS\\MOGU\\Mogu_Statue_Double.M2\"""								
"-- pandarenSlave01: Despawn()"""	0	0						
-- pandarenSlave01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
-- PlayLoopingSplitBodyAnim( actor, anim )								
-- PlayLoopingSplitBodyAnim( actor, anim )								
-- PlayOneShotSplitBodyAnim( actor, anim )								
-- PlayOneShotSplitBodyAnim( actor, anim )								
"-- relativeMover:StopLoopingFullBodyAnim()"""	0	0						
-- RunToLocation( actor, speed, x, y, z, facing [default = direction of travel] )								
-- RunToLocation( actor, speed, x, y, z, facing [default = direction of travel] )								
-- RunToLocation( hozen01, 2, 1466.88, 375.627, 550.221  )								
-- RunToLocation( hozen02, 2, 1464.94, 373.747, 550.222 )								
-- RunToLocation( moguSlaver01, 2, 1467.81, 372.467, 550.222 )								
-- RunToLocation( pandarenSlave01, 2, 1466.88, 375.627, 550.221 )								
-- RunToLocation(allianceShip, 10, 4113.9, -581.805, 0)								
"-- say \""Ah! Here we are. Over 14,000 years ago, this entire land was ruled by a terrible race of warlords called \'The mogu\'.\"""								
"-- say \""The hozen are many things, but they are not cowards - not for long. To lead them, you must inspire them!\"""								
"-- say \""The mogu ruled through FEAR. And fear kept them in power - until the first Pandaren monks taught my people COURAGE. And the mogu were overthrown.\"""								
"-- say \""You see, those who lead through fear only stay in power while those they govern lack courage.\"""								
-- Scene 6								
-- scene:SetCamera(341,0,nil,nil)								
-- scene:SetCamera(342,10,nil,nil)								
-- scene:SetCamera(343,2,nil,nil) -- ready to zoom								
-- scene:SetCamera(344,3,nil,nil) -- zoom								
-- scene:SetCamera(367, 10, nil, nil)								
-- scene:SetCamera(381, 0, nil, nil)								
-- scene:SetCamera(391, 25, nil, nil)								
-- scene:WaitTimer(1.5)								
"-- SendTrigger( \""priestTrigger\"" )"								
"-- SendTrigger( \""priestTrigger\"" )"								
-- spawn Alliance Crewman 01								
-- spawn Alliance Crewman 02								
-- spawn Alliance Crewman 03								
-- spawn Alliance Crewman 04								
-- spawn Alliance Crewman 05								
-- spawn zeppelin fire 01								
-- spawn zeppelin fire 02								
-- spawn zeppelin fire 03								
-- spawn zin\'jun								
-- spawn zin\'jun								
-- Start Scene 2								
-- Start Scene 3								
-- Start Scene 4								
-- TODO: add a pcall for safety, but pcall where the function can yield requires								
-- TODO: add a pcall for safety, but pcall where the function can yield requires								
-- vanguard04 = SpawnActor( vanguard04CreatureID, 3449.31, -278.87, 266.9, 209.976, 1.0, false )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait ( 2 )								
-- Wait for end of Scene 5								
-- Wait for Scene 4								
-- Wait for Scene 4								
-- Wait for Scene 4 ending								
-- Wait for Scene 5								
-- Wait for scene 5 trigger then cross stage right								
-- Wait for scene 5 trigger then cross stage right								
-- Wait for scene 5 trigger then cross stage right								
-- Wait for things to play out and then clear scene 4 and queue scene 6								
-- Wait until dismissed and setup for scene 6								
-- Wait until tree hits lead grummle, then cross and exit stage right								
-- Wait until tree hits lead grummle, then cross and exit stage right								
-- Wait until tree hits lead grummle, then cross and exit stage right								
-- Wait until tree hits lead grummle, then cross and exit stage right								
-- Wait(0.3)								
"-- WaitForTrigger( \""shipMove\"" )"								
-- worldport 0, -13191.1, 259.751, 21.8579, 88.5582								
"	0	0
"								
"	0	0
10	Global Functions - Math"""	"--
-- Vector Functions
--
function Vector:New(_x, _y, _z)
	local v = { x = _x or 0, y = _y or 0, z = _z or 0 }
	setmetatable(v, self.__meta)
	return v
end

function Vector:ToString()
	return string.format(\(%.3f, %.3f, %.3f)\"", self.x, self.y, s"							
"	0	0
11	Darren\'s Test Scene Script 3"""	"print(\-- START: Darren\'s Test Script 3 --\"")"							
"	0	0
116	Kun Lai Summit - Reclaiming the Thunder God - Mogu Door 01 - JSB"""	"-- close door
moguDoor01:PlayLoopingFullBodyAnim(Animations.Closed) 

Wait(8)
moguDoor01:StopLoopingFullBodyAnim()
moguDoor01:PlayLoopingAnimKit(2209)"	0	0					
"	0	0
12	Darren\'s Test Scene Script 5"""	"print(\-- START: Darren\'s Test Scene Script 5\"")"							
"	0	0
13	Darren\'s Movement and Facing Test"""	"print(\-- START: Darren\'s Movement and Facing Test --\"")"							
"	0	0
14	Kun Lai Summit - Horde Hub Swap Scene - Worker 01 - JSB"""	"
-- small tent panda 01
-- wait a little before running in
Wait(2)
FadeIn( panda01, 1 )

-- run to the tents
RunToLocation( panda01, 5.5, 2290.39, 944.073, 481.63, 341.549 )

Wait(1)

-- throw bucket at tents
CastSpellAtActor( panda01, fire03.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire02 )
PutOutFire( fire03 )
PutOutFire( fire14 )

Wait(1)

RunToLocation( panda01, 3, 2293.17, 950.125, 481.201, 337.517 )

PlayLoopingSplitBodyAnim( panda01, Animations.EmoteWork )

Wait(2)

FadeOut( fire02.smoke )
FadeOut( fire03.smoke )
FadeOut( fire14.smoke )

Wait(1)

FadeIn( workDust01, 5 )
FadeIn( workDust05, 5 )

-- nazgrim trigger
WaitForTrigger( \flagPlant\"" )"							
"	0	0
146	PetBattle - Effect Cast"""	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityTurnID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, idleRadius)
	end

	local abilityTurn = petAbilityTurns[abilityTurnID]
	if not abilityTurn then
		-- ERROR:
		print(\ERROR: unknown abilityTurnID \"" .. abilityTurnID)"							
"	0	0
147	PetBattle - Intro"""	"
--------------------------------------------------------------------------------
function BattleIntro()

	SetCamera(1)
	if (battleScene.SignalOpeningStart) then
		battleScene:SignalOpeningStart()
	end

	WaitAllPetsLoaded()

	scene:WaitTimer(0.25)
	SetCamera(2)
	scene:WaitTimer(0.75)
	
	if (battleScene.SignalReadyToStart) then
		battleScene:SignalReadyToStart()
	else
		battleScene:SignalOpeningComplete()
	end

	-- fade in the pets
	FadeInAllPets(initialFadeInTime)

end
"	0	0					
"	0	0
153	Jade Forest - Horde Intro Scene - Nazgrim - JSB"""	"
WaitForTrigger( \nazgrimTalk\"" )"							
"	0	0
154	Cinematic Framework - Spawning"""	"
--
-- SpawnModelActor( modelFileName, pointsPathID, snapToGround [=true] )
--   Spawn an uninteractible actor
--
function SpawnModelActorsAtPoints( modelFileName, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.model = modelFileName
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	return actors

end


function SpawnActorAtPoint( creatureID, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.creatureID =  creatureID
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	return actors[1]

end

function SpawnFadedActorAtPoint( creatureID, pointsPathID, snapToGround )

	createData = ActorCreateData:Default()
	createData.creatureID =  creatureID
	createData.groundSnap = (snapToGround ~= false)
	createData.interactible = false

	local actors = scene:SpawnActorsAtPoints( createData, pointsPathID )
	local actor = actors[1]
	FadeOut(actor, 0)
	return actor

end
"	0	0					
"	0	0
156	Jade Forest - Horde Intro Scene - Alliance Ship - JSB"""	"

allianceShipDest = Vector:New(3650.85, -622.323, 0)
allianceShipMoveTime = 25


allianceShipSrc = allianceShip:GetPosition()
allianceShipMoveOffset = allianceShipDest - allianceShipSrc

-- force the ship to face a direction
allianceShip:SetFacingToAbs(Vector:New(3416.34, -985.503, 0))

WaitForTrigger( \allianceShip\"" )"							
"	0	0
160	PetBattle - Prototype 2.0 - Constants"""	"--------------------------------------------------------------------------------
if (not MissReasons) then
	MissReasons = { }
end

if (not PetBattleMoveFailureReason) then
	PetBattleMoveFailureReason = { }
end

if (not PetBattlePetID) then
	PetB"							
"	0	0
161	PetBattle - Prototype 2.0 - Functions"""	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function GetAlpha(pet)
	
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end

end
"	0	0					
"	0	0
163	PetBattle - Prototype 2.0 - Effect Shared"""	"
--------------------------------------------------------------------------------
-- Helper Functions for processing effects

local currentEffectInstanceID = nil

function ProcessEffect(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType
	local effectType = event.effectType

	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.RoundEffect) then

		-- battle round effects
		if (effectType == PetBattleEffect.SetHealth) then
			-- test: run set custom scripts on set health
			local abilityVisual = petAbilityVisuals[event.abilityVisualID]
			local processed = nil
			if (abilityVisual and abilityVisual.scriptFunction) then
				if ( abilityVisual.scriptFunction( {event} ) ) then
					processed = true
				end
			end
			if (not processed) then 
				EffectSetHealth(event)
			end
		elseif (effectType == PetBattleEffect.AuraApply) then
			EffectAuraApply(event)
		elseif (effectType == PetBattleEffect.AuraCancel) then
			EffectAuraChange(event, true)
		elseif (effectType == PetBattleEffect.AuraChange) then
			EffectAuraChange(event, false)
		elseif (effectType == PetBattleEffect.PetSwap) then
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		elseif (effectType == PetBattleEffect.StatusChange) then
			-- HACK - for backwards compatibility
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		end

	end

	-- Ensure the current effect was processed
	SignalEffectProcessed()

	if (battleScene and battleScene:HasPendingEffects() == false) then
		ResetActivePets()
	end

	return true
end

--------------------------------------------------------------------------------
function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end

-- TODO: add a pcall for safety, but pcall where the function can yield requires
-- Lua 5.1 at least
local createFormatString = [[
return function(effects)
  local customFunc = function(effects)
    return %s
  end
  customFunc(effects)
  return true
end
]]

function LoadCustomVisualScript(abilityVisual)
	if (not abilityVisual) then
		return
	end

	local customScriptString = abilityVisual.scriptFunctionString
	if (customScriptString and #customScriptString > 0) then
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)
		local status, result = pcall(loadstring(createString))
		if (status == true) then
			setfenv(result, getfenv())
			abilityVisual.scriptFunction = result
		else
			print(\ERROR: loading script on BattlePetVisual ID=\"" .. abilityVisual.ID .. \"" failed: \"" .. createString)"							
"	0	0
164	PetBattle - Prototype 2.0 - Effect Cast"""	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, idleRadius)
	end

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local attackRadius = idleRadius
	if abilityVisual.range == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif abilityVisual.range == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	
	-- move front pet to the correct radius, if it was the caster
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then
		WaitMoveToRadius(casterFrontPet, attackRadius)
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (casterCastingPet.actor ~= targetPet.actor) then
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(
				spellVisualID,
				abilityVisual.impactTime,
				true,
				{targetPet.actor})
		else
			-- self targeted
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
		end
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return casterCastingPet, spellVisualID
end
"	0	0					
"	0	0
167	PetBattle - Prototype 2.0 - Effect Aura Apply"""	"
--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local auraVisualID = 0
	if (effect.targets[1]) then
		auraVisualID = effect.targets[1].auraVisualID
	end

	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, auraVisualID)
	if (not auraVisualID) or (auraVisualID == 0) then
		print(\WARNING: no auraVisual for aura\"")"							
"	0	0
168	PetBattle - Prototype 2.0 - Effect Aura Change"""	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	for index, target in pairs(effect.targets) do
		local petPlayerID = target.playerID
		local petSlot = target.petSlot

		local player = GetTeamByIndex(petPlayerID)
		local pet = player.pets[petSlot]

		if not petSlot then
			return
		end

		local auraInstanceID = target.auraInstanceID
		local aura = pet.auras[auraInstanceID]
		if not aura then
			print(\ERROR: unknown aura instance ID \"" .. auraInstanceID)"							
"	0	0
169	PetBattle - Prototype 2.0 - Test Teams"""	"--------------------------------------------------------------------------------
-- Test Teams
function InitTestTeams()

	local currentAbilityID = 0
	local abilityID = function()
		currentAbilityID = currentAbilityID + 1
		return currentAbilityID
"	0	0					
"	0	0
17	PetBattle - Effect Swap"""	"--------------------------------------------------------------------------------
-- SWAP
function EffectSwap(teamId, petIndex)

	ResetActivePets()
	
	local team = GetTeamByIndex(teamId)
	if team.activePet == petIndex then
		return
	end

	local "	0	0					
"	0	0
192	Jade Forest - Horde Intro Scene - Rivett - JSB"""	"
WaitForTrigger( \gorrokMove\"" )"							
"	0	0
193	Jade Forest - Horde Intro Scene - Special Fog - JSB"""	"
WaitForTrigger( \rivettTalk\"" )"							
"	0	0
194	Jade Forest - Horde Intro Scene - Zin\'jun - JSB"""	"
WaitForTrigger( \rivettTalk\"" )"							
"	0	0
195	Jade Forest - Horde Intro Scene - Kiryn - JSB"""	"WaitForTrigger( \rivettTalk\"" )"							
"	0	0
196	Lorewalker Story - S1: Grummle - Init - Scene 1 Actors - ZTO"""	"-- Spell preloads
grummleTransformSpellID = 120566
grummleTransformEffectSpellID = 120704

-- Spawn troggs
troggID = 61900
troggMain = SpawnActor( troggID, 1447.39, 361.676, 550.221, 42.0026 ) -- Trogg protagonist
trogg01 = SpawnActor( troggID, 145"	0	0					
"	0	0
208	Lorewalker Story - S1: Grummle - GrummleMainBag - ZTO"""	"-- Grummle spawns where non-pack version of grummle is running in place
WaitForTrigger( \grummleTransform2\"" )"							
"	0	0
22	Test - Alex\'s Battle Pet - Turn Loop"""	"

scene:WaitTimer(2.0)
while 1 do

	local moveTime
	for team=1,2 do 
		local action = math.random (1, 3);

		local pet = allPlayers[team].pets[ allPlayers[team].activePet ]


		local nextTeam = math.fmod(team,2)+1;
		local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]


		if ( action == 1 ) then
			local newPetIndex = math.fmod(allPlayers[team].activePet, #allPlayers[team].pets)+1;
			newPet = allPlayers[team].pets[newPetIndex];

			-- Swap active pet
			allPlayers[team].activePet = newPetIndex

			-- Perform the emote
			allPlayers[team].master:PlayOneShotSplitBodyAnim(Animations.EmotePoint)
			scene:WaitTimer(1.0)

			-- Swap the action
			PerformSwap(pet,newPet, opponent)
		elseif ( action == 2 ) then
			PerformMove(pet,opponent)
		else
			PerformMove(pet,opponent)
		end
	end
end
scene:WaitTimer(20.0)
--
-- done

--------------------------------------------------------------------------------
print(\|cFFAAFFAAEND: Alex\'s Battle Stage|r\"");"							
"	0	0
222	Jade Forest - Horde Intro Scene - Vangard02 - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = vanguard02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDe"							
"	0	0
223	Jade Forest - Horde Intro Scene - Vangard03 - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = vanguard03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDe"							
"	0	0
225	Jade Forest - Horde Intro Scene - Shokia - JSB"""	"
WaitForTrigger( \shipSpotted\"" )"							
"	0	0
226	Jade Forest - Horde Intro Scene - Clone - JSB"""	"
WaitForTrigger( \rivettTalk\"" )"							
"	0	0
229	Jade Forest - Horde Intro Scene - Zeppelin Cannon02 - JSB"""	"zeppelinCannon02:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \zeppelinMove\"" )"							
"	0	0
230	Jade Forest - Horde Intro Scene - Zeppelin Cannon03 - JSB"""	"zeppelinCannon03:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \zeppelinMove\"" )"							
"	0	0
231	Jade Forest - Horde Intro Scene - Zeppelin Cannon04 - JSB"""	"zeppelinCannon04:SetFacingToAbs ( Vector:New (3557.96, -447.832, 148.442) )
--
-- COPY STARTS HERE
--
local relativeMover = zeppelinCannon04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + zeppelinMoveOffset

-- move to keep same offset on the ship
--relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \zeppelinMove\"" )"							
"	0	0
232	Jade Forest - Horde Intro Scene - Cannons Fire - JSB"""	"
WaitForTrigger( \zeppelinMove\"" )"							
"	0	0
233	Jade Forest - Horde Intro Scene - Init 02 - JSB"""	"-- spawn Zeppelin Cannon Targets
local zeppelinTargetBunnyCreatureID = 61997
zeppelinTarget01 = SpawnActor( zeppelinTargetBunnyCreatureID, 3609.44, -593.548, 0, 326.921, 1.0, false )
zeppelinTarget02 = SpawnActor( zeppelinTargetBunnyCreatureID, 3676.5,"							
"	0	0
234	Jade Forest - Horde Intro Scene - Cannon03 - JSB"""	"cannon03:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = cannon03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
-- relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"							
"	0	0
238	Jade Forest - Horde Intro Scene - Cannons Target 01 - Zeppelin - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = shipTarget01 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPos"							
"	0	0
239	Jade Forest - Horde Intro Scene - Cannons Target 02 - Zeppelin - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = shipTarget02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPos"							
"	0	0
240	Jade Forest - Horde Intro Scene - Cannons Target 03 - Zeppelin - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = shipTarget03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPos"							
"	0	0
241	Jade Forest - Horde Intro Scene - Cannons Target 04 - Zeppelin - JSB"""	"-- COPY STARTS HERE
--
local relativeMover = shipTarget04 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPos"							
"	0	0
242	Lorewalker Story - S1: Grummle - grummlePacker1 - ZTO"""	"-- Wait until called
WaitForTrigger(\addGrummle1\"")"							
"	0	0
247	PetBattle Template - Custom Effect"""	"print(\PetBattle: Custom Effect Script Template\"")"							
"	0	0
248	Lorewalker Story - S1: Grummle - Scene 4 - stinkyPandaren - ZTO"""	"-- Wait until called by GrummleMainBag
--WaitForTrigger(\scene4Trigger\"")"							
"	0	0
249	Lorewalker Story - S1: Grummle - Scene 4 - richPandaren - ZTO"""	"-- Wait until called by GrummleMainBag
WaitForTrigger(\scene4Trigger\"")"							
"	0	0
25	Kun Lai Summit - Horde Hub Swap Scene - Master Script - JSB"""	"
scene:WaitTimer(2)

scene:SetCamera(304,0,nil,nil) -- (camera, transition time, primary target, secondary target)
scene:SetCamera(305,26,nil,nil)

scene:WaitTimer(18) --was 28
scene:SetCamera(311,25,nil,nil)

scene:WaitTimer(18) --was 28

scene:SetCamera(306,10,nil,nil)

scene:WaitTimer(10)

scene:SetCamera(0,2,nil,nil) -- sets camera back to game-cam
"	0	0					
"	0	0
252	Siege of Niuzao Temple - The Mantid Army - Init - SLG"""	"-- spawn flyers 1
local flyerCreatureID = 62091
flyer00 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 168.81, 315.917, false )
flyer01 = SpawnActor( flyerCreatureID, 1842.57, 5277.2, 178.81, 315.917, false )
flyer02 = SpawnActor( flyerCreatureID, 18"	0	0					
"	0	0
255	Stormstout Brewery - Virmen Keg Scene - Init 2"""	"-- spawn Virmen
local virmenCreatureID = 60205

virmen49 = SpawnActor( virmenCreatureID, -729, 1244, 165, 130, 1.0, false )
virmen50 = SpawnActor( virmenCreatureID, -725, 1244, 165, 140, 1.0, false )
virmen51 = SpawnActor( virmenCreatureID, -723, 124"	0	0					
"	0	0
259	Jade Forest - Horde Intro Scene - CRASH - JSB"""	"
WaitForTrigger( \zeppelinCrash\"" )"							
"	0	0
276	Darren\'s Test 4000+"""	"print(\sub script 1!!\"")"							
"	0	0
285	Lorewalker Story - Stage Lights - UC - ZTO"""	"-- Light - Upstage Center - When Called
WaitForTrigger( \cueLight_UC\"" )"							
"	0	0
286	Lorewalker Story - Stage Lights - UR - ZTO"""	"-- Light - Upstage Right - When Called
WaitForTrigger( \cueLight_UR\"" )"							
"	0	0
287	Lorewalker Story - Stage Lights - CC - ZTO"""	"-- Light - Upstage Right - When Called
WaitForTrigger( \cueLight_CC\"" )"							
"	0	0
288	Lorewalker Story - Stage Lights - CL - ZTO"""	"-- Light - Center Left - When Called
WaitForTrigger( \cueLight_CL\"" )"							
"	0	0
293	Lorewalker Story - S1: Grummle - grummleIncenseSniffer - ZTO"""	"-- Wait until called
WaitForTrigger(\smokingGrummle\"")"							
"	0	0
308	Orgrimmar - MoP Horde Intro Scene - Zeppelin - JSB"""	"
-- PlayLoopingSplitBodyAnim( zeppelin, Animations.ShipMoving )

zeppelin:PlayLoopingAnimKit(2272)


zeppelinDest1 = Vector:New(1825.42, -4432.02, 153.1)
zeppelinDest2 = Vector:New(1954.46, -4547.58, 170.281)

zeppelinMoveSpeed = 6
zeppelinMoveOffset = zeppelinDest2 - zeppelinDest1

-- force the ship to face a direction
zeppelin:SetFacingToAbs(Vector:New(1703.49, -4311.06, 136.569))

RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest1.x, zeppelinDest1.y, zeppelinDest1.z)

WaitForTrigger( \zeppelinLeave\"" )"							
"	0	0
309	Orgrimmar - MoP Horde Intro Scene - Nazgrim - JSB"""	"
Wait ( 4 )

nazgrim:SetFacing(150)

Wait ( 1 )

nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)

Wait( 14 )

SendTrigger( \zeppelinReady\"" )"							
"	0	0
310	Orgrimmar - MoP Horde Intro Scene - Rivett - JSB"""	"
WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
311	Townlong - Dread Shadow Fight - Camera"""	"local rand = math.random(0,2)
local path


	if rand == 0 then
		path = 3159
	elseif rand == 1 then
		path = 3181
	else
		path = 3182
	end



scene:SetCamera(392, 0, nil, nil)
SetCameraFollowPath( 398, 0.0, path, nil, 1.8 )
Wait(1.5)





scene:SetCamera(0, 0, nil, nil) -- sets camera back to game-cam"	0	0					
"	0	0
313	Orgrimmar - MoP Horde Intro Scene - Snuff - JSB"""	"
Wait( 2 )
snuff:StopLoopingFullBodyAnim()
Wait( 1 )
snuff:PlayLoopingFullBodyAnim(Animations.Stand)

-- board zepp

WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
316	Orgrimmar - MoP Horde Intro Scene - Gorrok - JSB"""	"WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
317	Orgrimmar - MoP Horde Intro Scene - Clone - JSB"""	"WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
318	Orgrimmar - MoP Horde Intro Scene - Vanguard01 - JSB"""	"WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
319	Orgrimmar - MoP Horde Intro Scene - Vanguard02 - JSB"""	"WaitForTrigger( \zeppelinReady\"" )"							
"	0	0
331	PetBattle(fallback) - Functions"""	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector(pet.teamFacing, -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end

function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	"	0	536					
"	0	0
337	PetBattle(fallback) - Effect Aura Apply"""	"
--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisualID = effect.abilityVisualID
	-- print( \Application Visual ID \"" .. abilityVisualID )"							
"	0	0
338	PetBattle(fallback) - Effect Aura Change"""	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	for index, target in pairs(effect.targets) do
		local petPlayerID = target.playerID
		local petSlot = target.petSlot

		local player = GetTeamByIndex(petPlayerID)
		local pet = player.pets[petSlot]

		if not petSlot then
			return
		end

		local auraInstanceID = target.auraInstanceID
		local aura = pet.auras[auraInstanceID]
		if not aura then
			print(\ERROR: unknown aura instance ID \"" .. auraInstanceID)"							
"	0	0
341	PetBattle(fallback) - Cameras"""	"
--------------------------------------------------------------------------------
-- camera
battleCameraIDs =
{
	intro = 336;
	idle = 335;
}

local cameraBunny = nil
function StartCameraBunny(transitionTime)
	if ( not isObserved ) or ( not useFreelookCamera ) then
		return
	end

	local player = teams[observingPlayerIndex]

	local cameraBunnyCreate = ActorCreateData:Default()
	cameraBunnyCreate.name = \arenaCameraBunny\"""							
"	0	0
346	Lorewalker Story - S2: Saurok - Init - Pre-scene Actors - ZTO"""	"-- Spawn huge mogu head!!
moguFaceID = 62170
moguFace = SpawnActor( moguFaceID, 1460.83, 362.878, 550.222, 131.721, .5 ) -- Mogu Main Character
moguFace: PlayLoopingAnimKit( 2340 )
FadeOut( moguFace, 0 )"	0	0					
"	0	0
35	Test - Alex\'s Battle Pet - Test Library"""	"-- Add two vectors
function VectorSum( vectorA, vectorB ) 
	return Vector:New( vectorA.x+vectorB.x, vectorA.y+vectorB.y, vectorA.z+vectorB.z );
end

-- Distance between two points
function VectorDist( vectorA, vectorB ) 
	return math.pow (math.pow("	0	0					
"	0	0
37	Test - Alex\'s Battle Pet - Move Library 1"""	"function CalculateLocationFacingRelativeOffset(pet, location, front, left, up)
	FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );

	return FastLocalFacingCoordinates ( pet.actor:GetPosition(), location, Vector:New(front, left, up) );
end

function CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 
	local opponentLocation = opponent.actor:GetPosition();

	return CalculateLocationFacingRelativeOffset(opponent, pet.actor:GetPosition(), front, left, up);
end

function PerformRelativeBump( opponent, pet, front, left, up ) 
	local newDrift = CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up ) 

	local opponentDriftPoint 	= opponent.actor:GetPosition() + newDrift;
	local driftDistance = opponentDriftPoint:Dist( opponent.actor:GetPosition() )

	opponent.actor:MoveToAbs(opponentDriftPoint, driftDistance/battleScale/opponent.moveSpeed );

end

function PerformDodge( opponent, pet) 
	local coin = math.random(0,1);
	if ( coin == 0 ) then 
		coin = -1;
	end

	local front = 0.1;
	local left = 1*coin;
	local up = 0;

	print(\dodge\"") "							
"	0	0
380	Jade Forest - Horde Intro Scene - Alliance Crewman02 - JSB"""	"allianceCrewman02:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman02 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"							
"	0	0
381	Jade Forest - Horde Intro Scene - Alliance Crewman03 - JSB"""	"allianceCrewman03:SetFacingToAbs ( Vector:New (3362.29, -338.691, 257.81) )
--
-- COPY STARTS HERE
--
local relativeMover = allianceCrewman03 -- CHANGE allianceCaptain to the appropriate NPC

-- calculate a move to position to keep the same position relative to the ship
local worldPosSrc = relativeMover:GetPosition()
local worldPosDest = worldPosSrc + allianceShipMoveOffset

-- move to keep same offset on the ship
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)
WaitForTrigger( \allianceShip\"" )"							
"	0	0
39	Kun Lai Summit - Horde Hub Swap Scene - Init - Generic Actors 01 - JSB"""	"
smokeFadeOutTime = 10
throwBucketSpellID = 115882

-- Spawn all tents
smallPandaTentCreatureID = 60522
largePandaTentCreatureID = 60525
smallHordeTentCreatureID = 60526
largeHordeTentCreatureID = 60527
tent01 = SpawnActor( smallPandaTentCreatureID, 2302.269, 948.937, 481.253, 211 ) -- PANDA small tent 01
tent02 = SpawnActor( smallPandaTentCreatureID, 2307.038, 936.111, 481.234, 195 ) -- PANDA small tent 02
tent03 = SpawnActor( largePandaTentCreatureID, 2269.875, 897.456, 480.156, 80 ) -- PANDA Large tent
tent04 = SpawnActor( smallHordeTentCreatureID, 2302.269, 948.937, 481.253, 211 ) -- HORDE small tent
tent05 = SpawnActor( smallHordeTentCreatureID, 2307.038, 936.111, 481.234, 195 ) -- HORDE small tent
tent06 = SpawnActor( largeHordeTentCreatureID, 2269.875, 897.456, 480.156, 80 ) -- HORDE Large tent
FadeOut( tent04, 0 )
FadeOut( tent05, 0 )
FadeOut( tent06, 0 )

-- Spawn all worker pandas
pandaCreatureID = 60152
panda01 = SpawnActor( pandaCreatureID, 2280.04, 981.489, 482.941, 266.84 )
panda02 = SpawnActor( pandaCreatureID, 2286.43, 977.096, 483.15, 276.065 )
panda03 = SpawnActor( pandaCreatureID, 2272.74, 989.461, 483.852, 303.416 )
panda04 = SpawnActor( pandaCreatureID, 2278.36, 992.575, 484.587, 300.843 )
panda05 = SpawnActor( pandaCreatureID, 2269.89, 986.992, 483.538, 320.384 )
panda06 = SpawnActor( pandaCreatureID, 2224.33, 972.759, 489.625, 276.767 )
FadeOut( panda01, 0 )
FadeOut( panda02, 0 )
FadeOut( panda03, 0 )
FadeOut( panda04, 0 )
FadeOut( panda05, 0 )
FadeOut( panda06, 0 )

-- Spawn all the fires to be put out
-- SpawnFire( x, y, z, scale )
fire01 = SpawnFire( 2295.05, 964.531, 483.92, 1 ) -- banner north - TARGET
fire02 = SpawnFire( 2304.65, 937.658, 483.913, 1 ) -- tent, small - WORKER 1
fire03 = SpawnFire( 2298.1, 941.111, 481.459, 1 ) -- tent, small - WORKER 1
fire04 = SpawnFire( 2316.1, 928.04, 481.757, 1 ) -- tent, small - WORKER 2
fire05 = SpawnFire( 2308.92, 906.934, 491.892, 1 ) -- tower - WORKER 3
fire06 = SpawnFire( 2313.74, 905.326, 503.25, 1 ) -- tower - WORKER 3
fire07 = SpawnFire( 2268.93, 889.865, 499.961, 1 ) -- tent, main - WORKER 5
fire08 = SpawnFire( 2319.66, 937.674, 483.92, 1 ) -- tent, small - WORKER 2
fire09 = SpawnFire( 2322.18, 902.429, 482.895, 1 ) -- tower - WORKER 3
fire10 = SpawnFire( 2306.92, 900.443, 481.481, 2 ) -- tower - large fire - TARGET - WORKER 3
fire11 = SpawnFire( 2268.31, 895, 481.306, 2 ) -- tent, main - TARGET - WORKER 5
fire12 = SpawnFire( 2278.66, 901.373, 490.065, 1 ) -- tent, main - WORKER 5
fire13 = SpawnFire( 2262.79, 913.825, 481.15, 1 ) -- tent, main - WORKER 5
fire14 = SpawnFire( 2300.67, 947.892, 481.201, 1 ) -- tent, small - WORKER 1
fire15 = SpawnFire( 2308.14, 962.451, 485.35, 0.5 ) -- banner north, small - nearby
fire16 = SpawnFire( 2305.58, 928.971, 481.152, 0.5 ) -- tent, small, small fire - WORKER 2
fire17 = SpawnFire( 2316.01, 915.215, 481.615, 0.5 ) -- tower, small fire - WORKER 3

fire18 = SpawnFire( 2255.46, 960.028, 480.485, 0.5 ) -- off-screen, small fire - WORKER 6
fire19 = SpawnFire( 2250.81, 942.753, 485.231, 0.5 ) -- off-screen, small fire - WORKER 6
fire20 = SpawnFire( 2241.63, 902.193, 489.048, 0.5 ) -- off-screen, small fire - WORKER 6
fire21 = SpawnFire( 2242.29, 934.299, 481.146, 1 ) -- off-screen, fire - WORKER 6
fire22 = SpawnFire( 2236.61, 915.137, 481.721, 1 ) -- off-screen, fire - WORKER 6
fire23 = SpawnFire( 2245.97, 915.745, 481.147, 2 ) -- off-screen, fire - WORKER 6
fire24 = SpawnFire( 2264.56, 954.792, 481.163, 0.7 ) -- off-screen, fire - WORKER 6

"	0	0					
"	0	0
391	PetBattle(fallback) - Event Move Pet Swap Selected"""	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\Move Selected: Pet Swap Slot: \"" .. petSlot)"							
"	0	0
426	PetBattle(fallback) - Effect Status Change"""	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	for targetIndex, target in pairs(effect.targets) do
		local targetPlayer = "	0	0					
"	0	0
535	PetBattle(fallback) - Effect Processing"""	"--------------------------------------------------------------------------------
-- Group and process all round effects
local debugOn = false

function ProcessAllRoundResults(allEffects)

	if (debugOn == true) then
		print(\== Round Result Grouping"							
"	0	0
539	Jade Forest - Stay a While Scene - Cho - JSB"""	"
Wait( 5 )
cho:StopLoopingFullBodyAnim()
cho:PlayOneShotFullBodyAnim(Animations.SitGroundUp)

Wait( 2 )
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)
-- say \Thanks to your actions, the Hozen fear your people. Indulge me a moment...\"""							
"	0	0
54	Kun Lai Summit - Horde Hub Swap Scene - Worker 06 - JSB"""	"
-- off-screen panda
-- wait a little before running in
Wait(2)
FadeIn( panda06, 1 )

-- run to the tents
RunToLocation( panda06, 5.5, 2246.38, 937.082, 481.146, 302.191 )

Wait(1)

-- throw bucket at tents
-- CastSpellAtActor( panda06, fire11.bunny, throwBucketSpellID )

-- wait for missile to hit
Wait(2)
PutOutFire( fire18, smokeFadeOutTime )
PutOutFire( fire19, smokeFadeOutTime )
PutOutFire( fire20, smokeFadeOutTime )
PutOutFire( fire21, smokeFadeOutTime )
PutOutFire( fire22, smokeFadeOutTime )
PutOutFire( fire23, smokeFadeOutTime )
PutOutFire( fire24, smokeFadeOutTime )

Wait(3)

RunToLocation( panda06, 3, 2256.22, 910.613, 481.148, 327.391 )

PlayLoopingSplitBodyAnim( panda06, Animations.EmoteWork )

Wait(3)

FadeOut( fire18.smoke )
FadeOut( fire19.smoke )
FadeOut( fire20.smoke )
FadeOut( fire21.smoke )
FadeOut( fire22.smoke )
FadeOut( fire23.smoke )
FadeOut( fire24.smoke )

-- nazgrim trigger
WaitForTrigger( \flagPlant\"" )"							
"	0	0
540	Jade Forest - Stay a While Scene - Mist - JSB"""	"
WaitForTrigger( \moguAppear\"" )"							
"	0	0
55	PetBattle - Test Teams"""	"--------------------------------------------------------------------------------
-- Test Teams
function InitTestTeams()

	local currentAbilityID = 0
	local abilityID = function()
		currentAbilityID = currentAbilityID + 1
		return currentAbilityID
"	0	0					
"	0	0
557	PetBattle - Constants"""	"--------------------------------------------------------------------------------
-- spawning options
battleScale    = 1.0
spawnFwdOffset = 0.0
initialFadeInTime = 0.5

--------------------------------------------------------------------------------"							
"	0	0
558	PetBattle - Functions"""	"
function BuildVector(facing, fwd, right)
	local facingRads = math.rad(facing)
	local facingX = math.cos(facingRads)
	local facingY = math.sin(facingRads)
	
	local absPos = Vector:New(
		(facingX*fwd - facingY*right) * battleScale,
		(facingY*fwd + facingX*right) * battleScale,
		0)
	
	if spawnFwdOffset then
		absPos.x = absPos.x + spawnFwdOffset
	end

	return absPos
end

function GetTeamByIndex(teamIndex)
	return teams[teamIndex]
end

function GetActivePetByIndex(teamIndex)
	local team = GetTeamByIndex(teamIndex)
	return team.pets[team.activePet]
end


function ResetActivePets()
	-- return pets to idle
	WaitMoveToRadius(GetActivePetByIndex(1), idleRadius)
	WaitMoveToRadius(GetActivePetByIndex(2), idleRadius)
end

function LookAtOpposingTeam(pet)
	local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
	pet.actor:SetFacingToAbs(lookAtPos)
end

function SetHealth(pet, health, fullUpdate)

	local oldHealth = pet.currentHealth
	pet.currentHealth = health

	-- damage numbers feedback for observed battles
	if (isObserved) and (not fullUpdate) and (oldHealth ~= nil) then
		local change = health - oldHealth
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end

	if (pet.currentHealth <= 0) and (not pet.deathAnimKit) then
		-- HACKfix facing way off in the distance so as to effectively not rotate
		local lookAtPos = BuildVector( (pet.teamFacing or 0.0), idleRadius*1000, 0)
		pet.actor:SetFacingToAbs(lookAtPos)
		RemoveAllAuraVisuals(pet)

		-- play dead
		local deathKitID = 62
		if (fullUpdate == true) then
			-- already dead
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)
		else
			-- dieing
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)
			scene:WaitTimer(1.5)
		end

	elseif (pet.currentHealth > 0) and (pet.deathAnimKit) then
		-- resurrect
		pet.deathAnimKit:Stop()
		pet.deathAnimKit = nil
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)
		LookAtOpposingTeam(pet)
		pet.actor:Fade(GetAlpha(pet), 0.5)
		UpdateAuraVisuals(pet)
	end
end

function SetXP(pet, xp, level, fullUpdate)
	local oldXP = pet.xp
	local oldLevel = pet.level
	pet.xp = xp
	pet.level = level
	if (fullUpdate) then
		return
	end
		
	local xpChange = pet.xp - oldXP
	local levelChange = pet.level - oldLevel
	if (xpChange <= 0) and (levelChange <= 0) then
		return
	end

	if (xpChange > 0) and (pet.playerID == observingPlayerIndex) then
		pet.actor:AddWorldXPGainText(xpChange)
	end

	if (levelChange > 0) then
		pet.actor:ApplyLevelUpEffect()
	end
end

function GetAlpha(pet)
	if (pet.deathAnimKit) then
		return 0
	else
		return 1
	end
end

"	0	0					
"	0	0
565	PetBattle - Result - Aura Apply"""	"
--------------------------------------------------------------------------------
-- APPLY AURA
function EffectAuraApply(effect)

	local abilityVisualID = effect.abilityVisualID
	-- print( \Application Visual ID \"" .. abilityVisualID )"							
"	0	0
566	PetBattle - Result - Aura Change"""	"
--------------------------------------------------------------------------------
-- REMOVE AURA

function EffectAuraChange(effect, cancel)

	target = effect.target
	local petPlayerID = target.playerID
	local petSlot = target.petSlot

	local player = GetTeamByIndex(petPlayerID)
	local pet = player.pets[petSlot]

	if not petSlot then
		return
	end

	local auraInstanceID = target.auraInstanceID
	local aura = pet.auras[auraInstanceID]
	if not aura then
		print(\ERROR: unknown aura instance ID \"" .. auraInstanceID)"							
"	0	0
567	PetBattle - Result - Status Change"""	"--------------------------------------------------------------------------------
-- STATUS CHANGE
function EffectStatusChange(effect)
	if (not effect) then
		return
	end

	target = effect.target
	local targetPlayer = GetTeamByIndex(target.playerID"	0	0					
"	0	0
57	Kun Lai Summit - Horde Hub Swap Scene - Init - Named Actors - JSB"""	"
-- Spawn all actors
nazgrimCreatureID = 60149
kirynCreatureID = 60592
bannerCreatureID = 60574
nazgrim01 = SpawnActor( nazgrimCreatureID, 2284.16, 980.726, 483.094, 266.8 ) -- Nazgrim
kiryn01 = SpawnActor( kirynCreatureID, 2287.65, 982.313, 483.283, 70 ) -- Kiryn
banner01 = SpawnActor( bannerCreatureID, 2284.02, 917.727, 481.979, 345 ) -- Banner

-- Initial fade
FadeOut( nazgrim01, 0 )
FadeOut( kiryn01, 0 )
FadeOut( banner01, 0 )"	0	0					
"	0	0
572	PetBattle - Selected - Pet Swap Selected Movement"""	"--------------------------------------------------------------------------------
-- MOVE (pet swap) SELECTED
function EventMovePetSwapSelected(petSlot)

	-- print(\Move Selected: Pet Swap Slot: \"" .. petSlot)"							
"	0	0
574	PetBattle - 1. Handle Event"""	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.abilityVisualID)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.newFrontPet)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected()
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\WARNING: processing round result outside of RoundStart/End\"")"							
"	0	0
580	PetBattle - Main"""	"
--------------------------------------------------------------------------------
-- battle constants
isObserved = false
observingPlayerIndex = 0
if battleScene then
	initialBattleState = battleScene:GetBattleState()
	observingPlayerIndex = battleScene:GetUIObservingPlayer()
	if (observingPlayerIndex > 0) then
		isObserved = true
	end
end

--------------------------------------------------------------------------------
-- build ability and abilityVisual map
petAbilities = { }
for index,ability in pairs(initialBattleState.abilityDescs) do
	petAbilities[ability.ID] = ability
end

petAbilityVisuals = { }
for index,abilityVisual in pairs(initialBattleState.abilityVisualDescs) do
	local visualID = abilityVisual.ID
	petAbilityVisuals[visualID] = abilityVisual

	-- add any custom script function
	LoadCustomVisualScript(abilityVisual)
end

--------------------------------------------------------------------------------
-- spawn teams
initialBattleState.players[PetBattlePlayerID.Weather].teamFacing = 0
initialBattleState.players[PetBattlePlayerID.Player1].teamFacing = 0
initialBattleState.players[PetBattlePlayerID.Player2].teamFacing = 180

teams = { }
teams[PetBattlePlayerID.Weather] = initialBattleState.players[PetBattlePlayerID.Weather]
teams[PetBattlePlayerID.Player1] = initialBattleState.players[PetBattlePlayerID.Player1]
teams[PetBattlePlayerID.Player2] = initialBattleState.players[PetBattlePlayerID.Player2]

if (PetBattleScene.GetActivePlayerDisplay) then
	if (teams[1]) then
		teams[1].playerDisplay = battleScene:GetActivePlayerDisplay(1)
	end
	if (teams[2]) then
		teams[2].playerDisplay = battleScene:GetActivePlayerDisplay(2)
	end
end

if (teams[PetBattlePlayerID.Player2].isNPC == true) and (#teams[PetBattlePlayerID.Player2].petDescs <= 1) then
	-- when battling a single NPC, don\'t show backline
	backlineAlpha = 0.0
end

InitTeam(PetBattlePlayerID.Weather, teams[PetBattlePlayerID.Weather])
InitTeam(PetBattlePlayerID.Player1, teams[PetBattlePlayerID.Player1])
InitTeam(PetBattlePlayerID.Player2, teams[PetBattlePlayerID.Player2])

-- wait for teams to load
if (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then
	BattleIntro()
else
	if isObserved then
		SetCamera(3)
		StartCameraBunny(0)
	end

	WaitAllPetsLoaded()
	FadeInAllPets(0)
end

-- Pet Battle loop
local inBattle = true
local winnerID
while (inBattle == true) do
	local event = nil

	-- poll for battle events
	local waitForEvents = function()
		return battleScene:HasPendingEffects()
	end
	scene:WaitCondition(waitForEvents)

	event = battleScene:GetPendingEffect()

	inBattle, winnerID = ProcessEvent(event)
end

VictoryCeremony(winnerID)

if isObserved then
	if (useFreelookCamera) then
		StopCameraBunny(0.75)
	else
		SetCamera(4);
		scene:WaitTimer(0.75)
	end
end

battleScene:SignalBattleComplete()
"	0	0					
"	0	0
585	Valley of the Four Winds - Stoneplow Finale - Leven - PRK"""	"WaitForTrigger(\TriggerLeven01\"")"							
"	0	0
586	Valley of the Four Winds - Stoneplow Finale - Farmers/Kids - PRK"""	"WaitForTrigger(\FarmersAssemble\"")"							
"	0	0
59	Kun Lai Summit - Horde Hub Swap Scene - Init - Generic Actors 02 - JSB"""	"
-- Spawn Dust Clouds
workDustModel = \spells\\xplosion_dust_impact_noflash.m2\"""							
"	0	0
592	Brazie\'s PetBattle - Init Pad"""	"--------------------------------------------------------------------------------
-- pad
padModel = \CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"""							
"	0	0
598	PetBattle - Pet Movement Stuff"""	"

function PetMoveToAttackPosition(pet, opponent, attackType)
	if ( not attackType or attackType == PetBattleRange.InPlace ) then 
		local radius = GetAttackRadius(attackType);
		WaitMoveToRadius(pet, radius);

	elseif (attackType == PetBattleRange.Melee or attackType == PetBattleRange.Ranged ) then 
		local attackRadius = GetAttackRadius(attackType);
		WaitMoveToRadius(pet, attackRadius);
	end

	LookAtOpposingTeam(pet)
end

function MoveToRadius(pet, radius, offset, instant)
	local radiusMove = pet.currentRadius - radius
	local offsetMove = (offset or 0.0) - pet.currentOffset
	local distToMove = math.sqrt(radiusMove*radiusMove + offsetMove*offsetMove)
	local moveTime = 0
	if (instant == true) then
		moveTime = 0
	elseif radiusMove < 0 then
		moveTime = distToMove / backwardSpeed
	else
		moveTime = distToMove / forwardSpeed
	end	

	pet.currentRadius = radius
	pet.currentOffset = (offset or 0.0)

	local pos = BuildVector( (pet.teamFacing or 0.0) , -pet.currentRadius, pet.currentOffset)
	pet.actor:MoveToAbs(pos, moveTime)
end

function GetAttackRadius(rangeType)
	local attackRadius = readyRadius
	if rangeType == PetBattleRange.Melee then
		attackRadius = meleeRadius
	elseif rangeType == PetBattleRange.Ranged then
		attackRadius = rangedRadius
	end
	return attackRadius
end

function WaitMoveToRadius(pet, radius, offset)
	MoveToRadius(pet, radius, offset)
	pet.actor:WaitMovementComplete()
end"	0	0					
"	0	0
604	Valley of the Four Winds - Stoneplow Finale - Li Li/Mudmug - PRK"""	"WaitForTrigger(\TriggerParade\"")"							
"	0	0
605	Valley of the Four Winds - Stoneplow Finale - Tauren - PRK"""	"WaitForTrigger(\TriggerParade\"")"							
"	0	0
606	Valley of the Four Winds - Stoneplow Finale - Hidden Master - PRK (copy)"""	"WaitForTrigger(\TriggerParade\"")"							
"	0	0
607	Valley of the Four Winds - Stoneplow Finale - Pang/Miss Fanny - PRK"""	"WaitForTrigger(\TriggerParade\"")"							
"	0	0
609	Valley of the Four Winds - Stoneplow Finale - Crane Monks - PRK"""	"WaitForTrigger(\TriggerParade\"")"							
"	0	0
610	Valley of the Four Winds - Stoneplow Finale - Kung Fu Five - PRK"""	"--Fade in
WaitForTrigger(\ChenEnters\"")"							
"	0	0
613	PetBattle - Debug Stuff"""	"debugOn = false;

function DebugPrint(...)
	if ( debugOn == true ) then
		print(...);
	end
end


STATE_LOOKUP = {
    STATE_Is_Dead = 1;
    STATE_maxHealthBonus = 2;
    STATE_speedBonus = 3;
    STATE_Stat_Kharma = 4;
    STATE_healthBonus = 17;
    STATE_Stat_Power = 18;
    STATE_Stat_Stamina = 19;
    STATE_Stat_Speed = 20;
    STATE_Mechanic_IsPoisoned = 21;
    STATE_Mechanic_IsStunned = 22;
    STATE_Mod_DamageDealtPercent = 23;
    STATE_Mod_DamageTakenPercent = 24;
    STATE_Mod_SpeedPercent = 25;
    STATE_Ramping_DamageID = 26;
    STATE_Ramping_DamageUses = 27;
    STATE_Condition_WasDamagedThisTurn = 28;
    STATE_untargettable = 29;
    STATE_Mechanic_IsUnderground = 30;
    STATE_Last_HitTaken = 31;
    STATE_Last_HitDealt = 32;
    STATE_Mechanic_IsFlying = 33;
    STATE_Mechanic_IsBurning = 34;
    STATE_turnLock = 35;
    STATE_swapLock = 36;
    STATE_Stat_CritChance = 40;
    STATE_Stat_Accuracy = 41;
    STATE_Passive_Critter = 42;
    STATE_Passive_Beast = 43;
    STATE_Passive_Humanoid = 44;
    STATE_Passive_Flying = 45;
    STATE_Passive_Dragon = 46;
    STATE_Passive_Elemental = 47;
    STATE_Passive_Mechanical = 48;
    STATE_Passive_Magic = 49;
    STATE_Passive_Undead = 50;
    STATE_Passive_Aquatic = 51;
    STATE_Mechanic_IsChilled = 52;
    STATE_Weather_BurntEarth = 53;
    STATE_Weather_ArcaneStorm = 54;
    STATE_Weather_Moonlight = 55;
    STATE_Weather_Darkness = 56;
    STATE_Weather_Sandstorm = 57;
    STATE_Weather_Blizzard = 58;
    STATE_Weather_Mud = 59;
    STATE_Weather_Rain = 60;
    STATE_Weather_Sunlight = 61;
    STATE_Weather_LightningStorm = 62;
    STATE_Weather_Windy = 63;
    STATE_Mechanic_IsWebbed = 64;
    STATE_Mod_HealingDealtPercent = 65;
    STATE_Mod_HealingTakenPercent = 66;
    STATE_Mechanic_IsInvisible = 67;
};"	0	0					
"	0	0
621	Brazie\'s PetBattle - Post Attack Resets"""	"backwardSpeedMulti = 0.7;

function ReturnOrResetCheck (pet, opponent)
	local newFrontVector = UnitVectorFromAtoB(opponent.actor:GetPosition(), pet.actor:GetPosition()  );
	local returnPoint = newFrontVector * 1.5*battleScale;

if ( not pet.playerID ) then
	print(\ERROR: Pet has no player ID\"");"							
"	0	0
622	Brazie\'s PetBattle - Pet Movement - Knockback / Dodge"""	"
function PerformDodge( opponent, pet) 
	local coin = math.random(0,1);
	if ( coin == 0 ) then 
		coin = -1;
	end

	local front = 0.01;
	local left = 0.75*coin;
	local up = 0; 

	DebugPrint(\dodge\"") "							
"	0	0
625	Brazie\'s PetBattle - Dispatcher - Display Damage"""	"function Dispatcher_SetHealth(ROID, newHealth, dontDraw)
	local pet = ROIDTOPET( ROID )

	SetHealth(pet, newHealth, dontDraw);
end

function SetHealth(pet, newHealth, dontDraw)
	local oldHealth = pet.currentHealth
	pet.currentHealth = newHealth

	local change = 0;

	if ( oldHealth ) then
		change = newHealth - oldHealth

		if ( not dontDraw ) then
			DisplayHealthChange(pet, change)
		end
	end
	
	return change, DeathAndRespawnCheck(pet)
end


function DisplayHealthChange(pet, change)
	-- damage numbers feedback for observed battles
	if (isObserved) then
		if (change < 0) and (Actor.AddDamageText) then
			pet.actor:AddDamageText(nil, -change, false, false)
		elseif (change > 0)  and (Actor.AddHealingText) then
			pet.actor:AddHealingText(nil, change, false, false)
		end
	end
end

"	0	0					
"	0	0
636	Brazie\'s PetBattle - Dispatcher - Result Stub - Shared"""	"
function preEffect_visual(targetPet, casterPet, result)
	local abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID = GetVisualData(result)

	PerformSpellVisual(casterPet, abilityVisualID, targetPet )
end

function successEffect_visual(targetPet, casterPet, result)
	local abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID = GetVisualData(result)

	local useID = spellVisualID
print(abilityVisualID, \,\"", spellVisualID, \"",\"", turnVisualID, \"",\"", turnVisualSpellID)"							
"	0	0
640	Brazie\'s PetBattle - Dispatcher - Default Turn Behaviour"""	"function Dispatcher_DefaultTurnBehaviour( ROID, turn )
	DefaultTurnBehaviour( ROID, \turn\"", turn);"							
"	0	0
648	Turn Package - Vanish - Ambush"""	"function Dispatcher_VanishAttackOnMultiHit( ROID, isTurn, turn )

	-- Only handle \effect\"" objects"							
"	0	0
649	Brazie\'s PetBattle - Dispatcher - Thread Bot 1"""	"local myROID;
local myList=nil;

while(not BOT_KILL_SWITCH ) do
	for k,v in pairs(UNIT_ACTION_QUEUE) do
		if ( v.isProcessing == false and #v.commands > 0 ) then 
			myROID = k;
			myList = v;
			break;
		end
	end

	if ( myROID ) then 
		UNIT_ACTION_QUEUE[myROID].isProcessing = true;
		
		while myList.commands[1] ~= nil do
			local task = myList.commands[1];
			local result = task.func(myROID, unpack(task.args));

			print(\Bot1 Result: \"",result)"							
"	0	0
65	PetBattle - Effect Aura Apply"""	"
--------------------------------------------------------------------------------
-- APPLY AURA

function EffectAuraApply(effect)
	
	local casterCastingPet
	local spellVisualID
	casterCastingPet, spellVisualID = EffectCastShared(effect, effect.auraAbilityTurnID)
	if (not spellVisualID) then
		return
	end

	-- signal the impact
	SignalEffectProcessed()

	-- final stage: actually apply the impact visuals and damage
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		targetPet.actor:PlaySpellImpactVisual(spellVisualID)

		-- apply an aura, tracked by instance ID
		ApplyAura(targetPet, targetData.auraInstanceID, spellVisualID)

		local newHealth = targetData.newHealth
		SetHealth(targetPet, newHealth, false)
	end

	-- wait until the casters animation has completed
	casterCastingPet.actor:WaitCastingComplete(true)

end

--------------------------------------------------------------------------------
function ApplyAura(pet, auraInstanceID, spellVisualID)

	local aura = pet.auras[auraInstanceID]
	if (not aura) then
		aura = { }
		pet.auras[auraInstanceID] = aura
	end

	-- clear existing aura visual for this instance, if there is one
	if (aura.spellVisualID and aura.spellVisualInstanceID) then
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
	end

	aura.spellVisualID = spellVisualID
	aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)

end

--------------------------------------------------------------------------------
function UpdateAuraVisuals(pet)

	for auraInstanceID, aura in pairs(pet.auras) do
		if (aura.spellVisualID and aura.spellVisualInstanceID) then
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)
		end
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)
	end

end
"	0	0					
"	0	0
655	Brazie\'s PetBattle - Perform Leap"""	"
-- Moves the unit to the correct location based on the ability
function PerformLeap(ROID, range, animation)
	local pet = ROIDTOPET(ROID);
	local opponent = GetActivePetByIndex(3 - pet.playerID)

	local opponentLocation = opponent.actor:GetPosition();
	local frontVector = UnitVectorFromAtoB(opponentLocation, pet.actor:GetPosition()  );
	local upVector = UnitVectorFromAtoB(opponentLocation, (opponentLocation + Vector:New(0,0,1) ) );
	local leftVector = UnitVectorCrossProduct(frontVector, upVector);

	pet.actor:ClearFacing(); 

	--casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)
	local finalDestination = nil;

	-- Melee
	if ( range == PetBattleRange.Melee ) then 
		local meleePoint = frontVector * 1*battleScale;
		local meleeAttackPoint = opponentLocation + meleePoint;
		finalDestination = meleeAttackPoint;
	-- Ranged
	elseif ( range == PetBattleRange.Ranged ) then 
		local rangedPoint = frontVector * 2*battleScale;
		local rangedAttackPoint = opponentLocation + rangedPoint;
		finalDestination = rangedAttackPoint;
	-- Stationary
	elseif (range == PetBattleRange.InPlace ) then 
		pet.actor:SetFacingToAbs(opponentLocation)
	-- Do nothing
	else
		Print(\ERROR: No movement range specified!\"");"							
"	0	0
660	Global Constants - Animation Table 1"""	"AnimTable1 =
{  
	None = -1;
	Stand = 0;
	Death = 1;
	Spell = 2;
	Stop = 3;
	Walk = 4;
	Run = 5;
	Dead = 6;
	Rise = 7;
	StandWound = 8;
	CombatWound = 9;
	CombatCritical = 10;
	ShuffleLeft = 11;
	ShuffleRight = 12;
	Walkbackwards = 13;
	Stun = 14;
	HandsClosed = 15;
	AttackUnarmed = 16;
	Attack1H = 17;
	Attack2H = 18;
	Attack2HL = 19;
	ParryUnarmed = 20;
	Parry1H = 21;
	Parry2H = 22;
	Parry2HL = 23;
	ShieldBlock = 24;
	ReadyUnarmed = 25;
	Ready1H = 26;
	Ready2H = 27;
	Ready2HL = 28;
	ReadyBow = 29;
	Dodge = 30;
	SpellPrecast = 31;
	SpellCast = 32;
	SpellCastArea = 33;
	NPCWelcome = 34;
	NPCGoodbye = 35;
	Block = 36;
	JumpStart = 37;
	Jump = 38;
	JumpEnd = 39;
	Fall = 40;
	SwimIdle = 41;
	Swim = 42;
	SwimLeft = 43;
	SwimRight = 44;
	SwimBackwards = 45;
	AttackBow = 46;
	FireBow = 47;
	ReadyRifle = 48;
	AttackRifle = 49;
	Loot = 50;
	ReadySpellDirected = 51;
	ReadySpellOmni = 52;
	SpellCastDirected = 53;
	SpellCastOmni = 54;
	BattleRoar = 55;
	ReadyAbility = 56;
	Special1H = 57;
	Special2H = 58;
	ShieldBash = 59;
	EmoteTalk = 60;
	EmoteEat = 61;
	EmoteWork = 62;
	EmoteUseStanding = 63;
	EmoteTalkExclamation = 64;
	EmoteTalkQuestion = 65;
	EmoteBow = 66;
	EmoteWave = 67;
	EmoteCheer = 68;
	EmoteDance = 69;
	EmoteLaugh = 70;
	EmoteSleep = 71;
	EmoteSitGround = 72;
	EmoteRude = 73;
	EmoteRoar = 74;
	EmoteKneel = 75;
	EmoteKiss = 76;
	EmoteCry = 77;
	EmoteChicken = 78;
	EmoteBeg = 79;
	EmoteApplaud = 80;
	EmoteShout = 81;
	EmoteFlex = 82;
	EmoteShy = 83;
	EmotePoint = 84;
	Attack1HPierce = 85;
	Attack2HLoosePierce = 86;
	AttackOff = 87;
	AttackOffPierce = 88;
	Sheath = 89;
	HipSheath = 90;
	Mount = 91;
	RunRight = 92;
	RunLeft = 93;
	MountSpecial = 94;
	Kick = 95;
	SitGroundDown = 96;
	SitGround = 97;
	SitGroundUp = 98;
	SleepDown = 99;
	Sleep = 100;
	SleepUp = 101;
	SitChairLow = 102;
	SitChairMed = 103;
	SitChairHigh = 104;
	LoadBow = 105;
	LoadRifle = 106;
	AttackThrown = 107;
	ReadyThrown = 108;
	HoldBow = 109;
	HoldRifle = 110;
	HoldThrown = 111;
	LoadThrown = 112;
	EmoteSalute = 113;
	KneelStart = 114;
	KneelLoop = 115;
	KneelEnd = 116;
	AttackUnarmedOff = 117;
	SpecialUnarmed = 118;
	StealthWalk = 119;
	StealthStand = 120;
	Knockdown = 121;
	EatingLoop = 122;
	UseStandingLoop = 123;
	ChannelCastDirected = 124;
	ChannelCastOmni = 125;
	Whirlwind = 126;
	Birth = 127;
	UseStandingStart = 128;
	UseStandingEnd = 129;
	CreatureSpecial = 130;
	Drown = 131;
	Drowned = 132;
	FishingCast = 133;
	FishingLoop = 134;
	Fly = 135;
	EmoteWorkNoSheathe = 136;
	EmoteStunNoSheathe = 137;
	EmoteUseStandingNoSheathe = 138;
	SpellSleepDown = 139;
	SpellKneelStart = 140;
	SpellKneelLoop = 141;
	SpellKneelEnd = 142;
	Sprint = 143;
	InFlight = 144;
	Spawn = 145;
	Close = 146;
	Closed = 147;
	Open = 148;
	Opened = 149;
	Destroy = 150;
	Destroyed = 151;
	Rebuild = 152;
	Custom0 = 153;
	Custom1 = 154;
	Custom2 = 155;
	Custom3 = 156;
	Despawn = 157;
	Hold = 158;
	Decay = 159;
	BowPull = 160;
	BowRelease = 161;
	ShipStart = 162;
	ShipMoving = 163;
	ShipStop = 164;
	GroupArrow = 165;
	Arrow = 166;
	CorpseArrow = 167;
	GuideArrow = 168;
	Sway = 169;
	DruidCatPounce = 170;
	DruidCatRip = 171;
	DruidCatRake = 172;
	DruidCatRavage = 173;
	DruidCatClaw = 174;
	DruidCatCower = 175;
	DruidBearSwipe = 176;
	DruidBearBite = 177;
	DruidBearMaul = 178;
	DruidBearBash = 179;
	DragonTail = 180;
	DragonStomp = 181;
	DragonSpit = 182;
	DragonSpitHover = 183;
	DragonSpitFly = 184;
	EmoteYes = 185;
	EmoteNo = 186;
	JumpLandRun = 187;
	LootHold = 188;
	LootUp = 189;
	StandHigh = 190;
	Impact = 191;
	LiftOff = 192;
	Hover = 193;
	SuccubusEntice = 194;
	EmoteTrain = 195;
	EmoteDead = 196;
	EmoteDanceOnce = 197;
	Deflect = 198;
	EmoteEatNoSheathe = 199;
	Land = 200;}
"	0	0					
"	0	0
67	Townlong Steppes - Ring worm Intro - Init"""	"
local RingWormBossID = 62324
RingWormBoss = SpawnActor( RingWormBossID, 1209.34, 2818.61, 264.553, 0, 1.0, false )"	0	0					
"	0	0
684	Turn Package - Stampede With Clones"""	"function Dispatcher_Stampede( clonesPerRow, ROID, isTurn, turn )
	--[[
	-- Global checker:
	--
	local env = {};
	setmetatable(env, { __index = getfenv(1), __newindex = function(tab, k, v) error(\Attempt to set global \""..k); end});"							
"	0	0
690	Brazie\'s PetBattle - Effect - GetVisualData"""	"function GetVisualData(result)
	local abilityVisualID = result.abilityVisualID
	local turnVisualID = result.turnVisualID

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return abilityVisualID, nil, turnVisualID
	end

	local spellVisualID = abilityVisual.spellVisualID

	local turnVisual = petAbilityVisuals[turnVisualID]
	if not turnVisual then
		return abilityVisualID, nil, turnVisualID
	end
	local turnVisualSpellID = turnVisual.spellVisualID;

	return abilityVisualID, spellVisualID, turnVisualID, turnVisualSpellID
end"	0	0					
"	0	0
692	Turn Package - Only Turn Animate The First N Effects"""	"function Dispatcher_OnlyTurnAnimateTheEffects1toN( n, ROID, isTurn, turn )
	-- Only handle \effect\"" objects"							
"	0	0
8	Darren\'s Test Scene Script 2"""	"print(\DazTest2\"")"							
"	0	0
81	Kun Lai Summit - Alliance Hub Swap Scene - Mishka 01 - JSB"""	"
-- wait before running in
Wait(22)

FadeIn( mishka01, 0 )

-- run into scene
RunToLocation( mishka01, 5, 2117.27, 1453.24, 487.886, 41.1248 )
RunToLocation( mishka01, 3, 2124.83, 1468.99, 487.886, 14.7998 )

-- taylor trigger
WaitForTrigger( \flagPlant\"" )"							
"	0	0
86	PetBattle - Effect Shared"""	"
--------------------------------------------------------------------------------
-- Helper Functions for processing effects

local currentEffectInstanceID = nil

function ProcessEffect(event)
	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType
	local effectType = event.effectType
	if (event.type) then
		-- backwardsCompatibility for Build <= 15418
		if (event.type == PetBattleEffect.Invalid) then
			return false
		end

		eventType = PetBattleEvent.RoundEffect
		effectType = event.type
	end

	-- save the instance ID of the effect currently being processed
	currentEffectInstanceID = event.instanceID

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.RoundEffect) then

		-- battle round effects
		if (effectType == PetBattleEffect.Ability) then
			EffectAbility(event)
		elseif (effectType == PetBattleEffect.AuraApply) then
			EffectAuraApply(event)
		elseif (effectType == PetBattleEffect.AuraCancel) then
			EffectAuraRemove(event)
		elseif (effectType == PetBattleEffect.PetSwap) then
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		elseif (effectType == PetBattleEffect.StatusChange) then
			-- HACK - for backwards compatibility
			EffectSwap(event.casterPlayerID, event.newFrontPet)
		end

	end

	if currentEffectInstanceID then
		-- Noone manually signaled the effect applied, do it now
		battleScene:SignalEffectApplied(currentEffectInstanceID)
	end

	if (battleScene and battleScene:HasPendingEffects() == false) then
		ResetActivePets()
	end

	return true
end

--------------------------------------------------------------------------------
function SignalEffectProcessed()
	if currentEffectInstanceID and battleScene then
		battleScene:SignalEffectApplied(currentEffectInstanceID)
		currentEffectInstanceID = nil
	end
end
"	0	0					
"	0	0
9	Global Functions - Actor"""	"--
-- Actor Functions
--
function Actor:WaitCondition(...)
	local scene = self:GetScene()
	if scene then
		scene:WaitCondition(...)
	end
end

function Actor:WaitCastingComplete(checkAnims, spellID)
	local waitCondition = function()
		return (("							
"	0	277
277	[1] Darren\'s Test 4000+"""	"--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------

print(\"							
"	0	555
334	PetBattle(fallback) - Effect Cast"""	"
--------------------------------------------------------------------------------
function EffectCastShared(effect, abilityVisualID)
	local casterPlayerID = effect.casterPlayerID
	local casterPlayer = GetTeamByIndex(casterPlayerID)
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]

	--
	-- Get the pets in their rightful places
	--
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]
	local opponentFrontPet = GetActivePetByIndex(3 - casterPlayerID)

	-- make sure the opponent pet is at the correct radius
	if not opponentFrontPet.deathAnimKit then
		WaitMoveToRadius(opponentFrontPet, readyRadius)
	end

	local abilityVisual = petAbilityVisuals[abilityVisualID]
	if not abilityVisual then
		return casterCastingPet
	end

	local attackRadius = GetAttackRadius(abilityVisual.range)
	
	-- move front pet to the correct radius, if it was the caster
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then
		WaitMoveToRadius(casterFrontPet, attackRadius)
	end

	--
	-- Actually cast
	--	
	local spellVisualID = abilityVisual.spellVisualID

	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)
	scene:WaitTimer(abilityVisual.castTime)
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)

	-- loop through all the targets
	for targetIndex, targetData in pairs(effect.targets) do
		local targetPlayer = GetTeamByIndex(targetData.playerID)
		local targetPet = targetPlayer.pets[targetData.petSlot]

		if (casterCastingPet.actor ~= targetPet.actor) then
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(
				spellVisualID,
				abilityVisual.impactTime,
				true,
				{targetPet.actor})
		else
			-- self targeted
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)
		end
	end

	-- wait for impact
	local waitMissiles = false
	if Actor.HasPendingMissiles then
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)
	end

	if (waitMissiles == true) then
		casterCastingPet.actor:WaitMissilesImpacted(0)
	else
		scene:WaitTimer(abilityVisual.impactTime)
	end

	return casterCastingPet, spellVisualID
end
"	0	0					
"	0	575
575	[1] PetBattle - 1. Handle Event"""	"
end

"	574	0					
"	276	0
281	Lorewalker Story - S1: Grummle - Init - Pre-scene Actors - ZTO"""	"-- Spawn huge mogu head!!
moguFaceID = 62170
moguFace = SpawnActor( moguFaceID, 1460.83, 362.878, 550.222, 131.721, .5 ) -- Mogu Main Character
moguFace: PlayLoopingAnimKit( 2340 )
FadeOut( moguFace, 0 )"	0	0					
"	276	278
278	[2] Darren\'s Test 4000+"""	"--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80----------------------------------------------------------------------------
--80-----"							
"	535	0
555	[1] PetBattle(fallback) - Event Processing"""	"
	end

end

"	333	0					
"	600	0
644	Brazie\'s PetBattle - Dispatcher - Post Attack Cleanup"""	"
-- Reset after an attack if needed
function Dispatcher_PerformPostAttackCleanup( ROID )
	local pet = ROIDTOPET(ROID);

	local opponent = GetActivePetByIndex(3 - pet.playerID)
		
	pet.actor:WaitCastingComplete(true, 122)
	scene:WaitTimer(0.25)

	ReturnOrResetCheck( pet, opponent );
end

"	0	0					
--[[								
--[[								
--[[								
--[[								
--[[								
--[[								
--[[								
--[[								
--[[ FUTURE NOTE: Initialize all pets facing 0,0,0 ]]--								
]]								
]]								
]]								
]]								
]]								
]]								
]]								
]]								
]]								
]]--								
"]]"""	0	0						
{								
{								
{								
{								
{								
{								
{								
{								
{								
{								
}								
}								
}								
}								
}								
}								
}								
}								
}								
}								
"};"								
"};"								
"};"								
"};"								
"};"								
"};"								
"};"								
"};"								
"}; "								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
--80----------------------------------------------------------------------------								
actor = scene:SpawnActor(actorCreateData)								
actor = scene:SpawnActor(actorCreateData)								
actor:Despawn()								
actor:PlayLoopingFullBodyAnim(Animations.Hover)								
actor:SetHoverHeight(2)								
actor:SetSnapToGround(false)								
actor:SetSnapToGround(true)								
actor:WaitMoveToRel(Vector:New(0,0,-3), 3)								
actor:WaitMoveToRel(Vector:New(0,0,5), 1)								
actor:WaitMoveToRel(Vector:New(5,0,0), 2)								
actor:WaitMoveToRel(Vector:New(5,0,0), 2)								
actor2 = scene:SpawnActor(actorCreateData)								
actorCreateData = ActorCreateData:New(53828, Transform:New(Vector:New( 5, 5, 3), -90), 0.5)								
actorCreateData = ActorCreateData:New(55242, Transform:New(points[pointIndex], 100), 1.0)								
actorCreateData.transform = Transform:New(Vector:New( -10, -10, 3))								
allianceCaptain = SpawnActor( allianceCaptainCreatureID, 3438.27, -953.387, 18.8127, 63, 1.0, false )								
"allianceCaptain:Despawn()"""	0	0						
allianceCaptain:FollowPath( 3231, 2 )								
allianceCaptain:PlayLoopingFullBodyAnim(Animations.FlyFall)								
allianceCaptain:PlayOneShotFullBodyAnim(Animations.EmoteTalkExclamation)								
allianceCrewman01 = SpawnActor( allianceCrewmanCreatureID, 3448.72, -936.778, 12.8252, 133.159, 1.0, false )								
allianceCrewman01:Despawn()								
allianceCrewman01:FollowPath( 3233, 2 )								
allianceCrewman01:PlayLoopingFullBodyAnim(Animations.FlyFall)								
allianceCrewman01:PlayOneShotFullBodyAnim(Animations.EmoteKneel)								
allianceCrewman01:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )								
allianceCrewman02 = SpawnActor( allianceCrewmanCreatureID, 3457.39, -935.658, 12.1602, 143.644, 1.0, false )								
allianceCrewman02:Despawn()								
allianceCrewman02:FollowPath( 3234, 2 )								
allianceCrewman02:PlayLoopingFullBodyAnim(Animations.FlyFall)								
allianceCrewman02:PlayOneShotFullBodyAnim(Animations.EmoteKneel)								
allianceCrewman02:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )								
allianceCrewman03 = SpawnActor( allianceCrewmanCreatureID, 3453.5, -941.767, 12.6392, 88.2943, 1.0, false )								
"allianceCrewman03:Despawn()"""	0	0						
allianceCrewman03:FollowPath( 3232, 2 )								
allianceCrewman03:PlayLoopingFullBodyAnim(Animations.FlyFall)								
allianceCrewman03:PlayOneShotFullBodyAnim(Animations.EmoteKneel)								
allianceCrewman03:SetFacingToAbs ( Vector:New (3743.72, -672.189, 14.29) )								
allianceCrewman04 = SpawnActor( allianceCrewmanCreatureID, 3464.04, -922.214, 6.76588, 150.169, 1.0, false )								
"allianceCrewman04:Despawn()"""	0	0						
allianceCrewman04:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)								
allianceCrewman04:PlayOneShotFullBodyAnim(Animations.Knockdown)								
allianceCrewman05 = SpawnActor( allianceCrewmanCreatureID, 3470.05, -911.329, 17.9969, 128.254, 1.0, false )								
"allianceCrewman05:Despawn()"""	0	0						
allianceCrewman05:PlayOneShotFullBodyAnim(Animations.EmoteShout)								
allianceCrewman05:PlayOneShotFullBodyAnim(Animations.Knockdown)								
allianceCrewman05:SetFacingToAbs ( Vector:New (3457.83, -923.965, 0) )								
allianceShip = SpawnModelActor( allianceShipModel, 3457.83, -923.965, 0, 257.2773, 1.0, false )								
allPlayers = { }								
arenaCreateData.interactible = false								
arenaCreateData.interactible = false								
arenaCreateData.model = arenaRingModel								
arenaCreateData.model = arenaRingModel								
arenaCreateData.scale = arenaRingScale								
arenaCreateData.scale = arenaRingScale								
arenaFadeTime = 5.0								
arenaFadeTime = 5.0								
arenaRing = scene:SpawnActor(arenaCreateData)								
arenaRing = scene:SpawnActor(arenaCreateData)								
arenaRing:Fade(0, 0)								
arenaRing:Fade(0, 0)								
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)								
arenaRing:Fade(arenaRingAlpha, arenaFadeTime)								
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)								
arenaRing:PlayLoopingFullBodyAnim(Animations.Hold)								
arenaRingAlpha = 0.5								
arenaRingAlpha = 0.5								
"arenaRingModel = \""SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"""								
"arenaRingModel = \""SPELLS\\Stranglethorn_DiamondMines_Circle_Effect_Solid_White.M2\"""								
arenaRingScale = 1.0								
arenaRingScale = 1.0								
ashyo = SpawnFadedActorAtPoint( 63390, 3382, false )								
ashyo:FollowPathAtSpeed(3549, 6)								
ashyo:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)								
ashyo:WaitMovementComplete()								
--Back on Loon, camera on a spline								
backlineAlpha = 1.0								
BACKROW_PET_OFFSETS = {								
battleCameraIDs =								
battleCameraIDs =								
battleCameraIDs =								
battleCameraIDs =								
battleCameraIDs =								
battleScale    = 1.0								
braveA = SpawnFadedActorAtPoint( 63398, 3399, false )								
braveA:FollowPathAtSpeed(3525, paradeSpeed)								
braveA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
braveA:WaitMovementComplete()								
braveB = SpawnFadedActorAtPoint( 63398, 3400, false )								
braveB:FollowPathAtSpeed(3526, paradeSpeed)								
braveB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
braveB:WaitMovementComplete()								
braveC = SpawnFadedActorAtPoint( 63398, 3401, false )								
braveC:FollowPathAtSpeed(3527, paradeSpeed)								
braveC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
braveC:WaitMovementComplete()								
braveD = SpawnFadedActorAtPoint( 63398, 3407, false )								
braveD:FollowPathAtSpeed(3528, paradeSpeed)								
braveD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
braveD:WaitMovementComplete()								
cameraBunny = scene:SpawnActor(cameraBunnyCreate)								
cameraBunnyCreate.interactible = false								
cameraBunnyCreate.model = stalkerModel								
"cameraBunnyCreate.name = \""cameraBunny\"""								
cameraDummyCreateData.floatingTooltip = false								
cameraDummyCreateData.groundSnap = false								
cameraDummyCreateData.interactible = false								
cameraDummyCreateData.model = cameraDummyModel								
cameraDummyCreateData.transform.position = cameraDummyDefaultPos								
cannon01 = SpawnModelActor( cannonModel, 3443.82, -935.37, 12.12, 144.899, 1, false ) -- ( modelFileName, x, y, z, facing, scale, snapToGround )								
"cannon01:Despawn()"""	0	0						
cannon02 = SpawnModelActor( cannonModel, 3446.112, -932.104, 11.9, 285.375, 1, false )								
"cannon02:Despawn()"""	0	0						
cannon03 = SpawnModelActor( cannonModel, 3448.505, -928.838, 11.75, 312.15, 1, false )								
"cannon03:Despawn()"""	0	0						
cannon04 = SpawnModelActor( cannonModel, 3451.00, -925.57, 11.652, 143.099, 1, false )								
"cannon04:Despawn()"""	0	0						
CastSpellAtActor( cannon01, shipTarget01,120705 )								
CastSpellAtActor( cannon01, shipTarget01,122262 )								
CastSpellAtActor( cannon02, shipTarget02,120705 )								
CastSpellAtActor( cannon02, shipTarget02,122262 )								
CastSpellAtActor( cannon03, shipTarget03,120705 )								
CastSpellAtActor( cannon03, shipTarget03,122262 )								
CastSpellAtActor( cannon04, shipTarget04,120705 )								
CastSpellAtActor( cannon04, shipTarget04,122262 )								
CastSpellAtActor( egg1, egg1, bloodyExplosionSpellID )								
CastSpellAtActor( egg2, egg2, bloodyExplosionSpellID )								
CastSpellAtActor( littlesaurok, littlesaurok, TransformEffectSpellID )								
CastSpellAtActor( moguMain, troggMain, grummleTransformSpellID )								
CastSpellAtActor( saurok_hack4, saurok_hack4, fieryExplosionSpellID ) --Explode								
CastSpellAtActor( saurok_hack5, saurok_hack5, fieryExplosionSpellID ) --Explode								
CastSpellAtActor( tian, egg1, TransformSpellID )								
CastSpellAtActor( tian, saurok_hack4, TransformSpellID )								
CastSpellAtActor( tian, saurok_hack5, TransformSpellID )								
CastSpellAtActor( troggMain, troggMain, grummleTransformEffectSpellID )								
CastSpellAtActor( zeppelinCannon01, zeppelinTarget02,120673 )								
CastSpellAtActor( zeppelinCannon02, zeppelinTarget01,120673 )								
CastSpellAtActor( zeppelinCannon03, zeppelinTarget03,120673 )								
CastSpellAtActor( zeppelinCannon04, zeppelinTarget04,120682 )								
CastSpellAtActor(chen, mantidLeven01, kickSpell)								
chen = SpawnFadedActorAtPoint( 63381, 3373, false )								
chen:FollowPath(3460, 5)								
"chen:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)"""	0	0						
cho:Despawn()								
cho:PlayLoopingFullBodyAnim(Animations.EmoteReadLoop)								
cho:PlayLoopingFullBodyAnim(Animations.EmoteUseStanding)								
cho:PlayLoopingFullBodyAnim(Animations.SitGround)								
cho:PlayOneShotFullBodyAnim(Animations.EmoteNo)								
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)								
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)								
cho:PlayOneShotFullBodyAnim(Animations.EmoteTalk)								
cho:PlayOneShotFullBodyAnim(Animations.SitGroundDown)								
cho:SetFacing(128)								
cho:SetFacing(66)								
cho:StopLoopingFullBodyAnim()								
cho:StopLoopingFullBodyAnim()								
clone = SpawnActor( cloneCreatureID, 1843.04, -4417.14, 135.232, 224.772, 1.0, false )								
clone = SpawnActor( cloneCreatureID, 3447.19, -285, 266.9, 215.151, 1.0, false )								
clone:FollowPath( 3246, 3 )								
clone:PlayLoopingFullBodyAnim(Animations.FlyFall)								
clone:PlayOneShotFullBodyAnim(Animations.EmoteCheer)								
clone:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
count = 1								
crashBunny = SpawnActor( crashbunnyCreatureID, 3172.29, -422.428, 239.355, 203.225, 1, false )								
current = 0								
DEBUG_TABLE(effect)								
dezco = SpawnFadedActorAtPoint( 63394, 3385, false )								
dezco:FollowPathAtSpeed(3529, paradeSpeed)								
dezco:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
dezco:WaitMovementComplete()								
egg1: Despawn()								
egg2: Despawn()								
"egg3: Despawn()"""	0	0						
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end								
end 								
end 								
end 								
end 								
end 								
end 								
end 								
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
"end"""	0	0						
FadeIn ( trollPriest01, 0 )								
FadeIn( grummleCheer1, 1)								
FadeIn( grummleCheer2, 1)								
FadeIn( grummleCheer3, 1)								
FadeIn( grummleCheer4, 1)								
FadeIn( grummleIncenseSniffer, 1 )								
FadeIn( grummleMain, 0 )								
FadeIn( grummleMainBag, 1 )								
FadeIn( grummlePacker1, 1 )								
FadeIn( grummlePacker2, 1 )								
FadeIn( grummleVendor1, 1)								
FadeIn( grummleVendor2, 1)								
FadeIn( grummleVendor3, 2)								
FadeIn( grummleVendor4, 2)								
FadeIn( grummleVendor5, 2)								
FadeIn( incense1, 1 )								
FadeIn( incense2, 1 )								
FadeIn( incense3, 1 )								
FadeIn( incense4, 1 )								
FadeIn( lamppost1, 1)								
FadeIn( light_cc, 2 )								
FadeIn( light_cl, 2 )								
FadeIn( light_cr, 1)								
FadeIn( mist, 0 )								
FadeIn( mist, 3 )								
FadeIn( mist, 3 )								
FadeIn( mogu, 7 )								
FadeIn( moguFace, 2 )								
FadeIn( moguFace, 2 )								
FadeIn( moguGrunt01, 1 )								
FadeIn( moguGrunt02, 1 )								
FadeIn( moguMain, 2 )								
FadeIn( moguSlaver02, 1)								
FadeIn( pandarenSlave02, 1)								
FadeIn( pandarenSlave03, 1)								
FadeIn( richPandaren1, 1)								
FadeIn( shadopan01, 1)								
--FadeIn( stinkyPandaren1, 1)								
FadeIn( trogg01, 1 )								
FadeIn( trogg02, 1 )								
FadeIn( trogg03, 1 )								
FadeIn( troggMain, 1 )								
FadeIn( whiteyak, 1)								
FadeIn(ashyo, 0)								
FadeIn(braveA, 0)								
FadeIn(braveB, 0)								
FadeIn(braveC, 0)								
FadeIn(braveD, 0)								
FadeIn(chen, 0)								
FadeIn(dezco, 0)								
FadeIn(egg1, 1)								
FadeIn(egg1, 1)								
FadeIn(egg2, 1)								
FadeIn(egg2, 1)								
FadeIn(egg3, 1)								
FadeIn(egg3, 1)								
FadeIn(hiddenmaster, 0)								
FadeIn(kang, 0)								
FadeIn(kenken, 0)								
FadeIn(koro, 0)								
FadeIn(light_cc, 1)								
FadeIn(light_cc, 1)								
FadeIn(light_cc, 2)								
FadeIn(light_cl, 1)								
FadeIn(light_cl, 1)								
FadeIn(light_cl, 2)								
FadeIn(light_cl, 2)								
FadeIn(light_cr, 1)								
FadeIn(light_cr, 1)								
FadeIn(light_cr, 2)								
FadeIn(light_uc, 2)								
FadeIn(light_ul, 2)								
FadeIn(light_ur, 2)								
FadeIn(lili, 0)								
FadeIn(lin, 0)								
FadeIn(littlesaurok , 1)								
FadeIn(lizard1, 1)								
FadeIn(lizard2, 1)								
FadeIn(lizard3, 1)								
FadeIn(lyalia, 0)								
FadeIn(mantidFarmers01, 0)								
FadeIn(mantidFarmers02, 0)								
FadeIn(mantidFarmers03, 0)								
FadeIn(mantidLeven01, 0)								
FadeIn(mantidLeven02, 0)								
FadeIn(mantidLeven03, 0)								
FadeIn(mantidLeven04, 0)								
FadeIn(missfanny, 0)								
FadeIn(moguMace1, 1)								
FadeIn(moguMace1, 1)								
FadeIn(moguPoleArm1, 1)								
FadeIn(moguPoleArm1, 1)								
FadeIn(moguPoleArm1, 1)								
FadeIn(monkA, 0)								
FadeIn(monkB, 0)								
FadeIn(monkC, 0)								
FadeIn(monkD, 0)								
FadeIn(mudmug, 0)								
FadeIn(pang, 0)								
FadeIn(priestA, 0)								
FadeIn(priestB, 0)								
FadeIn(priestC, 0)								
FadeIn(priestD, 0)								
FadeIn(saurok_hack , 1)								
FadeIn(saurok_hack, 1)								
FadeIn(saurok_hack2, 1)								
FadeIn(saurok_hack3, 1)								
FadeIn(saurok_hack4, 1)								
FadeIn(saurok_hack5, 1)								
FadeIn(saurok_hack6, 1)								
FadeIn(saurok_heal , 1)								
FadeIn(saurok_heal, 1)								
FadeIn(saurok_heal2, 1)								
FadeIn(saurok_heal3, 1)								
FadeIn(saurok_tank , 1)								
FadeIn(saurok_tank2, 1)								
FadeIn(saurok_tank3, 1)								
FadeIn(sentinelA, 0)								
FadeIn(sentinelB, 0)								
FadeIn(sentinelC, 0)								
FadeIn(sentinelD, 0)								
FadeIn(terrorcotta1, 1)								
FadeIn(terrorcotta2, 1)								
FadeIn(tian, 1)								
FadeIn(tian, 1)								
FadeIn(wardenA, 0)								
FadeIn(wardenB, 0)								
FadeIn(wardenC, 0)								
FadeIn(wardenD, 0)								
FadeIn(wardenE, 0)								
FadeIn(wardenF, 0)								
FadeIn(xiao, 0)								
FadeIn(yaungol1, 1)								
FadeIn(yaungol2, 1)								
FadeIn(yimo, 0)								
FadeOut( grummleCheer1, 1)								
FadeOut( grummleCheer2, 1)								
FadeOut( grummleCheer3, 1)								
FadeOut( grummleCheer4, 1)								
FadeOut( grummleIncenseSniffer, 1)								
FadeOut( grummlePacker1, 1)								
FadeOut( grummlePacker2, 1)								
FadeOut( grummleVendor1, 1)								
FadeOut( grummleVendor2, 1)								
FadeOut( grummleVendor3, 1)								
FadeOut( grummleVendor4, 1)								
FadeOut( grummleVendor5, 1)								
FadeOut( incense1, 1)								
FadeOut( incense2, 1)								
FadeOut( incense3, 1)								
FadeOut( incense4, 1)								
FadeOut( lamppost1, 1)								
FadeOut( light_cr, 1)								
FadeOut( mist, 0 )								
FadeOut( mist, 0 )								
"FadeOut( mist, 3)"""	0	0						
FadeOut( mist, 6 )								
FadeOut( mogu, 0 )								
"FadeOut( mogu, 3)"""	0	0						
FadeOut( moguFace, 2 )								
FadeOut( moguFace, 2 )								
--FadeOut( moguFace, 2)								
--FadeOut( moguFace, 2)								
FadeOut( moguGrunt01, 1)								
FadeOut( moguGrunt02, 1)								
FadeOut( moguMain, 1)								
--FadeOut( moguMain, 1)								
FadeOut( moguPoleArm1, 1)								
FadeOut( moguSlaver02, 1)								
FadeOut( pandarenSlave02, 1)								
FadeOut( pandarenSlave03, 1)								
FadeOut( richPandaren1, 1)								
FadeOut( shadopan01, 1)								
--FadeOut( stinkyPandaren1, 1)								
FadeOut( troggMain, 1 )								
FadeOut( whiteyak, 1)								
FadeOut( workDust01, 0 )								
FadeOut( workDust01, 0 )								
FadeOut( workDust02, 0 )								
FadeOut( workDust02, 0 )								
FadeOut( workDust03, 0 )								
FadeOut( workDust03, 0 )								
FadeOut( workDust04, 0 )								
FadeOut( workDust04, 0 )								
FadeOut( workDust05, 0 )								
FadeOut( workDust05, 0 )								
"FadeOut( workDust06, 0 )"""	0	0						
"FadeOut( workDust06, 0 )"""	0	0						
FadeOut( zeppelin, 0 )								
FadeOut(egg1, 1)								
FadeOut(egg1, 1)								
FadeOut(egg2, 1)								
FadeOut(egg2, 1)								
FadeOut(egg3, 1)								
FadeOut(grummleMain, 1)								
FadeOut(grummleMainBag, 1)								
FadeOut(light_cc, 1)								
FadeOut(light_cc, 1)								
FadeOut(light_cc, 1)								
FadeOut(light_cc, 1)								
FadeOut(light_cl, 1)								
FadeOut(light_cl, 1)								
FadeOut(light_cl, 1)								
FadeOut(light_cl, 1)								
FadeOut(light_cl, 2)								
FadeOut(light_cl, 2)								
FadeOut(light_cl, 2)								
FadeOut(light_cr, 1)								
FadeOut(light_cr, 1)								
FadeOut(light_cr, 1)								
FadeOut(light_cr, 1)								
FadeOut(light_cr, 2)								
FadeOut(light_uc, 1)								
FadeOut(light_uc, 1)								
FadeOut(light_uc, 2)								
FadeOut(light_ul, 1)								
FadeOut(light_ul, 1)								
FadeOut(light_ul, 2)								
FadeOut(light_ur, 1)								
FadeOut(light_ur, 1)								
FadeOut(light_ur, 2)								
FadeOut(littlesaurok, 1)								
FadeOut(lizard1, 1)								
FadeOut(lizard2, 1)								
FadeOut(lizard3, 1)								
FadeOut(moguMace1, 1)								
FadeOut(moguMace1, 1)								
FadeOut(moguPoleArm1, 1)								
FadeOut(moguPoleArm1, 1)								
FadeOut(saurok_hack, 1)								
FadeOut(saurok_hack, 1)								
FadeOut(saurok_hack2, 1)								
FadeOut(saurok_hack3, 1)								
FadeOut(saurok_hack4, 0)								
FadeOut(saurok_hack4, 1)								
FadeOut(saurok_hack5, 1)								
FadeOut(saurok_hack6, 1)								
FadeOut(saurok_heal, 1)								
FadeOut(saurok_heal2, 1)								
FadeOut(saurok_heal3, 1)								
FadeOut(saurok_tank, 1)								
FadeOut(saurok_tank2, 1)								
FadeOut(saurok_tank3, 1)								
FadeOut(terrorcotta1, 1)								
FadeOut(terrorcotta1, 1)								
FadeOut(terrorcotta2, 1)								
FadeOut(tian, 1)								
FadeOut(tian, 1)								
FadeOut(yaungol1, 1)								
FadeOut(yaungol2, 1)								
farmerA = SpawnActorAtPoint(63409, 3391, false)								
farmerA:FollowPath(3432, 6)								
farmerA:FollowPath(3448, 8)								
farmerA:PlayOneShotSplitBodyAnim(Animations.EmoteYes)								
farmerB = SpawnActorAtPoint(63412, 3392, false)								
farmerB:FollowPath(3433, 9)								
farmerB:FollowPath(3449, 8)								
farmerB:PlayOneShotSplitBodyAnim(Animations.EmoteCheer)								
farmerC = SpawnActorAtPoint(63410, 3393, false)								
farmerC:FollowPath(3434, 7)								
farmerC:FollowPathAtSpeed( 3557, 3 )								
farmerC:SetFacing(333)								
--farmers, kids								
"fenceActors = scene:CreateActorsAndWaitForLoad(listOfFenceCreateData, 0);"								
fireActor:SetInteractible(false)								
fireActor:SetInteractible(false)								
fireCreateData.creatureID = fireCreatureID								
fireCreateData.groundSnap = false								
fireCreateData.interactible = false								
"FlashHeal01 = SpawnModelActor( FlashHealModel, 292.12, 4007.6, 76.0999, 0 )"""	0	0						
for i=1, #corners do 								
for index, mist in pairs(mists) do								
for index, mist in pairs(mists) do								
for k,v in pairs ( arrayOfPoints ) do 								
for k,v in pairs(fenceActors) do								
for k,v in pairs(fences) do 								
forward = true								
fosho = SpawnActorAtPoint( 63378, 3370, false )								
fosho:FollowPath(3440, 4)								
fosho:FollowPath(3444, 6)								
fosho:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
fosho:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)								
fosho:StopLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
freelookZoomMax = 12								
freelookZoomMax = 12								
freelookZoomMin = 5								
freelookZoomMin = 5								
freelookZoomStart = 9.0								
function ActorCreateData:New(_id, _trans, _scale)								
function ActorCreateData:NewDisplay(_creatureID, _displayId, _trans, _scale)								
function ActorCreateData:NewModel(_name, _modelFile, _trans, _scale)								
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)								
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)								
function ApplyAura(pet, auraInstanceID, turnsRemaining, spellVisualID)								
function CameraDummyFollowPath( cameraDummy, pathID, moveTime )								
function CameraPosFollowPath( cameraModeID, pathID, moveTime )								
function CameraTgtFollowPath( cameraModeID, pathID, moveTime )								
function CastSpellAtActor( caster, target, spellID, faceTarget )								
function CastSpellAtActor( caster, target, spellID, faceTarget )								
function ClearTrapPrecast(playerID)								
function ClearTrapPrecast(playerID)								
function DeathAndRespawnCheck(pet)								
function DefaultDoEffect(ROID, isEffect, effect, handlerOverrides, skipCast ) 								
function DefaultTurnBehaviour( ROID, isTurn, turn )								
function Dispatcher_HandleSpellVisualPackage( ROID, turnVisualID, ...)								
function Dispatcher_HandleTurn(turn)								
function DoPadInit(transform)								
function FadeIn( actor, fadeTime )								
function FadeIn( actor, fadeTime )								
function FadeInAllPets( fadeInTime )								
function FadeInAllPets( fadeInTime )								
function FadeInAllPets( fadeInTime )								
function FadeInAllPets( fadeInTime )								
function FadeInAllPets( fadeInTime )								
function FadeOut( actor, fadeTime )								
function FadeOut( actor, fadeTime )								
function failureEffect_visual(targetPet, casterPet, result)								
function GenerateUniqueGroupKeys(effect)								
function GenerateUniqueGroupKeys(effect)								
function GenerateUniqueGroupKeys(effect)								
function GETROIDFROMPLAYERID( playerID )								
function GETROIDFROMPLAYERIDANDSLOT( playerID, slot )								
function GetStateLabel(zub)								
function GetTrapVisuals(playerID)								
function GetTrapVisuals(playerID)								
function HandleSpellVisualPackage(casterPlayerID, casterPetSlot, turnVisualID, ...)								
function huge_knockback_successEffect_visual(targetPet, casterPet, result)								
function InitPad(transform)								
function InitPet(team, petIndex, transform)								
function InitPet(team, petIndex, transform)								
function InitTeam(team)								
function ion_cannon_knockback_successEffect_visual(targetPet, casterPet, result)								
function LoadCustomVisualScript(abilityVisual)								
function LoadCustomVisualScript(abilityVisual)								
function PerformHardKnockback( opponent, pet, damage ) 								
function PerformJump( pet, dest, duration, animation )								
function PerformKnockback( opponent, pet, damage ) 								
function PerformKnockback( opponent, pet, howHard, duration ) 								
function PerformSlide( opponent, pet ) 								
function PerformTinyKnockback( opponent, pet, damage ) 								
function PerformTinySlide( opponent, pet, damage ) 								
function PerformVerticalKnockback( opponent, pet, damage ) 								
function PerformVerticalKnockback( opponent, pet, damage ) 								
function PlayLoopingSplitBodyAnim( actor, anim )								
function PlayLoopingSplitBodyAnim( actor, anim )								
function PlayOneShotSplitBodyAnim( actor, anim )								
function PlayOneShotSplitBodyAnim( actor, anim )								
function ProcessAbility(effect)								
function ProcessRoundEffectGroup(effectGroup)								
function ProcessRoundEffectGroup(effectGroup)								
function ProcessRoundResult(event)								
function ProcessRoundTurnGroup(turnGroup)								
function ProcessRoundTurnGroup(turnGroup)								
function ProcessSwap(effect)								
function RemoveAllAuraVisuals(pet)								
function RemoveAllAuraVisuals(pet)								
function RemoveAllAuraVisuals(pet)								
function RemoveAura(pet, auraInstanceID)								
function RemoveAura(pet, auraInstanceID)								
function RemoveAura(pet, auraInstanceID)								
function RemoveAuraVisual(pet, aura)								
function RemoveAuraVisual(pet, aura)								
function RemoveAuraVisual(pet, aura)								
function RunFollower(followTarget)								
function RunToLocation( actor, speed, x, y, z, facing )								
function RunToLocation( actor, speed, x, y, z, facing )								
function Scene:CreateActorAndWaitForLoad(createData, fadeInTime)								
function Scene:CreateActorsAndWaitForLoad(createDataList, fadeInTime)								
function Scene:WaitCondition(conditionFunc, freq, maxTime)								
function Scene:WaitEvent(freq, keepEvent)								
function Scene:WaitForActorsToLoad(actorList, fadeInTime)								
function secondary_successEffect_visual( secondaryVisual, targetPet, casterPet, result )								
function SendTrigger( triggerName )								
function SendTrigger( triggerName )								
function SetCamera( camera )								
function SetCamera(camera)								
function SetCamera(camera)								
function SetCameraFollowPath( cameraModeID, transitionTime, posPathID, tgtPathID, moveTime )								
function SignalEffectProcessed()								
function SignalEffectProcessed()								
function SpinCamera ()								
function StartEffectProcessing(event)								
function StartEffectProcessing(event)								
function StartTrapPrecast(playerID)								
function StartTrapPrecast(playerID)								
function StopCameraBunny(transitionTime)								
function StopCameraBunny(transitionTime)								
function StopLoopingSplitBodyAnim( actor )								
function StopLoopingSplitBodyAnim( actor )								
function StopLoopingSplitBodyAnim( actor )								
function StopLoopingSplitBodyAnim( actor )								
function TemplateCustomEffect(effectGroup)								
function TemplateCustomTurn(turn)								
function Transform:New(v, _yaw, _pitch, _roll)								
function TrapCast(effect)								
function TrapCast(effect)								
function UpdateAuraVisuals(pet)								
function UpdateAuraVisuals(pet)								
function UpdateAuraVisuals(pet)								
function WaitAllPetsLoaded()								
function WaitAllPetsLoaded()								
function WaitAllPetsLoaded()								
function WaitAllPetsLoaded()								
function WaitAllPetsLoaded()								
function WaitForTrigger( triggerName )								
function WaitForTrigger( triggerName )								
gorrok = SpawnActor( gorrokCreatureID, 1842.06, -4408.59, 135.232, 317.414, 1.0, false )								
gorrok = SpawnActor( gorrokCreatureID, 3434.29, -289.758, 268.19, 203.226, 1.0, false )								
gorrok:Despawn()								
gorrok:PlayLoopingFullBodyAnim(Animations.EmoteTalk)								
gorrok:PlayOneShotFullBodyAnim(Animations.EmoteCheer)								
gorrok:PlayOneShotFullBodyAnim(Animations.EmoteSalute)								
gorrok:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
gorrok:StopLoopingFullBodyAnim()								
gorrok:StopLoopingFullBodyAnim()								
"grummleCheer1: Despawn()"""	0	0						
grummleCheer1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleCheer2: Despawn()"""	0	0						
grummleCheer2:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleCheer3: Despawn()"""	0	0						
grummleCheer3:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleCheer4: Despawn()"""	0	0						
grummleCheer4:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleIncenseSniffer: Despawn()"""	0	0						
grummleIncenseSniffer:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
grummleMain: Despawn()								
grummleMain: SetFacing( 132.227 )								
grummleMain: SetFacing( 221.327 )								
"grummleMainBag: Despawn()"""	0	0						
grummleMainBag: PlayOneShotAnimKit( 2327 )								
--grummleMainBag: SetFacing(130.147)								
grummleMainBag: StopLoopingSplitBodyAnim( Animations.Run )								
--grummleMainBag:ClearSpellStateVisual(84, dazeAuraVisual) --Clear Daze Visual								
"grummlePacker1: Despawn()"""	0	0						
grummlePacker1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummlePacker2: Despawn()"""	0	0						
grummlePacker2:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
grummleVendor1: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleVendor1: Despawn()"""	0	0						
grummleVendor1: PlayLoopingFullBodyAnim( Animations.EmoteTalk )								
grummleVendor1: StopLoopingSplitBodyAnim( Animations.EmoteTalk )								
grummleVendor2: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleVendor2: Despawn()"""	0	0						
grummleVendor3: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
grummleVendor3: ClearSpellStateVisual(24987, fluteAura) -- Clear Flute Visual								
"grummleVendor3: Despawn()"""	0	0						
grummleVendor4: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleVendor4: Despawn()"""	0	0						
grummleVendor4: PlayLoopingFullBodyAnim(Animations.EmoteTalk)								
grummleVendor5: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"grummleVendor5: Despawn()"""	0	0						
grummleVendor5: PlayLoopingFullBodyAnim(Animations.SitGround)								
hiddenmaster = SpawnFadedActorAtPoint( 63385, 3377, false)								
hiddenmaster:FollowPathAtSpeed(3524, paradeSpeed)								
hiddenmaster:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
hiddenmaster:WaitMovementComplete()								
HOME_LIST = {								
if ( debugScale ) then								
if (not Scene.SetGameCameraTarget) then								
if (not Scene.SetGameCameraTarget) then								
if RunFollower then								
if Scene.ClearCameraShake and shakeY and shakeZ then								
incense1: Despawn()								
incense2: Despawn()								
incense3: Despawn()								
"incense4: Despawn()"""	0	0						
initialFadeInTime = 0.5 								
jooru = SpawnActorAtPoint( 63380, 3372, false )								
jooru:FollowPath(3441, 4)								
jooru:FollowPath(3445, 6)								
jooru:PlayLoopingSplitBodyAnim(Animations.ReadySpellDirected)								
jooru:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)								
jooru:StopLoopingSplitBodyAnim(Animations.ReadySpellDirected)								
kang = SpawnFadedActorAtPoint( 63388, 3380, false)								
kang:FollowPathAtSpeed(3550, 6)								
"kang:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)"""	0	0						
kang:WaitMovementComplete()								
kenken = SpawnFadedActorAtPoint( 63389, 3381, false)								
kenken:FollowPathAtSpeed(3548, 6)								
kenken:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)								
kenken:WaitMovementComplete()								
kidA = SpawnActorAtPoint(63405, 3394, false)								
kidA:FollowPath(3435, 4)								
kidA:FollowPathAtSpeed( 3558, 5 )								
kidA:SetFacing(333)								
kidB = SpawnActorAtPoint(63406, 3395, false)								
kidB:FollowPath(3436, 5)								
kidB:FollowPathAtSpeed( 3559, 6 )								
kidB:SetFacing(333)								
kidC = SpawnActorAtPoint(63407, 3396, false)								
kidC:FollowPath(3437, 5)								
kidC:FollowPathAtSpeed( 3560, 3 )								
kidC:SetFacing(333)								
kidD = SpawnActorAtPoint(63408, 3397, false)								
kidD:FollowPath(3438, 6)								
kidD:FollowPathAtSpeed( 3561, 4 )								
kidD:SetFacing(333)								
kidE = SpawnActorAtPoint(63411, 3398, false)								
kidE:FollowPath(3439, 5)								
kidE:FollowPathAtSpeed( 3562, 5 )								
"kidE:SetFacing(333)"""	0	0						
--Kill scene 6								
kiryn = SpawnActor( kirynCreatureID, 1847.05, -4419.12, 135.233, 9.03616, 1.0, false )								
kiryn = SpawnActor( kirynCreatureID, 3459.4, -278.842, 268.458, 202.139, 1.0, false )								
kiryn:Despawn()								
kiryn:PlayLoopingFullBodyAnim(Animations.Cower)								
kiryn:PlayLoopingFullBodyAnim(Animations.SitChairMed)								
kiryn:PlayLoopingFullBodyAnim(Animations.Stand)								
kiryn:PlayOneShotFullBodyAnim(Animations.EmoteCheer)								
kiryn:StopLoopingFullBodyAnim()								
"kiryn01: Despawn()"""	0	0						
koro = SpawnFadedActorAtPoint( 63384, 3376, false )								
koro:FollowPathAtSpeed(3537, paradeSpeed)								
koro:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
koro:WaitMovementComplete()								
koyan = SpawnActorAtPoint( 63379, 3371, false )								
koyan:FollowPath(3442, 4)								
"koyan:FollowPath(3446, 6)"""	0	0						
koyan:PlayLoopingSplitBodyAnim(Animations.Ready1H)								
koyan:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)								
koyan:StopLoopingSplitBodyAnim(Animations.Ready1H)								
"lamppost1: Despawn()"""	0	0						
lamppost1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
len = v1:Magnitude()								
leven = SpawnActorAtPoint( 63377, 3369, false )								
leven:FollowPath(3447, 8)								
leven:FollowPathAtSpeed(3427, 3)								
leven:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
leven:PlayOneShotSplitBodyAnim(Animations.EmoteSalute)								
leven:PlayOneShotSplitBodyAnim(Animations.EmoteTalk)								
leven:SetFacing(120)								
leven:SetFacing(84)								
light_cc: Despawn()								
light_cc: Despawn()								
light_cc: Despawn()								
light_cc: Despawn()								
light_cc: Despawn()								
light_cc: Despawn()								
"light_cc: Despawn()"""	0	0						
"light_cl: Despawn()"""	0	0						
"light_cr: Despawn()"""	0	0						
light_uc: Despawn()								
light_ul: Despawn()								
light_ul: Despawn()								
light_ur: Despawn()								
"light_ur: Despawn()"""	0	0						
lili = SpawnFadedActorAtPoint( 63382, 3374, false )								
lili:FollowPathAtSpeed(3523, paradeSpeed)								
lili:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
lili:WaitMovementComplete()								
lin = SpawnFadedActorAtPoint( 63386, 3378, false)								
lin:FollowPathAtSpeed(3551, 6)								
lin:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)								
lin:WaitMovementComplete()								
"littlesaurok: Despawn()"""	0	0						
"lizard1: Despawn()"""	0	0						
"lizard2: Despawn()"""	0	0						
"lizard3: Despawn()"""	0	0						
local actorAuraVisual = allianceCaptain:PlaySpellStateVisual(9628) --Cast Actor Visual								
local actorAuraVisual = allianceCrewman01:PlaySpellStateVisual(9628) --Cast Actor Visual								
local actorAuraVisual = allianceCrewman02:PlaySpellStateVisual(9628) --Cast Actor Visual								
local actorAuraVisual = allianceCrewman02:PlaySpellStateVisual(9628) --Cast Actor Visual								
local actorAuraVisual = grummleCheer1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleCheer2:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleCheer3:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleCheer4:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleIncenseSniffer:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleMain:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleMainBag:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummlePacker1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummlePacker2:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleVendor1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleVendor2:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleVendor3:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleVendor4:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = grummleVendor5:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = lamppost1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = lizard1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = lizard2:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = lizard3:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguGrunt01:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguGrunt02:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguMace1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguMain:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguPoleArm1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = moguSlaver02:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = pandarenSlave02:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = pandarenSlave03:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = richPandaren1:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = shadopan01:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = tian:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = trogg01:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = trogg02:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = trogg03:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = troggMain:PlaySpellStateVisual(24803) --Cast Actor Visual								
local actorAuraVisual = whiteyak:PlaySpellStateVisual(23826) -- Incense Aura for Yak								
local actorList = scene:CreateActorsAndWaitForLoad({fireCreateData1, fireCreateData2})								
local actorList = scene:CreateActorsAndWaitForLoad({fireCreateData1, fireCreateData2})								
local actors = {								
local allianceCaptainCreatureID = 62635								
local allianceCrewmanCreatureID = 62634								
local allianceCrewmanCreatureID = 62634								
local allianceCrewmanCreatureID = 62634								
local allianceCrewmanCreatureID = 62634								
local allianceCrewmanCreatureID = 62634								
"local allianceShipModel = \""world\\expansion03\\doodads\\generic\\alliance_ship01.m2\"""								
local arrayOfPoints = {								
local cameraBunnyCreate = ActorCreateData:Default()								
local cameraDummyCreateData = ActorCreateData:Default()								
local cameraDummyPositions = { }								
local cameraDummyTargets = { }								
"local camModel2 = \""CREATURE\\INVISIBLESTALKER\\InvisibleStalker_noAnims.mdx\"" -- \""Spells\\FIREBALL_MISSILE_HIGH.MDX\""; --"								
local cloneCreatureID = 61833								
local cloneCreatureID = 61833								
"local cloudModel = \""world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"""								
local corners = { 								
local crashbunnyCreatureID = 61997								
local createFormatString = [[								
local createFormatString = [[								
local dazeAuraVisual = grummleMainBag:PlaySpellStateVisual(84) --Cast Daze Visual								
local debugScale = true								
"local distance = 7.5;"								
local fences = { 								
local fireActor = actorList[1]								
local fireActor = actorList[1]								
--local fireActors = scene:SpawnActorsAtPoints(fireCreateData, 3036)								
local fireCreateData = ActorCreateData:Default()								
local fireCreateData1 = ActorCreateData:NewModel(								
local fireCreateData2 = ActorCreateData:NewModel(								
local fireCreatureID = 60157								
local fluteAura = grummleVendor3:PlaySpellStateVisual(24987) --Cast Flute Visual								
local gorrokCreatureID = 61846								
local gorrokCreatureID = 61846								
local instance = crashBunny:PlaySpellStateVisual(25201)								
local instance = shipFire01:PlaySpellStateVisual(19388)								
local instance = shipFire01:PlaySpellStateVisual(25187)								
local instance = shipFire02:PlaySpellStateVisual(19388)								
local instance = shipFire02:PlaySpellStateVisual(25187)								
local instance = shipFire03:PlaySpellStateVisual(19388)								
local instance = shipFire03:PlaySpellStateVisual(25187)								
local instance = zeppelinFire:PlaySpellStateVisual(19335)								
local instance = zeppelinFire:PlaySpellStateVisual(25195)								
local instance = zeppelinFire01:PlaySpellStateVisual(25195)								
local instance = zeppelinFire01:PlaySpellStateVisual(25196)								
local instance = zeppelinFire02:PlaySpellStateVisual(25195)								
local instance = zeppelinFire02:PlaySpellStateVisual(25196)								
local instance = zeppelinFire03:PlaySpellStateVisual(19335)								
local instance = zeppelinFire03:PlaySpellStateVisual(9520)								
local instance = zeppelinTarget04:PlaySpellStateVisual(19388)								
local instance = zeppelinTarget04:PlaySpellStateVisual(25187)								
local kirynCreatureID = 61867								
local kirynCreatureID = 61867								
local listOfFenceCreateData = {}								
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth								
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth								
local maxStackDepth = 16          -- turn keys are not guaranteed unique above this stack depth								
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn								
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn								
local maxTurnInstanceIDs = 100    -- effect keys are not guaranteed unique above this many actions a turn								
"local mistModel = \""world\\environment\\doodad\\generaldoodads\\steamclouds\\generic_steam_cloud_deepholm.m2\"""								
local moguCreatureID = 63143								
local nazgrimCreateData = ActorCreateData:Default()								
local nazgrimCreatureID = 61682								
local nazgrimCreatureID = 61682								
local newActor = scene:SpawnActor(								
local reasonIndex = 0								
local relativeMover = allianceCaptain -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = clone -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = clone -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = gorrok -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = gorrok -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = kiryn -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = kiryn -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = nazgrim -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = nazgrim -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = rivett -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = rivett -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = shokia -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = shokia -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = snuff -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = snuff -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = vanguard01 -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = vanguard02 -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = vanguard03 -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = zinjun -- CHANGE allianceCaptain to the appropriate NPC								
local relativeMover = zinjun -- CHANGE allianceCaptain to the appropriate NPC								
local rivettCreatureID = 61844								
local rivettCreatureID = 61844								
"local segments = 4;"								
local shakeOrigin = Vector:New(3723.47, -639.766, 14.877)								
local shakeOrigin01 = Vector:New(3168.19, -429.932, 246.441)								
local shokiaCreatureID = 61866								
local shokiaCreatureID = 61866								
local snuffCreatureID = 61869								
local snuffCreatureID = 61869								
local soundHandle = nazgrim:PlaySoundKit(25504, false)								
"local stalkerModel = \""CREATURE\\INVISIBLESTALKER\\InvisibleStalker.M2\"""								
"local testModel = \""world\\generic\\magehunter\\passive doodads\\runecircle\\mh_runecircle_01.m2\"""								
local vanguard01CreatureID = 61845								
local vanguard01CreatureID = 61845								
local vanguard02CreatureID = 61845								
local vanguard02CreatureID = 61845								
local vanguard03CreatureID = 61845								
local vanguard03CreatureID = 61845								
local voHandle = nazgrim:PlaySoundKit(25898, true)								
local walls = SpawnModelActorsAtPoints( wallModel, 3389, false )								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosDest = worldPosSrc + zeppelinMoveOffset								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local worldPosSrc = relativeMover:GetPosition()								
local z = {								
local zeppelinCannonBunnyCreatureID = 61997								
local zeppelinFireCreatureID = 61997								
local zeppelinFireCreatureID = 61997								
local zeppelinFireCreatureID = 61997								
local zeppelinFireCreatureID = 61997								
local zeppelins = SpawnModelActorsAtPoints( zeppelinModel, 3093, false )								
local zeppelins = SpawnModelActorsAtPoints( zeppelinModel, 3131, false )								
local zinjunCreatureID = 61868								
local zinjunCreatureID = 61868								
loon = SpawnActorAtPoint( 63374, 3368, false )								
--Loon, close								
loon:FollowPath(3426, 2)								
loon:PlayOneShotSplitBodyAnim(Animations.EmoteNo)								
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)								
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)								
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)								
loon:PlayOneShotSplitBodyAnim(Animations.EmotePoint)								
loon:PlayOneShotSplitBodyAnim(Animations.EmoteShout)								
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalk)								
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalkExclamation)								
loon:PlayOneShotSplitBodyAnim(Animations.EmoteTalkExclamation)								
loon:SetFacing(111)								
loon:SetFacing(175)								
loon:SetFacing(300)								
loon:SetFacing(303)								
loon:SetFacing(75)								
loon:SetFacing(84)								
loon:SetFacing(84)								
lorewalker: Despawn()								
"lorewalker: Despawn()"""	0	0						
lyalia = SpawnFadedActorAtPoint( 63395, 3386, false )								
lyalia:FollowPathAtSpeed(3532, paradeSpeed)								
lyalia:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
lyalia:WaitMovementComplete()								
"mainCamera = scene:SpawnActor( b );"								
"mainCameraTarget = scene:SpawnActor( a );"								
mantidLeven01:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)								
mantidLeven02:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
mantidLeven03:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)								
mantidLeven04:PlayLoopingSplitBodyAnim(Animations.AttackUnarmed)								
MASTER_SPOTS = { 								
"mishka01: Despawn()"""	0	0						
"mishka01: Despawn()"""	0	0						
missfanny = SpawnFadedActorAtPoint( 63392, 3384, false)								
"missfanny:FollowPathAtSpeed(3531, paradeSpeed)"""	0	0						
mist = SpawnModelActor( mistModel, 2127.5, -476.5, 398, 27.4498, 2.0, false )								
mist = SpawnModelActor( mistModel, 3450.53, -299.764, 269, 128.282, 4.0, false )								
mists = SpawnModelActorsAtPoints( cloudModel, 3094, false )								
mogu = SpawnActor( moguCreatureID, 2128.1, -475.986, 395, 354, 1.5, false )								
mogu:PlayLoopingAnimKit(2442)								
moguFace: Despawn()								
"moguFace: Despawn()"""	0	0						
"moguFace: Despawn()"""	0	0						
moguFist1: Despawn()								
"moguGrunt01: Despawn()"""	0	0						
"moguGrunt02: Despawn()"""	0	0						
moguMace1: Despawn()								
"moguMace1: Despawn()"""	0	0						
moguMain: Despawn()								
"--moguMain: Despawn()"""	0	0						
--moguMain: SetFacingToAbs(Vector:New(1444.44, 360.476, 550.221)) 								
moguMain:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
--moguMain:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
moguPoleArm1: Despawn()								
"moguPoleArm1: Despawn()"""	0	0						
moguPulse01 = SpawnModelActor( moguPulseModel, 3759, 1655.91, 750, 180, 2, false )								
"moguPulseModel = \""SPELLS\\BloodBolt_Chest.M2\"""								
moguRemains01 = SpawnModelActor( moguRemainsModel, 3759, 1655.91, 748.963, 180, 3 )								
"moguRemainsModel = \""WORLD\\EXPANSION04\\DOODADS\\MOGU\\Mogu_Statue_02Broken_Piece01.M2\"""								
"moguSlaver02: Despawn()"""	0	0						
moguSlaver02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
monkA = SpawnFadedActorAtPoint( 63397, 3413, false )								
monkA:FollowPathAtSpeed(3538, paradeSpeed)								
monkA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
monkA:WaitMovementComplete()								
monkB = SpawnFadedActorAtPoint( 63397, 3414, false )								
monkB:FollowPathAtSpeed(3539, paradeSpeed)								
monkB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
monkB:WaitMovementComplete()								
monkC = SpawnFadedActorAtPoint( 63397, 3415, false )								
monkC:FollowPathAtSpeed(3540, paradeSpeed)								
monkC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
monkC:WaitMovementComplete()								
monkD = SpawnFadedActorAtPoint( 63397, 3416, false )								
monkD:FollowPathAtSpeed(3541, paradeSpeed)								
monkD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
monkD:WaitMovementComplete()								
mudmug = SpawnFadedActorAtPoint( 63383, 3375, false )								
mudmug:FollowPathAtSpeed(3522, paradeSpeed)								
mudmug:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
mudmug:WaitMovementComplete()								
nazgrim = scene:SpawnActor(nazgrimCreateData)								
nazgrim = SpawnActor( nazgrimCreatureID, 1840.65, -4419.42, 135.233, 41, 1.0, false )								
nazgrim = SpawnActor( nazgrimCreatureID, 3447.54, -289.77, 266.9, 175.826, 1.0, false )								
nazgrim:BroadcastText(BroadcastType.Say, 63387)								
nazgrim:Despawn()								
--nazgrim:FollowPath(3045, 20)								
nazgrim:PlayOneShotAnimKit(2329)								
nazgrim:PlayOneShotAnimKit(2332)								
nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)								
nazgrim:PlayOneShotFullBodyAnim(Animations.EmotePointNoSheathe)								
nazgrim:PlayOneShotFullBodyAnim(Animations.EmoteRoar)								
nazgrim:PlayOneShotFullBodyAnim(Animations.EmoteTalkNoSheathe)								
nazgrim:SetFacing(120)								
nazgrim:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
nazgrim:WaitSoundKitComplete(voHandle)								
nazgrimCreateData.creatureID = nazgrimCreatureID								
nazgrimCreateData.transform = Transform:New(Vector:New(0, 10, 0), 7.86258)								
--nazgrimCreateData.transform = Transform:New(Vector:New(2273.87, 974.358, 482.445), 7.86258)								
nazgrimCreatureID = 60149								
--Over Loon\'s shoulder								
padAlpha = 0.0								
padAlpha = 0.0								
padAlpha = 0.333								
padAlpha = 1.0								
padAlpha = 1.0								
padAlpha = 1.0								
"padModel = \""world\\goober\\g_runegroundpurple01.m2\"""								
"padModel = \""world\\goober\\g_runegroundpurple01.m2\"""								
"padModel = \""world\\goober\\g_runegroundpurple01.m2\"""								
padScale = 0.4								
padScale = 0.4								
padScale = 0.4								
padScale = 1.0								
padScale = 1.0								
padScale = 1.0								
"panda01: Despawn()"""	0	0						
"panda01: Despawn()"""	0	0						
"panda02: Despawn()"""	0	0						
"panda02: Despawn()"""	0	0						
"panda03: Despawn()"""	0	0						
"panda03: Despawn()"""	0	0						
"panda05: Despawn()"""	0	0						
"panda05: Despawn()"""	0	0						
panda06: Despawn()								
"pandarenSlave02: Despawn()"""	0	0						
pandarenSlave02:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"pandarenSlave03: Despawn()"""	0	0						
pandarenSlave03:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
pang = SpawnFadedActorAtPoint( 63391, 3383, false)								
pang:FollowPathAtSpeed(3530, paradeSpeed)								
petBattleAnimKits =								
petBattleAnimKits =								
petBattleAnimKits =								
petBattleAnimKits =								
placeHolderActors = nil								
placeHolderActors = nil								
PlayLoopingSplitBodyAnim( grummleIncenseSniffer, Animations.SitGround )								
PlayLoopingSplitBodyAnim( grummleIncenseSniffer, Animations.SitGround )								
PlayLoopingSplitBodyAnim( grummleMain, Animations.Run )								
PlayLoopingSplitBodyAnim( grummleMainBag, Animations.Run )								
PlayLoopingSplitBodyAnim( grummleMainBag, Animations.SitGround )								
--PlayLoopingSplitBodyAnim( grummleMainBag, Animations.Stand )								
PlayLoopingSplitBodyAnim( grummlePacker1, Animations.Run )								
PlayLoopingSplitBodyAnim( grummlePacker2, Animations.Run )								
PlayLoopingSplitBodyAnim( moguMace1, Animations.Attack2H )								
PlayLoopingSplitBodyAnim( moguMace1, Animations.Ready2HL )								
--PlayLoopingSplitBodyAnim( moguPoleArm1, Animations.Attack2H )								
PlayLoopingSplitBodyAnim( moguPoleArm1, Animations.Ready2H )								
PlayLoopingSplitBodyAnim( saurok_heal, Animations.MountSelfIdle )								
PlayLoopingSplitBodyAnim( tian, Animations.EmoteLaugh )								
PlayLoopingSplitBodyAnim( tian, Animations.EmoteTalkExclamation )								
PlayOneShotSplitBodyAnim( grummleCheer1, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( grummleCheer2, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( grummleCheer3, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( grummleCheer4, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( grummleMain, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( grummleMain, Animations.EmotePoint )								
--PlayOneShotSplitBodyAnim( grummleMainBag, Animations.SitGroundUp )								
PlayOneShotSplitBodyAnim( grummleVendor1, Animations.EmoteTalk )								
PlayOneShotSplitBodyAnim( grummleVendor2, Animations.EmoteTalk )								
PlayOneShotSplitBodyAnim( kiryn01, Animations.EmoteApplaud )								
PlayOneShotSplitBodyAnim( kiryn01, Animations.EmoteCheer )								
PlayOneShotSplitBodyAnim( littlesaurok, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( mishka01, Animations.EmoteApplaud )								
PlayOneShotSplitBodyAnim( mishka01, Animations.EmoteCheer )								
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguGrunt01, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguGrunt02, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( moguPoleArm1, Animations.Attack2HL )								
PlayOneShotSplitBodyAnim( moguPoleArm1, Animations.EmotePoint )								
PlayOneShotSplitBodyAnim( saurok_hack, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( saurok_heal, Animations.BattleRoar )								
PlayOneShotSplitBodyAnim( shadopan01, Animations.EmoteBow )								
PlayOneShotSplitBodyAnim( sully01, Animations.EmoteApplaud )								
PlayOneShotSplitBodyAnim( sully01, Animations.EmoteCheer )								
PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteLaugh )								
PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteTalk )								
PlayOneShotSplitBodyAnim( trollPriest01, Animations.EmoteTalkExclamation )								
pointIndex = 1								
points =								
priestA = SpawnFadedActorAtPoint( 63451, 3417, false )								
priestA:FollowPathAtSpeed(3542, paradeSpeed)								
priestA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
priestA:WaitMovementComplete()								
priestB = SpawnFadedActorAtPoint( 63451, 3418, false )								
priestB:FollowPathAtSpeed(3543, paradeSpeed)								
priestB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
priestB:WaitMovementComplete()								
priestC = SpawnFadedActorAtPoint( 63451, 3419, false )								
priestC:FollowPathAtSpeed(3544, paradeSpeed)								
priestC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
priestC:WaitMovementComplete()								
priestD = SpawnFadedActorAtPoint( 63451, 3420, false )								
priestD:FollowPathAtSpeed(3545, paradeSpeed)								
priestD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
priestD:WaitMovementComplete()								
"print(\""-- END: Darren\'s Follower --\"")"								
"print(\""-- END: Darren\'s Movement and Facing Test --\"")"								
"print(\""-- END: Darren\'s Test Scene Script 5\"")"								
"print(\""-- END: Darren\'s Test Script 1 --\"")"								
"print(\""-- END: Darren\'s Test Script 2 --\"")"								
"print(\""-- END: Darren\'s Test Script 3 --\"")"								
"print(\""-- END: Darren\'s Test Script 6 --\"")"								
"print(\""Ahoy Thar dsfasdfafsds\"")"								
"print(\""ERROR: Target Player ID is: \"",targetPlayerID);"								
"--print(\""Getter: \"",playerID, \"" \"", slot);"								
"Print(\""ION CANNON!\"");"								
"Print(\""LEAP~!\"");"								
"print(\""len = \"" .. len)"								
"print(\""v1 = \"" .. v1 .. \"", v2 = \"" .. v2 .. \"", add = \"" .. v3)"								
"print(\""v1 = \"" .. v1 .. \"", v2 = \"" .. v2 .. \"", minus = \"" .. v3)"								
"print(\""v1 = \"" .. v1 .. \"", v2 = \"" .. v2 .. \"", mul x 4 = \"" .. v3)"								
"print(\""v1 = \"" .. v1 .. \"", v2 = \"" .. v2 .. \"", sub = \"" .. v3)"								
print(d)								
"print(turnVisual.range);"								
"--print(v.index,\"": \"",remainder,\"":\"",v.actor:IsMoving())"								
"ProcessRoundTurnGroup = Dispatcher_HandleTurn;"								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:PlayLoopingFullBodyAnim(Animations.Stand)								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
relativeMover:StopLoopingFullBodyAnim()								
"relativeMover:StopLoopingFullBodyAnim()"""	0	0						
"relativeMover:StopLoopingFullBodyAnim()"""	0	0						
"relativeMover:StopLoopingFullBodyAnim()"""	0	0						
"relativeMover:StopLoopingFullBodyAnim()"""	0	0						
return function(...)								
return function(effects)								
richPandaren1: ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
"richPandaren1: Despawn()"""	0	0						
richPandaren1: PlayLoopingFullBodyAnim(Animations.EmoteTalkExclamation)								
rivett = SpawnActor( rivettCreatureID, 1843.93, -4420.85, 135.233, 104.292, 1.0, false )								
rivett = SpawnActor( rivettCreatureID, 3458.38, -288.321, 268.1, 290.783, 1.0, false )								
rivett:Despawn()								
rivett:PlayLoopingFullBodyAnim(Animations.Cower)								
rivett:PlayOneShotFullBodyAnim(Animations.EmoteCheer)								
rivett:PlayOneShotFullBodyAnim(Animations.EmotePoint)								
rivett:PlayOneShotFullBodyAnim(Animations.EmoteShout)								
rivett:SetFacing(157)								
rivett:StopLoopingFullBodyAnim()								
--Run in, jumpkick fool								
--Run in, punch fools								
RunToLocation( cho, 2, 2130.74, -474.679, 392.885, 29 )								
RunToLocation( cho, 2, 2135.42, -476.072, 392.935, 205.425 )								
RunToLocation( cho, 2, 2141.74, -476.905, 392.37, 330.525 )								
RunToLocation( clone, 1, 3449.42, -286.845, 266.9, 276.345 )								
RunToLocation( clone, 3.5, 1826.63, -4429.49, 135.18, 269.876)								
RunToLocation( clone, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( clone, 400, 3168.19, -429.932, 246.441, 213 )								
RunToLocation( egg1, 5, 1463.12, 366.547, 550.221)								
RunToLocation( egg2, 5, 1459.96, 365.049, 550.221)								
RunToLocation( egg3, 5, 1451.5, 371.934, 550.222)								
RunToLocation( gorrok, 2, 3434.29, -289.758, 268.19, 203.226 )								
RunToLocation( gorrok, 2, 3439.87, -293.908, 267.8, 293.237 )								
RunToLocation( gorrok, 2, 3442.33, -288.137, 267.447, 336 )								
RunToLocation( gorrok, 3.5, 1836.41, -4426.74, 135.5, 300)								
RunToLocation( gorrok, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( gorrok, 3.5, 1838.25, -4433.68, 136.2, 316.901)								
--RunToLocation( grummleIncenseSniffer, 7, 1443.38, 362.09, 550.221  )								
--RunToLocation( grummleIncenseSniffer, 7, 1443.38, 362.09, 550.221  )								
--RunToLocation( grummleMainBag, 2, 1447.98, 369.523, 550.221  )								
--RunToLocation( grummleMainBag, 2, 1450.79, 369.54, 550.221  )								
RunToLocation( grummlePacker1, 7, 1443.38, 362.09, 550.221  )								
RunToLocation( grummlePacker2, 7, 1446.07, 358.825, 550.221  )								
RunToLocation( grummleVendor1, 2, 1460.35, 375.131, 550.221, 41.5002  )								
RunToLocation( grummleVendor2, 2, 1460.58, 372.162, 550.221, 41.5002  )								
RunToLocation( kiryn, 1, 3456.55, -280.263, 268.1, 130.8 )								
RunToLocation( kiryn, 3.5, 1819.94, -4418.78, 136.4, 316.901)								
RunToLocation( kiryn, 3.5, 1822.66, -4422.05, 136.4, 131.726)								
RunToLocation( kiryn, 3.5, 1824.08, -4423.17, 135.3, 141.851)								
RunToLocation( kiryn, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( lamppost1, 4, 1460.04, 374.389, 550.222 )								
RunToLocation( lorewalker, 2, 1447.18, 371.453, 550.221, 93.5645 )								
RunToLocation( lorewalker, 2, 1447.35, 371.28, 550.221, 96.3434, true)								
RunToLocation( lorewalker, 2, 1449.42, 358.265, 550.221, 36.9958 )								
RunToLocation( lorewalker, 2, 1451.2, 366.019, 550.221, 104.938 ) 								
RunToLocation( lorewalker, 2, 1453.76, 373.314, 550.221, 155.518, true)								
RunToLocation( lorewalker, 2, 1455.54, 372.492, 550.222, 139.374) --Cross to Center								
RunToLocation( lorewalker, 2, 1456.04, 367.276, 550.222, 133.746 )								
RunToLocation( lorewalker, 2, 1457.44, 365.731, 550.221, 130.144 ) 								
RunToLocation( lorewalker, 2, 1457.44, 365.731, 550.221, 130.144 ) 								
RunToLocation( lorewalker, 2, 1463.12, 371.442, 550.221, 130.144 ) --Cross to Stage right								
RunToLocation( lorewalker, 2, 1465.6, 368.785, 550.221, 205.073 ) -- Cross UR								
RunToLocation( moguMace1, 5,1462.19, 377.953, 550.221, 195.386)								
RunToLocation( moguMain, 2, 1457.22, 366.413, 550.222, 131.724 )								
RunToLocation( moguMain, 2, 1458.92, 371.169, 550.222, 218.403 )								
--RunToLocation( moguMain, 2, 1467.41, 377.901, 550.222, 218.403 )								
RunToLocation( moguPoleArm1, 2, 1464.2, 372.466, 550.221, 219.87)								
RunToLocation( moguPoleArm1, 5, 1467.08, 374.867, 550.221, 225.045) -- setup for scene 6								
RunToLocation( moguPoleArm1, 5,1463.83, 375.459, 550.221, 236.786)								
--RunToLocation( moguSlaver02, 2, 1467.81, 372.467, 550.222 )								
RunToLocation( nazgrim, 4, 1829.62, -4425.06, 135.18, 316.353 )								
RunToLocation( nazgrim, 4, 1835.71, -4421.69, 135.18, 210.603 )								
RunToLocation( nazgrim, 4, 3447.87, -293.173, 266.9, 294 )								
RunToLocation( nazgrim01, 3, 2272.157, 896.843, 481.231, 100 )								
RunToLocation( nazgrim01, 3, 2272.32, 907.589, 481.128, 273.167 )								
RunToLocation( nazgrim01, 3, 2273.15, 914.13, 481.287, 262.367 )								
RunToLocation( panda01, 3, 2110.84, 1445.04, 149 )								
RunToLocation( panda01, 3, 2276.55, 970.392, 482.394, 101.25 )								
RunToLocation( panda02, 3, 2161.75, 1492.9, 487.886, 87.4315 )								
RunToLocation( panda02, 3, 2166.38, 1522.54, 494.402, 78.4314 )								
RunToLocation( panda02, 3, 2270.03, 950.734, 481.315, 24.7839 )								
RunToLocation( panda05, 3, 2135.24, 1461.33, 487.886, 178.989 )								
RunToLocation( panda05, 3, 2256.42, 939.436, 481.148, 126.017 )								
RunToLocation( panda06, 3, 2254.1, 944.32, 481.123, 104.867 )								
--RunToLocation( pandarenSlave02, 2, 1466.88, 375.627, 550.221 )								
--RunToLocation( pandarenSlave03, 2, 1464.94, 373.747, 550.222 )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, allianceShipMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveSpeed, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( relativeMover, zeppelinMoveTime, worldPosDest.x, worldPosDest.y, worldPosDest.z )								
RunToLocation( rivett, 2, 3454.62, -276.787, 268.1, 60 )								
RunToLocation( rivett, 2, 3456.49, -282.811, 268.1, 275 )								
RunToLocation( rivett, 2, 3456.92, -282.23, 268.1, 251.326 )								
RunToLocation( rivett, 3.5, 1823.17, -4418.4, 136.4, 310.278)								
RunToLocation( rivett, 3.5, 1824.86, -4419.68, 136.4, 147.603)								
RunToLocation( rivett, 3.5, 1826.46, -4420.67, 135.3, 156.378)								
RunToLocation( rivett, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( shokia, 2, 3450.24, -285.118, 267.019, 267.956 )								
RunToLocation( shokia, 3.5, 1823.88, -4425.88, 135.3, 336.476)								
RunToLocation( shokia, 3.5, 1832.44, -4428.37, 135.586, 197.201)								
RunToLocation( shokia, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( snuff, 3.5, 1824.9, -4415.01, 136.4, 327.926)								
RunToLocation( snuff, 3.5, 1824.9, -4415.01, 136.4, 327.926)								
RunToLocation( snuff, 3.5, 1828.71, -4418.81, 135.3, 135.326)								
RunToLocation( snuff, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( snuff, 4, 3458.08, -288.528, 268.1, 290.064 )								
RunToLocation( taylor01, 3, 2149.99, 1464.34, 487.886, 2.649 )								
RunToLocation( taylor01, 3, 2168.91, 1474.57, 487.886, 193 )								
RunToLocation( trogg01, 5.5, 1448.95, 356.926, 550.222, 228.392 )								
RunToLocation( trogg01, 5.5, 1451.81, 362.822, 550.222, 177.767 )								
RunToLocation( trogg01, 5.5, 1452.64, 360.794, 550.222, 292.292 )								
RunToLocation( trogg01, 5.5, 1453.48, 362.303, 550.222, 60.7672 )								
RunToLocation( trogg02, 5.5, 1442.34, 362.558, 550.221, 222.679 )								
RunToLocation( trogg02, 5.5, 1444.47, 367.409, 550.221, 91.9536 )								
RunToLocation( trogg02, 5.5, 1445.27, 364.92, 550.221, 228.754 )								
RunToLocation( trogg02, 5.5, 1446.52, 365.808, 550.221, 8.25353 )								
RunToLocation( trogg03, 5.5, 1446.07, 357.41, 550.221, 209.178 )								
RunToLocation( trogg03, 5.5, 1446.66, 357.854, 550.221, 122.103 )								
RunToLocation( trogg03, 5.5, 1448.08, 355.902, 550.221, 242.928 )								
RunToLocation( trogg03, 5.5, 1448.39, 358.707, 550.221, 18.378 )								
RunToLocation( troggMain, 2, 1454.37, 369.568, 550.222, 41.102 )								
RunToLocation( trollPriest01, 5, 3600.05, 1571.08, 757.963, 264.075 )								
RunToLocation( trollPriest01, 5, 3602.81, 1598.81, 743.012, 264.299 )								
RunToLocation( trollPriest01, 5, 3605.16, 1622.07, 742.666, 264 )								
RunToLocation( trollPriest01, 5, 3606.92, 1640.85, 742.683, 264 )								
RunToLocation( trollPriest01, 5, 3606.92, 1640.85, 742.683, 84.3163 )								
RunToLocation( trollPriest01, 5, 3615.26, 1557.32, 759.908, 21.2992 )								
RunToLocation( vanguard01, 3.5, 1829.91, -4418.78, 135.18, 309.205)								
RunToLocation( vanguard01, 3.5, 1831.54, -4422.2, 135.18, 122.9)								
RunToLocation( vanguard01, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( vanguard02, 3.5, 1835.17, -4434.62, 136.2, 303.355)								
RunToLocation( vanguard02, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( vanguard02, 3.5, 1839.62, -4439.6, 136.8, 281.081)								
RunToLocation( vanguard03, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation( vanguard03, 3.5, 1840.15, -4430.83, 136.2, 306.956)								
RunToLocation( vanguard03, 3.5, 1843.91, -4434.75, 136.8, 331.706)								
RunToLocation( whiteyak, 2, 1457.78, 372.955, 550.222, 38.3463  )								
RunToLocation( zinjun, 1, 3460.48, -284.169, 268.1, 199.819 )								
RunToLocation( zinjun, 3.5, 1823.17, -4415.84, 136.4, 321.401)								
RunToLocation( zinjun, 3.5, 1825.77, -4418.44, 136.4, 139.826)								
RunToLocation( zinjun, 3.5, 1827.17, -4420.16, 135.3, 139.151)								
RunToLocation( zinjun, 3.5, 1838.08, -4421.66, 135.234, 215.103)								
RunToLocation(allianceShip, 500, 3845.42, -645.091, 0)								
RunToLocation(allianceShip, allianceShipMoveTime, allianceShipDest.x, allianceShipDest.y, allianceShipDest.z)								
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)								
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)								
RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)								
--RunToLocation(lizard1, 2, 1450.64, 372.105, 550.221, 226.669)								
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)								
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)								
RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)								
--RunToLocation(lizard1, 2, 1452.79, 374.391, 550.221, 103.819)								
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)								
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)								
RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)								
--RunToLocation(lizard1, 2, 1453.33, 375.299, 550.221, 36.0935)								
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)								
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)								
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)								
RunToLocation(lizard2, 2, 1446.11, 364.98, 550.221, 153.093)								
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)								
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)								
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)								
RunToLocation(lizard2, 2, 1446.68, 363.408, 550.221, 317.117)								
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)								
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)								
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)								
RunToLocation(lizard2, 2, 1447.04, 365.694, 550.221, 63.5425)								
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)								
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)								
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)								
RunToLocation(lizard3, 2, 1457.11, 376.419, 550.221, 276.168)								
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)								
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)								
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)								
RunToLocation(lizard3, 2, 1458.24, 376.539, 550.221, 135.543)								
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)								
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)								
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)								
RunToLocation(lizard3, 2, 1459.67, 375.32, 550.221, 340.068)								
RunToLocation(lorewalker, 2, 1452.46, 357.498, 550.221, 129.194, true)								
RunToLocation(moguMace1, 2, 1462.35, 368.695, 550.223, 132.17)								
RunToLocation(moguPoleArm1, 2, 1452.2, 359.916, 550.221, 127.444)								
RunToLocation(saurok_hack, 4, 1453.68, 365.862, 550.221, 51.5689)								
RunToLocation(saurok_hack, 5, 1448.76, 358.391, 550.221, 54.2689)								
RunToLocation(saurok_hack4, 1, 1454.27, 361.229, 560.222, 124.734, false) --Float in air								
RunToLocation(saurok_hack4, 2, 1456.78, 356.96, 551.863, 133.284, false)								
RunToLocation(saurok_hack4, 4, 1454.27, 361.229, 550.222, 124.734, true) --Run to Tian								
RunToLocation(saurok_hack5, 2, 1464.62, 364.296, 551.862, 130.584, false)								
RunToLocation(saurok_hack5, 4, 1456.3, 365.106, 550.222, 168.609, true)								
RunToLocation(saurok_hack6, 2, 1468.44, 367.551, 551.862, 130.584, false)								
RunToLocation(saurok_hack6, 4, 1458.96, 371.655, 550.222, 208.884, true)								
RunToLocation(saurok_heal, 5, 1449.89, 369.873, 550.222, 67.5435)								
RunToLocation(shipFire01, 500, 3835.78, -653.77, 12.9994)								
RunToLocation(shipFire02, 500, 3851.24, -641.253, 6.3)								
RunToLocation(shipFire03, 500, 3859.47, -636.061, 18.5503)								
RunToLocation(terrorcotta1, 2, 1448.2, 361.327, 550.222, 222.344, true)								
RunToLocation(terrorcotta1, 2, 1458.17, 371.436, 550.221, 219.419, true)								
RunToLocation(terrorcotta1, 2, 1462.21, 374.621, 550.221, 220.322, true)								
RunToLocation(tian, 2, 1457.29, 366.243, 550.222, 129.022)								
RunToLocation(tian, 5, 1449.02, 362.493, 550.222, 69.1598)								
RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest.x, zeppelinDest.y, zeppelinDest.z)								
RunToLocation(zeppelin, zeppelinMoveSpeed, zeppelinDest2.x, zeppelinDest2.y, zeppelinDest2.z)								
RunToLocation(zeppelinTarget04, 500, 3822.34, -663.603, 17.7212)								
"saurok_hack: Despawn()"""	0	0						
"saurok_hack2: Despawn()"""	0	0						
saurok_hack2: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )								
"saurok_hack3: Despawn()"""	0	0						
saurok_hack3: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )								
"saurok_hack4: Despawn()"""	0	0						
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Dead )								
saurok_hack4: PlayLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Ready1H )								
saurok_hack4: PlayLoopingFullBodyAnim( Animations.SitGround )								
saurok_hack4: PlayLoopingFullBodyAnim( Animations.Strangulate ) --Start to get strangled								
saurok_hack4: PlayOneShotFullBodyAnim( Animations.Death )								
saurok_hack4: PlayOneShotFullBodyAnim( Animations.MountSelfStart )								
saurok_hack4: PlayOneShotFullBodyAnim( Animations.SitGroundUp )								
saurok_hack4: StopLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack4: StopLoopingFullBodyAnim( Animations.SitGround )								
"saurok_hack5: Despawn()"""	0	0						
saurok_hack5: PlayLoopingFullBodyAnim( Animations.Dead ) --Start to get strangled								
saurok_hack5: PlayLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack5: PlayLoopingFullBodyAnim( Animations.SitGround )								
saurok_hack5: PlayOneShotFullBodyAnim( Animations.Death ) --Start to get strangled								
saurok_hack5: PlayOneShotFullBodyAnim( Animations.MountSelfStart )								
saurok_hack5: PlayOneShotFullBodyAnim( Animations.SitGroundUp )								
saurok_hack5: StopLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack5: StopLoopingFullBodyAnim( Animations.SitGround )								
"saurok_hack6: Despawn()"""	0	0						
saurok_hack6: PlayLoopingFullBodyAnim( Animations.Dead )								
saurok_hack6: PlayLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack6: PlayLoopingFullBodyAnim( Animations.SitGround )								
saurok_hack6: PlayOneShotFullBodyAnim( Animations.Death )								
saurok_hack6: PlayOneShotFullBodyAnim( Animations.MountSelfStart )								
saurok_hack6: PlayOneShotFullBodyAnim( Animations.SitGroundUp )								
saurok_hack6: StopLoopingFullBodyAnim( Animations.MountSelfRun )								
saurok_hack6: StopLoopingFullBodyAnim( Animations.SitGround )								
"saurok_heal: Despawn()"""	0	0						
"saurok_heal2: Despawn()"""	0	0						
saurok_heal2: PlayLoopingFullBodyAnim( Animations.ReadySpellOmni )								
"saurok_heal3: Despawn()"""	0	0						
saurok_heal3: PlayLoopingFullBodyAnim( Animations.ReadySpellOmni )								
"saurok_tank: Despawn()"""	0	0						
saurok_tank: PlayOneShotFullBodyAnim( Animations.BattleRoar )								
"saurok_tank2: Despawn()"""	0	0						
saurok_tank2: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )								
"saurok_tank3: Despawn()"""	0	0						
saurok_tank3: PlayLoopingFullBodyAnim( Animations.AttackUnarmed )								
"scene:SetCamera(0, 0, nil, nil)"""	0	0						
"scene:SetCamera(0, 1, nil, nil)"""	0	0						
scene:SetCamera(0, 2.5, nil, nil)								
scene:SetCamera(0,3,nil,nil) -- sets camera back to game-cam								
scene:SetCamera(302, 0.0, nil, nil)								
--scene:SetCamera(307, 1.0, nil, nil)								
scene:SetCamera(337,2.5,nil,nil) -- backing up								
scene:SetCamera(344,3.5,nil,nil) -- zoom								
scene:SetCamera(345,4,nil,nil)								
scene:SetCamera(346,3,nil,nil)								
scene:SetCamera(347,4,nil,nil)								
scene:SetCamera(367, 15, nil, nil)								
scene:SetCamera(373, 1, nil, nil)								
scene:SetCamera(374, 0, nil, nil) -- rivett intial shot								
scene:SetCamera(375, 0.25, nil, nil) -- rivett close shot								
scene:SetCamera(379, 35, nil, nil)								
scene:SetCamera(380, 0, nil, nil) -- ship to zepp								
scene:SetCamera(382, 20, nil, nil) -- panning nazgrim								
scene:SetCamera(384, 0, nil, nil)								
scene:SetCamera(386, 1, nil, nil)								
scene:SetCamera(402, 0, nil, nil)								
scene:SetCamera(416, 0, actor, actor2)								
--scene:SetGameCameraTarget(nazgrim, 5, 30)								
scene:SetRelativeCoords(false)								
scene:WaitTimer(0.25)								
scene:WaitTimer(0.25)								
scene:WaitTimer(0.5)								
scene:WaitTimer(1)								
scene:WaitTimer(1)								
scene:WaitTimer(10)								
scene:WaitTimer(10)								
scene:WaitTimer(2)								
scene:WaitTimer(2)								
scene:WaitTimer(2)								
scene:WaitTimer(3)								
scene:WaitTimer(4)								
scene:WaitTimer(5)								
scene:WaitTimer(9.5)								
"SendTrigger( \""allianceShip\"" )"								
"SendTrigger( \""attackTian\"" ) --Let Tian know i\'m here"								
"SendTrigger( \""blackLight_CC\"" )"								
"SendTrigger( \""blackLight_CR\"" )"								
"SendTrigger( \""blackLight_UC\"" )"								
"SendTrigger( \""blackLight_UC\"")"								
"SendTrigger( \""crashMove\"" )"								
"SendTrigger( \""cueLight_CC\"" )"								
"SendTrigger( \""cueLight_CR\"" )"								
"SendTrigger( \""cueLight_UC\"" ) -- Cue upstage center light"								
"SendTrigger( \""cueLight_UC\"")"								
"SendTrigger( \""cueMogu\"" ) -- Cue Mogu"								
"SendTrigger( \""eggBreak\"" )"								
"SendTrigger( \""eggBreak2\"" )"								
"SendTrigger( \""endScene\"" )"								
"SendTrigger( \""endScene\"" )"								
"SendTrigger( \""endScene3\"" )"								
"SendTrigger( \""endScene3\"" ) -- clear scene 3"								
"SendTrigger( \""endScene4\"" )"								
"SendTrigger( \""endScene4\"" ) -- kill scene 4"								
"SendTrigger( \""endScene5\"" )"								
"SendTrigger( \""endScene5\"" ) -- kill scene 5"								
"SendTrigger( \""endScene6\"" )"								
"SendTrigger( \""endScene6\"" ) -- kill scene 6"								
"SendTrigger( \""grummleTransform2\"" )"								
"SendTrigger( \""hack\"" ) -- Cue saurok hack"								
"SendTrigger( \""heal\"" ) -- Cue saurok hack"								
"SendTrigger( \""kill_2\"" )"								
"SendTrigger( \""kill_saurok_hack6\"" )"								
"SendTrigger( \""killMogu\"" ) -- kill Mogu"								
"SendTrigger( \""killSaurok\"" ) --Clear Scene 2"								
"SendTrigger( \""moguAppear\"" )"								
"SendTrigger( \""moguDisappear\"" )"								
"SendTrigger( \""nazgrimTalk\"" )"								
"SendTrigger( \""priestTrigger\"" )"								
"SendTrigger( \""rivettTalk\"" )"								
"SendTrigger( \""scene3\"" ) -- Cue scene 3"								
"SendTrigger( \""scene3Trigger\"" )"								
"SendTrigger( \""scene4\"" ) -- Cue scene 4"								
"SendTrigger( \""scene4Trigger\"" )"								
"SendTrigger( \""scene5\"" ) -- Cue scene 5"								
"SendTrigger( \""scene5Trigger\"" )"								
"SendTrigger( \""scene6\"" ) -- cue scene 6"								
"SendTrigger( \""scene6Trigger\"" )"								
"SendTrigger( \""shipMove\"" )"								
"SendTrigger( \""shipSpotted\"" )"								
"SendTrigger( \""smokingGrummle\"" )"								
"SendTrigger( \""Spawn Mogu\"" ) -- Bring in the mogu"								
"SendTrigger( \""Spawn Troggs\"" ) -- Bring in the troggs"								
"SendTrigger( \""startRunning\"" )"								
"SendTrigger( \""tank\"" ) -- Cue saurok hack"								
"SendTrigger( \""throttle\"" )"								
"SendTrigger( \""throttle2\"" )"								
"SendTrigger( \""troggSpawn\"" )"								
"SendTrigger( \""zeppelinCrash\"" )"""	0	0						
"SendTrigger( \""zeppelinMove\"" )"								
"SendTrigger(\""addGrummle1\"")"								
"SendTrigger(\""addGrummle2\"")"								
"SendTrigger(\""blackLight_CL\"")"								
"SendTrigger(\""BreakWall\"")"								
"--SendTrigger(\""callPandas\"")"								
"SendTrigger(\""callSmack\"")"								
"SendTrigger(\""ChenEnters\"")"								
"--SendTrigger(\""clearPandas\"") -- Fade out pandas mid pathing"								
"SendTrigger(\""clearTree\"")"								
"SendTrigger(\""cueLight_CL\"")"								
"SendTrigger(\""DeployFarmers\"")"								
"SendTrigger(\""DeployLeven\"")"								
"SendTrigger(\""DeployShadoPan\"")"								
"--SendTrigger(\""endScene\"")"								
"SendTrigger(\""FarmersAssemble\"")"								
"SendTrigger(\""grummleTransform\"")"								
"SendTrigger(\""KidsShot\"")"								
"SendTrigger(\""KungFuEnters\"")"								
"SendTrigger(\""LoonShot3\"")"								
"SendTrigger(\""LoonShot4\"")"								
"SendTrigger(\""LoonShot5\"")"								
"--SendTrigger(\""scene2Trigger\"")"								
"--SendTrigger(\""scene3Trigger\"")"								
"--SendTrigger(\""scene4Trigger\"")"								
"SendTrigger(\""Scene5a\"")"								
"SendTrigger(\""treeSmack\"")"								
"SendTrigger(\""TriggerLeven01\"")"								
"SendTrigger(\""TriggerParade\"")"								
sentinelA = SpawnFadedActorAtPoint( 63399, 3402, false )								
sentinelA:FollowPathAtSpeed(3533, paradeSpeed)								
sentinelA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
sentinelA:WaitMovementComplete()								
sentinelB = SpawnFadedActorAtPoint( 63399, 3403, false )								
sentinelB:FollowPathAtSpeed(3534, paradeSpeed)								
sentinelB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
sentinelB:WaitMovementComplete()								
sentinelC = SpawnFadedActorAtPoint( 63399, 3404, false )								
sentinelC:FollowPathAtSpeed(3535, paradeSpeed)								
sentinelC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
sentinelC:WaitMovementComplete()								
sentinelD = SpawnFadedActorAtPoint( 63399, 3408, false )								
sentinelD:FollowPathAtSpeed(3536, paradeSpeed)								
sentinelD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
sentinelD:WaitMovementComplete()								
SetCameraFollowPath( 372, 0, nil, 3097, 20 )								
SetCameraFollowPath( 383, 0.0, 3114, 3113, 14 )								
SetCameraFollowPath( 385, 4.0, 3116, 3117, 16 )								
SetCameraFollowPath( 399, 6, 3165, 3166, 45 )								
SetCameraFollowPath( genericFOV90, 0, 3423, 3422, 10)								
SetCameraFollowPath( genericFOV90, 0, 3424, 3422, 10)								
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)								
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)								
SetCameraFollowPath( genericFOV90, 0, 3428, 3429, 10)								
SetCameraFollowPath( genericFOV90, 0, 3430, 3431, 10)								
SetCameraFollowPath( genericFOV90, 0, 3443, 3429, 25)								
SetCameraFollowPath( genericFOV90, 0, 3451, 3452, 9)								
SetCameraFollowPath( genericFOV90, 0, 3461, 3462, 9)								
SetCameraFollowPath( genericFOV90, 0, 3552, 3553, 9)								
SetCameraFollowPath( genericFOV90, 0, 3554, 3555, 32)								
"shadopan01: Despawn()"""	0	0						
shadopan01:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
shakeX = scene:AddCameraShake( 211, shakeOrigin )								
shakeX = scene:AddCameraShake( 214, shakeOrigin01 )								
shakeY = scene:AddCameraShake( 212, shakeOrigin )								
shakeY = scene:AddCameraShake( 215, shakeOrigin01 )								
shakeZ = scene:AddCameraShake( 213, shakeOrigin )								
shakeZ = scene:AddCameraShake( 216, shakeOrigin01 )								
shokia = SpawnActor( shokiaCreatureID, 1848.93, -4419, 135.233, 192.74, 1.0, false )								
shokia = SpawnActor( shokiaCreatureID, 3449.31, -278.87, 266.9, 209.976, 1.0, false )								
shokia:Despawn()								
shokia:PlayLoopingFullBodyAnim(Animations.KneelLoop)								
shokia:PlayLoopingFullBodyAnim(Animations.Stand)								
shokia:PlayOneShotFullBodyAnim(Animations.EmoteCheer)								
shokia:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
shokia:StopLoopingFullBodyAnim()								
snuff = SpawnActor( snuffCreatureID, 1839.86, -4415.26, 135.233, 332.626, 1.0, false )								
snuff = SpawnActor( snuffCreatureID, 3459.5, -283.872, 268.1, 108, 0.7, false )								
snuff:Despawn()								
snuff:PlayLoopingFullBodyAnim(Animations.SitGround)								
snuff:PlayLoopingFullBodyAnim(Animations.Sleep)								
snuff:PlayLoopingFullBodyAnim(Animations.Sleep)								
snuff:PlayOneShotAnimKit(2330)								
snuff:PlayOneShotFullBodyAnim(Animations.EmoteDance)								
snuff:PlayOneShotFullBodyAnim(Animations.EmoteRoar)								
snuff:SetFacingToAbs(Vector:New(3508.48, -631.563, 122.261))								
snuff:StopLoopingFullBodyAnim()								
snuff:StopLoopingFullBodyAnim()								
soundHandle:Stop()								
speed = 6.0								
STATE_LOOKUP = {								
--stinkyPandaren1:ClearSpellStateVisual(13960, actorSmokeVisual) --Clear Actor Visual								
--stinkyPandaren1:ClearSpellStateVisual(24803, actorAuraVisual) --Clear Actor Visual								
StopLoopingSplitBodyAnim( moguPoleArm1, Animations.Attack2H )								
StopLoopingSplitBodyAnim( panda01 )								
StopLoopingSplitBodyAnim( panda01 )								
StopLoopingSplitBodyAnim( panda02 )								
StopLoopingSplitBodyAnim( panda02 )								
StopLoopingSplitBodyAnim( panda03 )								
StopLoopingSplitBodyAnim( panda03 )								
StopLoopingSplitBodyAnim( panda05 )								
StopLoopingSplitBodyAnim( panda05 )								
StopLoopingSplitBodyAnim( panda06 )								
"terrorcotta1: Despawn()"""	0	0						
terrorcotta1: PlayOneShotFullBodyAnim( Animations.Attack2H )								
terrorcotta1: PlayOneShotFullBodyAnim( Animations.Attack2H )								
"terrorcotta2: Despawn()"""	0	0						
terrorcotta2: PlayLoopingAnimKit( 1551 )								
tian: Despawn()								
"tian: Despawn()"""	0	0						
tian: SetFacing(29.9705)								
tian: SetFacing(326.124)								
tian: StopLoopingSplitBodyAnim( Animations.EmoteTalkExclamation )								
Triggers = { }								
Triggers = { }								
"trogg01: Despawn()"""	0	0						
"trogg02: Despawn()"""	0	0						
"trogg03: Despawn()"""	0	0						
"troggMain: Despawn()"""	0	0						
trollGrunt01:FollowPath( 3049, 12 )								
trollGrunt02:FollowPath( 3050, 12 )								
trollGrunt03:FollowPath( 3051, 12 )								
trollGrunt04:FollowPath( 3052, 12 )								
trollGrunt05:FollowPath( 3058, 12 )								
trollGrunt06:FollowPath( 3059, 12 )								
trollGrunt07:FollowPath( 3060, 12 )								
trollGrunt08:FollowPath( 3061, 12 )								
trollGrunt09:FollowPath( 3062, 12 )								
useFreelookCamera = true								
useFreelookCamera = true								
v1 = Vector:New(1, 2, 3)								
v2 = Vector:New(2, 4, 6)								
v3 = -v1								
v3 = v1 - v2								
v3 = v1*4								
v3 = Vector.Add(v1, v2)								
vanguard01 = SpawnActor( vanguard01CreatureID, 1851.74, -4417.59, 135.232, 144.925, 1.0, false )								
vanguard01 = SpawnActor( vanguard01CreatureID, 3432.55, -287.139, 268.19, 133.576, 1.0, false )								
vanguard01:Despawn()								
vanguard01:PlayOneShotFullBodyAnim(Animations.EmoteApplaud)								
vanguard01:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
vanguard01:StopLoopingFullBodyAnim()								
vanguard02 = SpawnActor( vanguard02CreatureID, 1851.41, -4411.51, 135.065, 225.698, 1.0, false )								
vanguard02 = SpawnActor( vanguard02CreatureID, 3435.51, -293.801, 268.19, 273, 1.0, false )								
vanguard02:Despawn()								
vanguard02:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
vanguard02:StopLoopingFullBodyAnim()								
vanguard03 = SpawnActor( vanguard03CreatureID, 1847.81, -4408.08, 135.067, 225.665, 1.0, false )								
vanguard03 = SpawnActor( vanguard03CreatureID, 3452.83, -289.126, 266.9, 186, 1.0, false )								
vanguard03:Despawn()								
vanguard03:SetFacingToAbs(Vector:New(3671.88, -532.339, 88.999))								
vanguard03:StopLoopingFullBodyAnim()								
Vector.__meta.__add = Vector.Add								
Vector.__meta.__concat = Vector.Concat								
Vector.__meta.__div = Vector.Div								
Vector.__meta.__len = Vector.Magnitude								
Vector.__meta.__mul = Vector.Mul								
Vector.__meta.__sub = Vector.Sub								
Vector.__meta.__tostring = Vector.ToString								
Vector.__meta.__unm = Vector.Neg								
Vector.Add = function(a, b)								
Vector.Concat = function(a, b)								
Vector.CrossProduct = function ( a, b ) 								
Vector.Dist = function ( a, b ) 								
Vector.Div = function(a, b)								
Vector.Magnitude = function(v)								
Vector.Mul = function(a, b)								
Vector.Neg = function(a)								
Vector.Normalize = function(v)								
Vector.Sub = function(a, b)								
Vector.UnitVectorFromAtoB = function ( a, b ) 								
Wait (1)								
Wait (1)								
Wait (1)								
Wait (12)								
Wait (15)								
Wait (2)								
Wait (2)								
Wait (2)								
Wait (2)								
Wait (3)								
Wait (3)								
Wait (3)								
Wait (3)								
Wait (5)								
--Wait (5)								
"Wait (50)"""	0	0						
Wait (7)								
--Wait (8)								
Wait (9)								
--Wait for Scene 6								
--Wait for Scene 6								
--Wait for Scene 6								
--Wait for Scene 6								
Wait( 0.1 )								
Wait( 0.25 )								
Wait( 0.3 ) 								
Wait( 0.3 ) 								
Wait( 0.3 ) 								
Wait( 0.5 )								
Wait( 0.5 )								
Wait( 0.5 )								
Wait( 0.5 )								
Wait( 0.5 ) 								
Wait( 0.6 )								
Wait( 0.6 ) 								
Wait( 0.7 )								
Wait( 0.8 ) 								
Wait( 1 )								
Wait( 1 )								
Wait( 1 )								
Wait( 1 )								
Wait( 1 )								
Wait( 1.26 )								
Wait( 1.5 )								
Wait( 10 )								
Wait( 10.2 )								
Wait( 11 )								
Wait( 12 )								
Wait( 13.5 )								
Wait( 15 )								
Wait( 15 )								
Wait( 15 )								
Wait( 15 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2 )								
Wait( 2.5 )								
Wait( 2.5 )								
Wait( 2.5 )								
Wait( 2.5 ) 								
Wait( 20 )								
Wait( 25 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3 )								
Wait( 3.27 )								
Wait( 3.9 )								
Wait( 4 )								
Wait( 4 )								
Wait( 4 )								
Wait( 4 )								
Wait( 4 )								
Wait( 4 )								
Wait( 4.1 )								
Wait( 4.2 )								
Wait( 4.3 )								
Wait( 5 )								
Wait( 5 )								
Wait( 5 )								
Wait( 5 )								
Wait( 5 )								
Wait( 5 )								
Wait( 5.7 )								
Wait( 5.8 )								
Wait( 6 )								
Wait( 6 )								
Wait( 6 )								
Wait( 6.2 )								
Wait( 6.5 )								
Wait( 7 )								
Wait( 7.1 )								
Wait( 7.1 )								
Wait( 8 )								
Wait( 8.1 )								
Wait(0.1)								
Wait(0.1)								
Wait(0.15)								
Wait(0.2)								
Wait(0.2)								
Wait(0.2)								
Wait(0.2)								
Wait(0.2)								
Wait(0.25)								
Wait(0.3)								
Wait(0.3)								
Wait(0.3)								
Wait(0.3)								
Wait(0.4)								
Wait(0.5)								
Wait(0.5)								
Wait(0.5)								
Wait(0.5)								
Wait(0.5)								
Wait(0.5)								
Wait(0.6)								
Wait(0.6)								
Wait(0.7)								
Wait(0.7)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1)								
Wait(1.5)								
Wait(1.5)								
Wait(1.5)								
Wait(1.5)								
Wait(1.9)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
Wait(10)								
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
"Wait(100)"""	0	0						
Wait(12)								
Wait(12)								
Wait(13)								
Wait(16)								
Wait(19)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2)								
Wait(2.5)								
Wait(2.5)								
Wait(2.5)								
Wait(2.5)								
Wait(2.5)								
Wait(2.5)								
Wait(2.5)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(3)								
Wait(35)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(4)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5)								
Wait(5.5)								
Wait(6)								
Wait(6)								
Wait(6)								
Wait(7)								
Wait(7)								
Wait(8)								
Wait(8)								
Wait(8)								
Wait(9)								
Wait(9)								
Wait(9)								
Wait(9)								
"WaitForTrigger (\""endScene5\"")"								
"WaitForTrigger (\""Scene5a\"")"								
"WaitForTrigger( \""attackTian\"" )"								
"WaitForTrigger( \""blackLight_CC\"" )"								
"WaitForTrigger( \""blackLight_CL\"" )"								
"WaitForTrigger( \""blackLight_CR\"" )"								
"WaitForTrigger( \""blackLight_UC\"" )"								
"WaitForTrigger( \""blackLight_UL\"" )"								
"WaitForTrigger( \""blackLight_UR\"" )"								
"WaitForTrigger( \""crashMove\"" )"								
"WaitForTrigger( \""crashMove\"" )"								
"WaitForTrigger( \""crashMove\"" )"								
"WaitForTrigger( \""cueMogu\"" )"								
"WaitForTrigger( \""eggBreak\"" )"								
"WaitForTrigger( \""eggBreak\"" )"								
"WaitForTrigger( \""eggBreak\"" )"								
"WaitForTrigger( \""eggBreak\"" )"								
"WaitForTrigger( \""eggBreak2\"" )"								
"WaitForTrigger( \""endMogu\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" )"								
"--WaitForTrigger( \""endScene\"" )"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene\"" ) -- On clean up, despawn bunnies"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene3\"" )"								
"WaitForTrigger( \""endScene4\"" )"								
"WaitForTrigger( \""endScene4\"" )"								
"WaitForTrigger( \""endScene4\"" )"								
"WaitForTrigger( \""endScene4\"" )"								
"WaitForTrigger( \""endScene4\"" )"								
"WaitForTrigger( \""endScene5\"" )"								
"WaitForTrigger( \""endScene5\"" )"								
"WaitForTrigger( \""endScene5\"" )"								
"WaitForTrigger( \""endScene5\"" )"								
"WaitForTrigger( \""endScene5\"" )"								
"WaitForTrigger( \""endScene6\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""grummleTransform\"" )"								
"WaitForTrigger( \""kill_2\"" )"								
"WaitForTrigger( \""kill_saurok_hack6\"" )"								
"WaitForTrigger( \""kill_saurok_hack6\"" )"								
"WaitForTrigger( \""killMogu\"" )"								
"WaitForTrigger( \""killMogu\"" )"								
"WaitForTrigger( \""killMogu\"" )"								
"WaitForTrigger( \""killMogu\"" )"								
"WaitForTrigger( \""killSaurok\"" )"								
"WaitForTrigger( \""killSaurok\"" )"								
"WaitForTrigger( \""killSaurok\"" )"								
"WaitForTrigger( \""moguDisappear\"" )"								
"WaitForTrigger( \""moguDisappear\"" )"								
"WaitForTrigger( \""rivettTalk\"" )"								
"WaitForTrigger( \""rivettTalk\"" )"								
"WaitForTrigger( \""rivettTalk\"" )"								
"WaitForTrigger( \""scene4\"" )"								
"WaitForTrigger( \""scene4\"" )"								
"WaitForTrigger( \""scene5\"" )"								
"WaitForTrigger( \""scene6\"" )"								
"WaitForTrigger( \""scene6\"" )"								
"WaitForTrigger( \""scene6\"" )"								
"WaitForTrigger( \""scene6\"" )"								
"WaitForTrigger( \""scene6\"" )"								
"WaitForTrigger( \""shipSpotted\"" )"								
"WaitForTrigger( \""shipSpotted\"" )"								
"WaitForTrigger( \""shipSpotted\"" )"								
"WaitForTrigger( \""shipSpotted\"" )"								
"WaitForTrigger( \""Spawn Mogu\"" )"								
"WaitForTrigger( \""throttle\"" )"								
"WaitForTrigger( \""throttle\"" )"								
"WaitForTrigger( \""throttle2\"" )"								
"WaitForTrigger( \""treeSmack\"" )"								
"WaitForTrigger( \""troggSpawn\"" )"								
"WaitForTrigger( \""zeppelinCrash\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinLeave\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger( \""zeppelinMove\"" )"								
"WaitForTrigger(\""ChenEnters\"")"								
"WaitForTrigger(\""ChenEnters\"")"								
"WaitForTrigger(\""clearTree\"")"								
"WaitForTrigger(\""DeployFarmers\"")"								
"WaitForTrigger(\""DeployLeven\"")"								
"WaitForTrigger(\""DeployShadoPan\"")"								
"WaitForTrigger(\""eggBreak\"") --Wait for egg break to play out"								
"WaitForTrigger(\""endScene4\"")"								
"WaitForTrigger(\""endScene4\"")"								
"WaitForTrigger(\""endScene4\"")"								
"--WaitForTrigger(\""endScene4\"")"								
"WaitForTrigger(\""endScene6\"")"								
"WaitForTrigger(\""endScene6\"")"								
"WaitForTrigger(\""endScene6\"")"								
"WaitForTrigger(\""KungFuEnters\"")"								
"WaitForTrigger(\""LoonShot3\"")"								
"WaitForTrigger(\""LoonShot4\"")"								
"WaitForTrigger(\""LoonShot5\"")"								
"WaitForTrigger(\""scene5Trigger\"")"								
"WaitForTrigger(\""scene5Trigger\"")"								
"WaitForTrigger(\""scene5Trigger\"")"								
"WaitForTrigger(\""scene5Trigger\"")"								
"WaitForTrigger(\""startRunning\"")"								
"WaitForTrigger(\""startRunning\"")"								
"--WaitForTrigger(\""startRunning\"")"								
"WaitForTrigger(\""treeSmack\"")"								
"WaitForTrigger(\""treeSmack\"")"								
"WaitForTrigger(\""treeSmack\"")"								
"WaitForTrigger(\""treeSmack\"")"								
"WaitForTrigger(\""treeSmack\"")"								
"WaitForTrigger(\""TriggerParade\"")"								
wall = walls[1]								
"wall:PlayOneShotAnimKit(2474)"""	0	0						
wardenA = SpawnFadedActorAtPoint( 63400, 3405, false )								
wardenA:FollowPathAtSpeed(3516, paradeSpeed)								
wardenA:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenA:WaitMovementComplete()								
wardenB = SpawnFadedActorAtPoint( 63400, 3406, false )								
wardenB:FollowPathAtSpeed(3517, paradeSpeed)								
wardenB:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenB:WaitMovementComplete()								
wardenC = SpawnFadedActorAtPoint( 63400, 3409, false )								
wardenC:FollowPathAtSpeed(3518, paradeSpeed)								
wardenC:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenC:WaitMovementComplete()								
wardenD = SpawnFadedActorAtPoint( 63400, 3410, false )								
wardenD:FollowPathAtSpeed(3519, paradeSpeed)								
wardenD:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenD:WaitMovementComplete()								
wardenE = SpawnFadedActorAtPoint( 63400, 3411, false )								
wardenE:FollowPathAtSpeed(3520, paradeSpeed)								
wardenE:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenE:WaitMovementComplete()								
wardenF = SpawnFadedActorAtPoint( 63400, 3412, false )								
wardenF:FollowPathAtSpeed(3521, paradeSpeed)								
wardenF:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
wardenF:WaitMovementComplete()								
while 1 do								
while true do								
while true do								
while true do 								
whiteyak: ClearSpellStateVisual(23826, actorAuraVisual) --Clear Incense Visual								
"whiteyak: Despawn()"""	0	0						
workDust01 = SpawnModelActor( workDustModel, 2147.85, 1436.33, 487.886, 126.691, 1.5 ) -- Smal Tent								
workDust01 = SpawnModelActor( workDustModel, 2298.7, 950.208, 481.153, 126.691 )								
workDust02 = SpawnModelActor( workDustModel, 2139.15, 1499.97, 487.886, 2.49143, 1.5 ) -- Small Tents								
workDust02 = SpawnModelActor( workDustModel, 2305.26, 935.646, 481.217, 2.49143 )								
workDust03 = SpawnModelActor( workDustModel, 2158.62, 1472.41, 487.886, 217.141, 2 ) -- Large Tent LEFT								
workDust03 = SpawnModelActor( workDustModel, 2267.43, 910.647, 481.253, 199.366, 2 )								
workDust04 = SpawnModelActor( workDustModel, 2153.06, 1501.22, 487.886, 61.441, 1.5 ) -- Small Tents								
workDust04 = SpawnModelActor( workDustModel, 2279.81, 904.865, 482.649, 61.441 )								
workDust05 = SpawnModelActor( workDustModel, 2146.45, 1502.85, 487.886, 37.365, 1.5 ) -- Small Tents								
workDust05 = SpawnModelActor( workDustModel, 2304.87, 952.176, 481.153, 37.365 )								
workDust06 = SpawnModelActor( workDustModel, 2165.57, 1466.66, 487.886, 217.366, 3 ) -- Large Tent RIGHT								
workDust06 = SpawnModelActor( workDustModel, 2276.11, 901.96, 492.636, 237.166, 3 )								
xiao = SpawnFadedActorAtPoint( 63387, 3379, false)								
xiao:FollowPathAtSpeed(3547, 6)								
xiao:PlayOneShotSplitBodyAnim(Animations.AttackUnarmed)								
xiao:WaitMovementComplete()								
"yaungol1: Despawn()"""	0	0						
yaungol1: PlayLoopingFullBodyAnim( Animations.Attack2H )								
yaungol2: Despawn()								
yaungol2: PlayLoopingFullBodyAnim( Animations.Attack2H )								
yimo = SpawnFadedActorAtPoint( 63396, 3387, false )								
yimo:FollowPathAtSpeed(3515, paradeSpeed)								
yimo:PlayLoopingSplitBodyAnim(Animations.ReadyUnarmed)								
yimo:WaitMovementComplete()								
--zeppelin = SpawnModelActor( zeppelinModel, 3444.23, -278.363, 284.752, 249.2335, 1.0, false )								
--zeppelin = SpawnModelActor( zeppelinModel, 3444.23, -278.363, 284.752, 249.2335, 1.0, false )								
zeppelin = zeppelins[1]								
zeppelin = zeppelins[1]								
"zeppelin:Despawn()"""	0	0						
zeppelin:FollowPath( 3118, 10 )								
zeppelinCannon01 = SpawnActor( zeppelinCannonBunnyCreatureID, 3454.88, -291.905, 263.772, 307.796, 1.0, false )								
zeppelinCannon02 = SpawnActor( zeppelinCannonBunnyCreatureID, 3448.31, -294.369, 263.772, 296.321, 1.0, false )								
zeppelinCannon03 = SpawnActor( zeppelinCannonBunnyCreatureID, 3442.37, -295.521, 263.957, 279.446, 1.0, false )								
zeppelinCannon04 = SpawnActor( zeppelinCannonBunnyCreatureID, 3437.49, -295.544, 264.3, 280.5711, 1.0, false )								
zeppelinFire = SpawnActor( zeppelinFireCreatureID, 3310.88, -336.348, 279, 143, 5, false )								
zeppelinFire:Despawn()								
zeppelinFire:FollowPath( 3120, 10 )								
zeppelinFire01 = SpawnActor( zeppelinFireCreatureID, 3302.44, -334.681, 278.071, 325.581, 1, false )								
zeppelinFire01:Despawn()								
zeppelinFire02 = SpawnActor( zeppelinFireCreatureID, 3308.47, -332.332, 273.305, 313.882, 1, false )								
zeppelinFire02:Despawn()								
zeppelinFire03 = SpawnActor( zeppelinFireCreatureID, 3292.96, -344.628, 282.832, 27.9496, 1, false )								
zeppelinFire03:Despawn()								
zeppelinFire03:FollowPath( 3245, 10 )								
zeppelinMoveSpeed = 4								
zinjun = SpawnActor( zinjunCreatureID, 1840.35, -4412.36, 135.233, 334.341, 1.0, false )								
zinjun = SpawnActor( zinjunCreatureID, 3461.3, -283.872, 268.4, 199.819, 1.0, false )								
zinjun:Despawn()								
zinjun:PlayLoopingFullBodyAnim(Animations.Cower)								
zinjun:PlayLoopingFullBodyAnim(Animations.SitChairMed)								
zinjun:PlayLoopingFullBodyAnim(Animations.Stand)								
zinjun:PlayOneShotAnimKit(2331)								
zinjun:PlayOneShotFullBodyAnim(Animations.EmotePoint)								
zinjun:PlayOneShotFullBodyAnim(Animations.Stand)								
zinjun:StopLoopingFullBodyAnim()								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
#NAAM?								
		#NAAM?						
		local baseFuncName = string.sub(key,5)						
		local baseFunc = Scene[baseFuncName]						
		if baseFunc then						
			-- the function exists, generate a wrapper					
			local waitWrapperFunc = function(self, ...)					
				return self:Wait(baseFunc(self, ...))				
			end					
			Scene[key] = waitWrapperFunc					
		end						
	end							
								
	return Scene[key]							
								
	"local elapsed = 0;"							
	if not freq or freq == 0 then							
		#NAAM?						
		local timer = self:Timer(0)						
		while conditionFunc() ~= true or (maxTime and maxTime < elapsed) do						
			"elapsed = elapsed + .01;"					
			timer:Reset()					
			self:Wait(timer)					
		end						
	else							
		#NAAM?						
		while conditionFunc() ~= true or (maxTime and maxTime < elapsed) do						
			"elapsed = elapsed + freq;"					
			self:WaitTimer(freq)					
		end						
	end							
								
	local waitCondition = function()							
		local event = self:PeekEvent()						
		if event then						
			return true					
		else						
			return false					
		end						
	end							
								
	self:WaitCondition(waitCondition, freq)							
	local event = self:PeekEvent()							
	assert(event ~= nil)							
	if (keepEvent ~= true) then							
		self:PopEvent()						
	end							
	return event							
								
	local actorList = self:CreateActorsAndWaitForLoad({createData}, fadeTime)							
	return actorList[1]							
								
	local actorList = {}							
	for index, createData in pairs(createDataList) do							
		local actor = self:SpawnActor(createData)						
		actorList[index] = actor						
	end							
								
	self:WaitForActorsToLoad(actorList, fadeInTime)							
	return actorList							
								
	if not fadeInTime then							
		fadeInTime = 0.5						
	end							
								
	for index, actor in pairs(actorList) do							
		actor:SetInteractible(false)						
		actor:SetHidden(true)						
		actor:Fade(0, 0)						
	end							
								
	local waitCondition = function()							
		#NAAM?						
		for index, actor in pairs(actorList) do						
			if not actor:IsReadyToDisplay() then					
				return false				
			end					
		end						
		return true						
	end							
	self:WaitCondition(waitCondition)							
								
	#NAAM?							
	for index, actor in pairs(actorList) do							
		actor:SetHidden(false)						
		actor:Fade(1, fadeInTime)						
	end							
								
	#NAAM?							
	if fadeInTime > 0 then							
		self:WaitTimer(fadeInTime)						
	end							
								
	#NAAM?							
	for index, actor in pairs(actorList) do							
		actor:SetInteractible(true)						
	end							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	scene:WaitTimer(5)							
	reasonIndex = reasonIndex + 1							
	if (reasonIndex > MissReasons.Reflected) then							
		reasonIndex = 1						
	end							
								
	--nazgrim:AddWorldText(nil, MissReasons.Physical, false, false)							
	nazgrim:AddWorldText(nil, reasonIndex, false, false)							
								
								
								
								
								
								
								
								
								
		scale = 1.0,						
		"name = \""\"","						
		transform = Transform:New(),						
		hoverHeight = 0.0,						
		groundSnap = true,						
		interactible = true,						
		floatingTooltip = true,						
	}							
	setmetatable(c, self.__meta)							
	return c							
								
	local c = ActorCreateData:Default()							
								
	c.creatureID = _id or c.creatureID							
	c.scale = _scale or c.scale							
	c.transform = _trans							
								
	return c							
								
	local c = ActorCreateData:Default()							
								
	c.creatureID = _creatureID or c.creatureID							
	c.creatureDisplayID = _displayID or c.creatureDisplayID							
	c.scale = _scale or c.scale							
	c.transform = _trans							
								
	return c							
								
	local c = ActorCreateData:Default()							
								
	c.model = _modelFile							
	c.scale = _scale or c.scale							
	c.name = _name							
	c.transform = _trans							
								
	return c							
								
	local stringA = a							
	"if type(stringA) ~= \""string\"" then"							
		stringA = a:ToString()						
	end							
								
	local stringB = b							
	"if type(stringB) ~= \""string\"" then"							
		stringB = b:ToString()						
	end							
								
	return (stringA .. stringB)							
								
	return Vector:New(a.x + b.x, a.y + b.y, a.z + b.z)							
								
	return Vector:New(a.x - b.x, a.y - b.y, a.z - b.z)							
								
	"if type(a) == \""number\"" then"							
		return Vector:New(a * b.x, a * b.y, a * b.z)						
	else							
		return Vector:New(a.x * b, a.y * b, a.z * b)						
	end							
								
	"if type(b) == \""number\"" then"							
		return Vector.Mul(a, 1.0 / b)						
	end							
								
	return Vector:New(-a.x, -a.y, -a.z)							
								
	return math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z)							
								
	"local magnitude = v:Magnitude();"							
								
			v.x/magnitude, 					
			v.y/magnitude, 					
			"v.z/magnitude);"					
								
	"local normalA, normalB = a:Normalize(), b:Normalize();"							
								
	return Vector:New( 							
		((normalA.y * normalB.z) - (normalA.z * normalB.y)),						
		((normalA.z * normalB.x) - (normalA.x * normalB.z)),						
		((normalA.x * normalB.y) - (normalA.y * normalB.x)) 						
		)						
								
	return math.pow (math.pow( a.x-b.x, 2 ) + 							
					 math.pow( a.y-b.y, 2 ) +  			
					" math.pow( a.z-b.z, 2 ) , 0.5 );"			
								
	"local dist = a:Dist( b );"							
								
	return Vector:New( 							
			(a.x-b.x) / dist,					
			(a.y-b.y) / dist,					
			"(a.z-b.z) / dist);"					
								
								
	local t =							
	{							
		position = v or Vector:New(),						
		yaw = _yaw or 0,						
		pitch = _pitch or 0,						
		roll = _roll or 0						
	}							
	setmetatable(t, self.__meta)							
	return t							
								
	RunFollower(actor)							
								
								
	Vector:New(-13191.5, 261.017, 21.857),							
	Vector:New(-13200.5, 274.399, 21.857),							
	Vector:New(-13214.2, 265.146, 21.857),							
	Vector:New(-13204.1, 250.901, 21.857),							
								
								
								
								
								
								
	local thisPoint = points[pointIndex]							
	pointIndex = (pointIndex % #points) + 1							
	local nextPoint = points[pointIndex]							
	local lookPoint = points[(pointIndex % #points) + 1] -- look another point ahead for the head							
								
	local offsetX = nextPoint.x - thisPoint.x							
	local offsetY = nextPoint.y - thisPoint.y							
	local dist = math.sqrt(offsetX*offsetX + offsetY*offsetY)							
								
	if count == 4 then							
		scene:SetCamera(0, 1, nil, nil)						
	elseif count < 4 then							
								
		if pointIndex == 1 then						
			scene:SetCamera(302, 10.0, nil, nil)					
	--	elseif pointIndex == 2 then						
	--		scene:SetCamera(0, 0.5, nil, nil)					
		elseif pointIndex == 3 then						
			scene:SetCamera(303, 20.0, nil, nil)					
		end						
								
	end							
								
	count = count + 1							
								
	actor:SetFacingToAbs(lookPoint)							
	scene:WaitTimer(2)							
	actor:ClearFacing()							
	actor:SetHeadFacingToAbs(nextPoint)							
	scene:WaitTimer(2)							
	actor:ClearHeadFacing()							
	scene:WaitTimer(2)							
								
	#NAAM?							
	actor:MoveToAbs(nextPoint, dist / speed)							
	"print(\""MoveTo: points[\"" .. pointIndex .. \""]\"" .. nextPoint:ToString())"							
								
	#NAAM?							
	scene:WaitTimer(0.5)							
	actor:SetHeadFacingToAbs(lookPoint)							
	scene:WaitTimer(1)							
	actor:ClearHeadFacing()							
								
	actor:WaitMovementComplete()							
	scene:WaitTimer(1)							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	local followOffsetX = 5							
								
	if not followTarget then							
		return						
	end							
								
	local scene = followTarget:GetScene()							
	scene:WaitTimer(2)							
								
	local spawnPos = followTarget:GetPosition()							
	spawnPos.x = spawnPos.x + followOffsetX							
								
	local actorCreateData = ActorCreateData:New(55242, Transform:New(spawnPos, 0), 1.5)							
	local actor = scene:SpawnActor(actorCreateData)							
	actor:SetHeadFacingToTarget(followTarget, Vector:New())							
	actor:SetInteractible(false)							
								
	while true do							
		local facePos = followTarget:GetPosition()						
		actor:SetFacingToAbs(facePos)						
		scene:WaitTimer(15)						
								
		facePos = followTarget:GetPosition()						
		actor:SetFacingToAbs(facePos)						
		scene:WaitTimer(15)						
								
		actor:ClearFacing()						
								
		local movePos = followTarget:GetPosition()						
		movePos.x = movePos.x + followOffsetX						
								
								
		actor:WaitMoveToAbs(movePos, 2)						
	end							
								
								
								
								
								
								
	"\""Camp Fire\"","							
	"\""world\\generic\\human\\passive doodads\\firewood\\firewoodpile04.m2\"","							
	Transform:New(Vector:New(0, 0, 0), 0),							
	2.0)							
								
								
	"\""Fireworks\"","							
	"\""spells\\fireworks_redstreaks_01.m2\"","							
	Transform:New(Vector:New(0, 0, 0), 0),							
	0.5)							
								
								
	scene:WaitTimer(1)							
	local transform = fireActor:GetTransform()							
	transform.yaw = transform.yaw + 5							
	fireActor:SetTransform(transform)							
								
	pet.actor:SetFacingToTarget(opponent.actor, Vector:New())							
								
	"local originalOpponentLoc = VectorCopy(opponent.actor:GetPosition());"							
	"local originalPetLoc = VectorCopy(pet.actor:GetPosition());"							
								
	for i=1, #points do 							
		"local v = points[i];"						
		"local newDrift = FastLocalFacingCoordinates(originalOpponentLoc, originalPetLoc , v * -battleScale );"						
								
		local opponentDriftPoint 	"= opponent.actor:GetPosition() + (newDrift-originalOpponentLoc);"					
		local driftDistance = opponentDriftPoint:Dist( pet.actor:GetPosition() )						
								
		pet.actor:CastSpell( 122, opponent.actor)						
		"pet.actor:WaitMoveToAbs(opponentDriftPoint,driftDistance/pet.moveSpeed );"						
								
		opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)						
		PerformTinyKnockback(opponent, pet, damage/5)						
								
	end							
	"pet.actor:ClearFacing();"							
								
	"PerformRelativeBump( opponent, pet, front, left, up );"							
								
								
	"local front = math.random(10,20)*.01;"							
	"local left = math.random(-10,10)/10;"							
	"local up = 0;"							
								
	scene:WaitTimer(0.3)							
								
	"print(\""knock\"")"							
	opponent.actor:AddDamageText(nil, damage, false, false)							
	"PerformRelativeBump( opponent, pet, front, left, up );"							
								
								
	"local front = -3;"							
	local left = 0							
	"local up = 0;"							
								
	scene:WaitTimer(0.3)							
								
	"print(\""knock\"")"							
	opponent.actor:AddDamageText(nil, damage, false, false)							
	local opponentFinalPoint 	"= opponent.actor:GetPosition() + CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up );"						
	local driftDistance = 3							
								
	"local duration = driftDistance/battleScale/opponent.moveSpeed;"							
								
	"--opponent.actor:MoveToAbs(opponentFinalPoint,  Vector:New() );"							
	opponent.actor:SetSnapToGround(false)							
	opponent.actor:MoveSplineAbs( 							
			BuildKnockbackSpline(opponent, opponentFinalPoint, duration), duration )					
	opponent.actor:WaitMovementComplete()							
	opponent.actor:SetSnapToGround(true)							
								
								
								
	"local front = math.random(15,15)*.01;"							
	"local left = math.random(-15,15)*.01;"							
	"local up = 0;"							
								
	--scene:WaitTimer(0.3)							
								
	"--print(\""tinyknock\"")"							
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)							
								
	opponent.actor:AddDamageText(nil, damage, false, false)							
								
								
	"--PerformRelativeBump( opponent, pet, front, left, up );"							
								
	opponent.actor:SetSnapToGround(false)							
	opponent.actor:AddDamageText(nil, damage, false, false)							
								
	--opponent.actor:MoveSplineAbs(BuildKnockbackSpline(opponent, opponent.actor:GetPosition(), 0.5), 0.5)							
								
								
	opponent.actor:WaitMovementComplete()							
	opponent.actor:SetSnapToGround(true)							
	"\""spells\\fireworks_redstreaks_01.m2\"","							
	Transform:New(Vector:New(0, 0, 0), 0),							
	0.5)							
								
								
	ActorCreateData:NewModel(							
		"\""Fireworks\"","						
		"\""SPELLS\\Fireball_Missile_High.m2\"","						
		Transform:New(Vector:New(7.5,0,0), 0),						
		1						
	") );"							
								
								
								
								
	Vector:New(7.5,0,0),							
	Vector:New(0,-7.5,0),							
	Vector:New(-7.5,0,0),							
	Vector:New(0.0,7.5),							
								
	"local curr=corners[i];"							
	"local next=corners[math.fmod((i),#corners)+1];"							
								
	"local dx = next.x-curr.x;"							
	"local dy = next.y-curr.y;"							
								
	"local stepX = dx/4;"							
	"local stepY = dy/4;"							
	for d = 1, 4 do 							
		if i == 2 or i == 4 then 						
			table.insert(fences ,					
				Transform:New(Vector:New(curr.x+stepX*d,curr.y+stepY*d,0), 225+90*(i))				
			");"					
		else						
			table.insert(fences ,					
				Transform:New(Vector:New(curr.x+stepX*d,curr.y+stepY*d,0), 45+90*(i))				
			");"					
		end						
	end							
								
	Transform:New(Vector:New(7.50,0,0), -45),							
	Transform:New(Vector:New(3.75,-3.75,0), -45),							
	Transform:New(Vector:New(0,7.5,0), 45),							
	Transform:New(Vector:New(3.75,3.75,0), 45),							
	Transform:New(Vector:New(0,-7.5,0), -135),							
	Transform:New(Vector:New(-3.75,-3.75,0), -135),							
	Transform:New(Vector:New(-7.5,0,0), 135),							
	Transform:New(Vector:New(-3.75,3.75,0), 135),							
	table.insert(listOfFenceCreateData, 							
		ActorCreateData:NewModel( 						
			"\""Ring\"","					
			"\""WORLD\\EXPANSION01\\DOODADS\\EVERSONG\\FENCE\\BE_Fence_Eversong02.m2\"","					
			v,					
			0.5					
		)						
	");"							
								
								
	"v:SetInteractible(false);"							
								
								
								
	Vector:New(   7.50,	  -0,  0),						
	Vector:New(   3.75, -3.75,  0),							
	Vector:New(   0,	-7.5,  0),						
	Vector:New(  -3.75,	-3.75,  0),						
	Vector:New(  -7.50,	  -0,  0),						
	Vector:New(  -3.75, 3.75,  0),							
	Vector:New(      0,  7.5,  0),							
	Vector:New(   3.75, 3.75,  0)							
								
								
	local newActor = scene:SpawnActor(							
		ActorCreateData:NewModel(						
			"\""Fireworks\"","					
			"\""SPELLS\\Fireball_Missile_High.m2\"","					
			"Transform:New(v, 0), 0.5) );"					
								
	"newActor:SetInteractible(false);"							
	"table.insert(actors, {actor=newActor,point=k});"							
								
								
	if ( forward ) then							
		direction = 1						
	else							
		direction = -1						
	end							
	"current = current + direction;"							
	if ( current> #arrayOfPoints ) then							
		current = 1						
	elseif ( current <= 0 ) then							
		current = #arrayOfPoints						
	end							
								
	for k,v in pairs(actors) do 							
		v.actor:MoveToAbs(arrayOfPoints[math.fmod(current+v.point, #arrayOfPoints)+1], 1.5)						
	end							
	actors[1].actor:WaitMovementComplete()							
	createData.groundSnap = (snapToGround ~= false)							
	createData.interactible = false							
								
	local actor = scene:SpawnActor( createData )							
	return actor							
								
								
								
								
	local destPos = Vector:New(x, y, z)							
								
	local currPos = actor:GetPosition()							
	local offset = currPos - destPos							
	local distance = offset:Magnitude()							
								
	local travelTime = distance / speed							
								
	actor:WaitMoveToAbs( destPos, travelTime )							
								
	if facing then							
		actor:SetFacing( facing )						
	end							
								
								
								
								
	#NAAM?							
	if faceTarget and faceTarget == true then							
		caster:SetFacingToTarget( target, Vector:New() )						
		scene:WaitTimer( 0.75 )						
	end							
								
	caster:CastSpell( spellID, target )							
								
	if faceTarget and faceTarget == true then							
		caster:ClearFacing()						
	end							
								
								
								
	actor:PlayLoopingSplitBodyAnim( anim )							
								
								
								
	actor:PlayLoopingSplitBodyAnim( anim )							
								
								
								
	actor:PlayOneShotSplitBodyAnim( anim )							
								
								
								
	actor:StopAnimKit( AnimKits.LoopingSplitBody )							
								
								
								
	if not fadeTime then							
		fadeTime = 2						
	end							
								
	actor:Fade( 0, fadeTime )							
								
								
								
	if not fadeTime then							
		fadeTime = 0.5						
	end							
								
	actor:Fade( 1, fadeTime )							
								
								
	Triggers[triggerName] = true							
								
								
	local waitCondition = function()							
		return (Triggers[triggerName] == true)						
	end							
	"	0	599
47	Global Constants - Animation"""	"
-- Useful Anim Kit IDs
AnimKits =
{
	OneShotSplitBody	= 2127;
	OneShotUpperBody	= 2128;
	OneShotFullBody		= 2129;
	LoopingSplitBody	= 2130;
	LoopingUpperBody	= 2131;
	LoopingFullBody		= 2132;
}


-- Construct an animation table out of the 5 individual anim tables
-- When we have removed the 4000 character limit we can eliminate this step

Animations = { }

function AddToAnimTable(subTable)
	for animName, id in pairs(subTable) do
		Animations[animName] = id
	end
end

AddToAnimTable(AnimTable1)
AddToAnimTable(AnimTable2)
AddToAnimTable(AnimTable3)
AddToAnimTable(AnimTable4)

-- avoid duplicate memory
AnimTable1 = nil
AnimTable2 = nil
AnimTable3 = nil
AnimTable4 = nil
"	0	0				
	end							
								
	"local opponentHome = HOME_LIST[opponent.team].position;"							
								
	local opponentReturnDistance = opponent.actor:GetPosition():Dist(opponentHome)							
								
	if ( opponentReturnDistance > 3 * battleScale ) then 							
		"local distance = opponentHome:Dist(pet.actor:GetPosition());"						
		"print ( \""opponent reset\"" );"						
		"opponent.actor:WaitMoveToAbs( opponentHome, distance/ ( opponent.moveSpeed*backwardSpeedMulti) );"						
								
	end							
								
	"--pet.actor:WaitMoveToAbs( pet.home, returnDistance/ ( pet.speed*backwardSpeedMulti) );"							
								
	"pet.actor:WaitMoveToAbs( petLoc, returnDistance/ ( pet.moveSpeed*backwardSpeedMulti) );"							
	pet.actor:SetFacingToAbs(opponent.actor:GetPosition())							
								
								
								
								
								
								
								
								
	"intro = 336;"							
	"idle = 335;"							
								
	"Transform:New(Vector:New( 2*battleScale, 0, 0), 180);"							
	"Transform:New(Vector:New( -2*battleScale, 0, 0), 0);"							
	"Transform:New(Vector:New( 6, -6, 3), 180);"							
	"Transform:New(Vector:New( -6, 6, 3), 0);"							
	"Vector:New(-1, 2, 0 );"							
	"Vector:New(-1, -2, 0 );"							
								
								
								
	#NAAM?							
	"allPlayers[#allPlayers + 1] = team;"							
								
	#NAAM?							
	"local homeTransform = HOME_LIST[#allPlayers];"							
								
	#NAAM?							
	"team.pad = DoPadInit(homeTransform);"							
								
	#NAAM?							
	"local masterTransform = MASTER_SPOTS[#allPlayers];"							
	"local masterLoc = masterTransform.position;"							
								
	"local master = scene:SpawnActor(ActorCreateData:New(55242, masterTransform, battleScale) );"							
	"master:SetFacingToAbs(Vector:New());"							
								
	#NAAM?							
	"team.master = master;"							
								
	#NAAM?							
	"team.pets = {};"							
								
	"mainPetLoc = homeTransform;"							
								
	"local backLineCount = 0;"							
								
	for k,v in pairs( team.petDescs ) do 							
		if ( k == team.activePet ) then 						
			"table.insert(team.pets, InitPet(team, k, mainPetLoc) );"					
		else						
			"backLineCount = backLineCount + 1;"					
								
			#NAAM?					
			"local offset = FastLocalFacingCoordinates ( masterTransform.position, Vector:New(), BACKROW_PET_OFFSETS[backLineCount] );"					
			"local newPet = InitPet(team, k, Transform:New( offset, masterTransform.yaw ) );"					
								
			"table.insert(team.pets, newPet );"					
		end						
	end							
								
	#NAAM?							
	for k,v in pairs(team.pets) do							
		if ( k ~= team.activePet ) then 						
			"v.actor:SetFacingToTarget(team.pets[team.activePet].actor, Vector:New());"					
		end						
	end							
								
	#NAAM?							
	"team.home = homeTransform.position;"							
								
								
	"local petData = team.petDescs[petIndex];"							
	local petActor = scene:SpawnActor(ActorCreateData:New(petData.creatureID, transform, battleScale))							
								
	#NAAM?							
	for auraIndex, auraData in pairs(petData.auras or { }) do							
		--[[						
		local abilityTurn = petAbilityTurns[auraData.abilityTurnID]						
		if (abilityTurn) then						
			ApplyAura(pet, auraData.instanceID, abilityTurn.spellVisualID)					
		end						
		]]--						
	end							
								
	#NAAM?							
	"petActor:SetInteractible(false);"							
	"petActor:SetHidden(true);"							
	"petActor:Fade(0, 0);"							
								
	"local pet = { actor = petActor; moveSpeed = 5; auras = {}; slot = petIndex; team = team.playerID; health = petData.health };"							
								
	"return pet;"							
								
								
	local waitCondition = function()							
		#NAAM?						
		for playerID, player in pairs( allPlayers ) do						
			for slot, pet in pairs ( player.pets ) do					
				if not pet.actor:IsReadyToDisplay() then				
					return false			
				end				
			end					
		end						
		return true						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetHidden(false)					
								
			local targetAlpha = backlineAlpha					
			if slot == player.activePet then					
				#NAAM?				
				targetAlpha = 1.0 --GetAlpha(pet)				
			end					
								
			pet.actor:Fade(targetAlpha, fadeInTime or 1)					
		end						
	end							
								
	#NAAM?							
	if fadeInTime > 0 then							
		scene:WaitTimer( fadeInTime )						
	end							
								
	#NAAM?							
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetInteractible( true )					
		end						
	end							
								
								
								
								
								
	"local beams = {};"							
	for i = 1, 5 do 							
		"local f = math.random(-150,150)*0.01;"						
		"local l = math.random(-250,250)*0.01;"						
								
		if ( i == 3 ) then 						
			f,l = 0,0					
		end						
								
		"local v = frontVector*f+leftVector*l;"						
		"v = opponentLocation + v;"						
		"local t = Transform:New(v,math.random(-180,180));"						
								
		local create = ActorCreateData:NewModel(						
			"\""Moonfire\"","					
			"\""SPELLS\\MOONFIRE_IMPACT_BASE.m2\"","					
			t,					
			"0.5);"					
		"local newActor = scene:SpawnActor(create);"						
								
		"table.insert(beams, newActor);"						
		scene:WaitTimer(0.3)						
		opponent.actor:AddDamageText(nil, damage/5, false, false)						
	end							
								
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)							
								
	scene:WaitTimer(1.0)							
								
	for k,v in pairs(beams) do 							
		"v:Despawn();"						
	end							
								
								
								
								
								
								
								
								
								
								
		return						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
								
		targetPet.actor:PlaySpellImpactVisual(spellVisualID)						
								
		local newHealth = targetData.newHealth						
		SetHealth(targetPet, newHealth, false)						
	end							
								
	#NAAM?							
	casterCastingPet.actor:WaitCastingComplete(true)							
	team.pad = scene:SpawnActor(padCreateData)							
	team.pad:Fade(padAlpha, 0.5)							
								
	team.pets = { }							
	local numDescs = #team.petDescs							
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing							
	for id, petDesc in pairs(team.petDescs) do							
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }						
								
		team.pets[id] = pet						
								
		local radius = backlineRadius						
		local offset = 0						
		if id == team.activePet then						
			radius = idleRadius					
		else						
			offset = backLineOffset					
			backLineOffset = backLineOffset + backlineSpacing					
		end						
								
		local pos = BuildVector(team.teamFacing, -radius, offset)						
		local transform = Transform:New(pos, team.teamFacing)						
								
		local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)						
		petCreateData.creatureDisplayID = petDesc.displayID or 0						
								
		pet.actor = scene:SpawnActor(petCreateData)						
								
		SetHealth(pet, petDesc.health, true)						
								
		pet.currentRadius = radius						
		pet.currentOffset = offset						
								
		#NAAM?						
		LookAtOpposingTeam(pet)						
								
		#NAAM?						
		for auraIndex, auraData in pairs(petDesc.auras or { }) do						
			local abilityTurn = petAbilityTurns[auraData.abilityTurnID]					
			if (abilityTurn) then					
				ApplyAura(pet, auraData.instanceID, abilityTurn.spellVisualID)				
			end					
		end						
								
		#NAAM?						
		pet.actor:SetInteractible(false)						
		pet.actor:SetHidden(true)						
		pet.actor:Fade(0, 0)						
		pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)						
	end							
								
								
	local waitCondition = function()							
		#NAAM?						
		for playerID, player in pairs( allPlayers ) do						
			for slot, pet in pairs ( player.pets ) do					
				if not pet.actor:IsReadyToDisplay() then				
					return false			
				end				
			end					
		end						
		return true						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetHidden(false)					
								
			local targetAlpha = backlineAlpha					
			if slot == player.activePet then					
				#NAAM?				
				targetAlpha = GetAlpha(pet)				
			end					
								
			pet.actor:Fade(targetAlpha, fadeInTime)					
		end						
	end							
								
	#NAAM?							
	if fadeInTime > 0 then							
		scene:WaitTimer( fadeInTime )						
	end							
								
	#NAAM?							
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetInteractible( true )					
		end						
	end							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	"intro = 336;"							
	"idle = 335;"							
								
	"Stand = 2267;"							
	"Death = 2268;"							
	"Dead  = 2269;"							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	#NAAM?							
	"local padCreateData = ActorCreateData:NewModel(\""pad\"", padModel, transform, padScale*battleScale)"							
	pad = scene:SpawnActor(padCreateData)							
	pad:Fade(padAlpha, 0.5)							
	"pad:SetInteractible(false);"							
								
	"return pad;"							
								
	"local a = ActorCreateData:NewModel( \""target\"", camModel2, Transform:New(Vector:New(0,0,0),0), battleScale);"							
	"a.groundSnap = false;"							
	"local b = ActorCreateData:NewModel( \""camera\"", camModel2, Transform:New(Vector:New(0, -15, 5),0), battleScale);"							
	"b.groundSnap = false;"							
								
								
								
	"camera = 3;"							
								
	if ( camera == 0 ) then							
		scene:SetCamera(360, 0.0, pad1, pad2)						
		scene:SetCamera(362, 3.0, mainCamera, mainCameraTarget)						
								
	elseif ( camera == 1 ) then 							
		#NAAM?						
		scene:SetCamera(360, 0.0, pad1, pad2)						
	elseif ( camera == 2 ) then 							
		#NAAM?						
		scene:SetCamera(361, 3.0, pad1, pad2)						
	elseif ( camera == 3 ) then 							
		#NAAM?						
								
		scene:SetCamera(362, 3.0, mainCamera, mainCameraTarget)						
	elseif ( camera == 4 ) then							
		--scene:SetCamera(335, 3.0, mainCamera, mainCameraTarget)						
		--scene:SetCamera(362, 3.0, mainCameraTarget, mainCamera)						
	end							
								
	#NAAM?							
	"local arrayOfPoints = {};"							
	"local radius = 15;"							
	local max = 36							
	for i=1,max do 							
		"local v = Vector:New(  math.cos(math.pi*2*i/max)*radius, math.sin(math.pi*2*i/max)*radius, 5 );"						
								
		"table.insert(arrayOfPoints,v);"						
	end							
								
	"local point = 1;"							
	"local forward = true;"							
	"local current = 1;"							
								
	while true do 							
		if ( forward ) then						
			direction = 1					
		else						
			direction = -1					
		end						
		"current = current + direction;"						
		if ( current> #arrayOfPoints ) then						
			current = 1					
		elseif ( current <= 0 ) then						
			current = #arrayOfPoints					
		end						
								
		mainCamera:MoveSplineAbs(arrayOfPoints, 100)						
		mainCamera:WaitMovementComplete()						
	end							
								
	"local distance = (pet.actor:GetPosition()+frontVector*-1):Dist(opponentLocation+frontVector*-3)+4;"							
								
	"local objects = {};"							
	"local total = 15;"							
								
	for i = 1, total do 							
								
		"local f = distance/total*i;"						
		"local l = math.sin(math.rad(i*(600/total)))*3;"						
								
		l = l * (0.1 + 0.9 * i/total)						
								
		"local v = frontVector*f+leftVector*l;"						
		"v = pet.actor:GetPosition() + v;"						
		"local t = Transform:New(v,math.random(-180,180));"						
								
		local create = ActorCreateData:NewModel(						
			"\""Dirt\"","					
			"\""SPELLS\\burrowearth_brown_missile_v2.m2\"","					
			t,					
			"0.2);"					
		"local newActor = scene:SpawnActor(create);"						
		"newActor:SetInteractible(false);"						
								
		"table.insert(objects, newActor);"						
								
		"local v = frontVector*f+leftVector*-l;"						
		"v = pet.actor:GetPosition() + v;"						
		"local t = Transform:New(v,math.random(-180,180));"						
								
		local create = ActorCreateData:NewModel(						
			"\""Dirt\"","					
			"\""SPELLS\\burrowearth_brown_missile_v2.m2\"","					
			t,					
			"0.2);"					
		"local newActor = scene:SpawnActor(create);"						
		"newActor:SetInteractible(false);"						
								
		"table.insert(objects, newActor);"						
		scene:WaitTimer(0.05)						
	end							
								
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)							
								
	scene:WaitTimer(0.5)							
								
	for i = 1, total do 							
								
		"local f = distance/total*i;"						
		"local l = math.sin(math.rad(i*(600/total)))*3;"						
								
		l = l * (0.1 + 0.9 * i/total)						
								
		"local v = frontVector*f+leftVector*l;"						
		"v = pet.actor:GetPosition() + v;"						
		"local t = Transform:New(v,math.random(-180,180));"						
								
		local create = ActorCreateData:NewModel(						
			"\""Dirt\"","					
			"\""SPELLS\\GROUNDSPIKE_IMPACT.m2\"","					
			t,					
			"0.2);"					
		"local newActor = scene:SpawnActor(create);"						
		newActor:PlayLoopingAnimKit(2133)						
		"newActor:SetInteractible(false);"						
		"table.insert(objects, newActor);"						
								
		"local v = frontVector*f+leftVector*-l;"						
		"v = pet.actor:GetPosition() + v;"						
		"local t = Transform:New(v,math.random(-180,180));"						
								
		local create = ActorCreateData:NewModel(						
			"\""Dirt\"","					
			"\""SPELLS\\GROUNDSPIKE_IMPACT.m2\"","					
			t,					
			"0.2);"					
		"local newActor = scene:SpawnActor(create);"						
		newActor:PlayLoopingAnimKit(2133)						
		"newActor:SetInteractible(false);"						
		"table.insert(objects, newActor);"						
								
		scene:WaitTimer(0.05)						
								
		if ( i == 12 ) then 						
			opponent.actor:AddDamageText(nil, 10, false, false)					
			"PerformVerticalKnockback(opponent, pet, damage);"					
		end						
	end							
								
								
								
								
	scene:WaitTimer(1)							
								
	for k,v in pairs(objects) do 							
		v:StopAnimKit(2133)						
	end							
	scene:WaitTimer(0.4)							
	for k,v in pairs(objects) do 							
		"v:Fade(0,0);"						
		"v:Despawn();"						
	end							
		table.insert(list, 						
			pet.actor:GetPosition()+ Vector:New(x,y,u) 					
			");"					
								
	end							
	"table.insert(list, petFinalPoint);"							
	"table.remove(list, 1);"							
								
	"return list;"							
		"ProcessSwap(effect);"						
								
	elseif ( effect.type == PetBattleEffect.Ability ) then 							
								
		"print(\""Process Ability\"");"						
		"ProcessAbility(effect);"						
	else							
		"print ( \""Effect: \""..effect.instanceID );"						
		for k,v in pairs(effect) do 						
			"print(\""k: \"", k, \"" v: \"", v );"					
		end						
	end							
								
								
	if ( effect.type == PetBattleEffect.FinalRound ) then 							
		"return;"						
	end 							
								
	battleScene:SignalEffectApplied(effect.instanceID)							
								
	"local team = effect.casterPlayerID;"							
	"local newPetIndex = effect.newFrontPet;"							
								
	"local pet = allPlayers[team].pets[allPlayers[team].activePet];"							
	"local newPet = allPlayers[team].pets[newPetIndex];"							
								
	"local nextTeam = math.fmod(team,2)+1;"							
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]							
								
	#NAAM?							
	allPlayers[team].activePet = newPetIndex							
								
	#NAAM?							
	allPlayers[team].master:PlayOneShotSplitBodyAnim(Animations.EmotePoint)							
	scene:WaitTimer(1.0)							
								
	#NAAM?							
	PerformSwap(pet,newPet, opponent)							
								
	"local team = effect.casterPlayerID;"							
	"local pet = allPlayers[team].pets[allPlayers[team].activePet];"							
								
	"local nextTeam = math.fmod(team,2)+1;"							
	local opponent = allPlayers[nextTeam].pets[ allPlayers[nextTeam].activePet ]							
								
	PerformMove(pet,opponent, effect)							
	local newActor = scene:SpawnActor(							
	ActorCreateData:NewModel(							
		"\""Wave\"","						
		"\""SPELLS\\MISSILE_WAVE_WATER.m2\"","						
		Transform:New( pet.actor:GetPosition()+frontVector*-5, 0),						
		0.5						
	") );"							
	newActor:PlayLoopingAnimKit(2133)							
	"newActor:SetInteractible(false);"							
	"local target = opponent.actor:GetPosition() + frontVector*6;"							
	"newActor:SetFacingToAbs(target);"							
	scene:WaitTimer(1.0)							
								
								
	"newActor:MoveToAbs(target, 3);"							
	"lastD = newActor:GetPosition():Dist(opponent.actor:GetPosition());"							
	local test = function() 							
		"local d = newActor:GetPosition():Dist(opponent.actor:GetPosition());"						
		if( d < 1 or d > lastD ) then						
			"return true;"					
		else						
			"lastD = d;"					
			"return false;"					
		end						
								
	end							
								
	"scene:WaitCondition(test, nil, 6);"							
	"PerformHardKnockback(opponent,pet, damage);"							
								
	"newActor:WaitMovementComplete();"							
	"newActor:Fade(0,1);"							
	scene:WaitTimer(1.0)							
	"newActor:Despawn();"							
								
		return						
	end							
								
	local attackRadius = meleeRadius							
	if not abilityTurn.isMelee then							
		attackRadius = rangedRadius						
	end							
								
	-- move front pet to the correct radius, if it was the caster							
	if ((casterPlayer.activePet == effect.casterPetSlot)) and (not casterFrontPet.deathAnimKit) then							
		WaitMoveToRadius(casterFrontPet, attackRadius)						
	end							
								
	--							
	#NAAM?							
	--							
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]							
	local spellVisualID = abilityTurn.spellVisualID							
								
	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)							
	scene:WaitTimer(abilityTurn.castTime)							
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)							
								
	#NAAM?							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
								
		if (casterCastingPet.actor ~= targetPet.actor) then						
			casterCastingPet.actor:PlaySpellCastVisualAtTargets(					
				spellVisualID,				
				abilityTurn.impactTime,				
				true,				
				{targetPet.actor})				
		else						
			#NAAM?					
			casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)					
		end						
	end							
								
	#NAAM?							
	local waitMissiles = false							
	if Actor.HasPendingMissiles then							
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)						
	end							
								
	if (waitMissiles == true) then							
		casterCastingPet.actor:WaitMissilesImpacted(0)						
	else							
		scene:WaitTimer(abilityTurn.impactTime)						
	end							
								
	return casterCastingPet, spellVisualID							
								
								
								
								
								
	scene:ClearCameraShake(shakeY)							
	scene:ClearCameraShake(shakeZ)							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	local posDummy = CameraPosFollowPath( cameraModeID, posPathID, moveTime )							
	local tgtDummy = CameraTgtFollowPath( cameraModeID, tgtPathID, moveTime )							
	scene:SetCamera( cameraModeID, transitionTime, posDummy, tgtDummy )							
								
	if not pathID then							
		return nil						
	end							
								
	local cameraDummyPos = cameraDummyPositions[cameraModeID]							
	if (not cameraDummyPos) then							
		cameraDummyPos = scene:SpawnActor(cameraDummyCreateData)						
		cameraDummyPositions[cameraModeID] = cameraDummyPos						
	end							
	CameraDummyFollowPath( cameraDummyPos, pathID, moveTime )							
	return cameraDummyPos							
								
	if not pathID then							
		return nil						
	end							
								
	local cameraDummyTgt = cameraDummyTargets[cameraModeID]							
	if (not cameraDummyPos) then							
		cameraDummyTgt = scene:SpawnActor(cameraDummyCreateData)						
		cameraDummyTargets[cameraModeID] = cameraDummyTgt						
	end							
	CameraDummyFollowPath( cameraDummyTgt, pathID, moveTime )							
	return cameraDummyTgt							
								
	local path = scene:LoadPath( pathID )							
	if #path.nodes > 0 then							
		#NAAM?						
		local transform = cameraDummy:GetTransform()						
		transform.position = path.nodes[1].pos						
		cameraDummy:SetTransform( transform )						
								
		#NAAM?						
		cameraDummy:FollowPath( pathID, moveTime )						
	end							
								
								
								
								
								
								
								
								
	"intro = 336;"							
	"idle = 335;"							
								
	"Stand = 2267;"							
	"Death = 2268;"							
	"Dead  = 2269;"							
	team.pad = scene:SpawnActor(padCreateData)							
	team.pad:Fade(padAlpha, 0.5)							
								
	team.pets = { }							
	local numDescs = #team.petDescs							
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing							
	for id, petDesc in pairs(team.petDescs) do							
		if (id == PetBattlePetID.Pad) then						
								
		else						
			local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }					
								
			team.pets[id] = pet					
								
			local radius = backlineRadius					
			local offset = 0					
			if id == team.activePet then					
				radius = idleRadius				
			else					
				offset = backLineOffset				
				backLineOffset = backLineOffset + backlineSpacing				
			end					
								
			local pos = BuildVector(team.teamFacing, -radius, offset)					
			local transform = Transform:New(pos, team.teamFacing)					
								
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)					
			petCreateData.creatureDisplayID = petDesc.displayID or 0					
								
			pet.actor = scene:SpawnActor(petCreateData)					
								
			SetHealth(pet, petDesc.health, true)					
								
			pet.currentRadius = radius					
			pet.currentOffset = offset					
								
			#NAAM?					
			LookAtOpposingTeam(pet)					
								
			#NAAM?					
			for auraIndex, auraData in pairs(petDesc.auras or { }) do					
				local auraVisual = petAbilityVisuals[auraData.auraVisualID]				
				if (auraVisual) then				
					ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)			
				end				
			end					
								
			#NAAM?					
			pet.actor:SetInteractible(false)					
			pet.actor:SetHidden(true)					
			pet.actor:Fade(0, 0)					
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)					
		end						
	end							
								
								
	local waitCondition = function()							
		#NAAM?						
		for playerID, player in pairs( allPlayers ) do						
			for slot, pet in pairs ( player.pets ) do					
				if not pet.actor:IsReadyToDisplay() then				
					return false			
				end				
			end					
		end						
		return true						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetHidden(false)					
								
			local targetAlpha = backlineAlpha					
			if slot == player.activePet then					
				#NAAM?				
				targetAlpha = GetAlpha(pet)				
			end					
								
			pet.actor:Fade(targetAlpha, fadeInTime)					
		end						
	end							
								
	#NAAM?							
	if fadeInTime > 0 then							
		scene:WaitTimer( fadeInTime )						
	end							
								
	#NAAM?							
	for playerID, player in pairs( allPlayers ) do							
		for slot, pet in pairs ( player.pets ) do						
			pet.actor:SetInteractible( true )					
		end						
	end							
								
			"print(\""ERROR: \"" .. result)"					
		end						
	end							
								
								
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
								
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then						
			targetPet.actor:AddWorldText(casterCastingPet, MissReasons.Physical, false, false)					
		else						
			if (spellVisualID) then					
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)				
			end					
								
			local newHealth = targetData.newHealth					
			SetHealth(targetPet, newHealth, false)					
		end						
	end							
								
	#NAAM?							
	if (spellVisualID) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. auraVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then						
			targetPet.actor:AddWorldText(casterCastingPet, MissReasons.Physical, false, false)					
		else						
			if (spellVisualID) then					
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)				
			end					
								
			-- apply an aura, tracked by instance ID					
			ApplyAura(targetPet, targetData.auraInstanceID, targetData.turnsRemaining, spellVisualID)					
		end						
	end							
								
	#NAAM?							
	if (spellVisualID) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
								
								
	local aura = pet.auras[auraInstanceID]							
	if (not aura) then							
		aura = { }						
		pet.auras[auraInstanceID] = aura						
	end							
								
	-- clear existing aura visual for this instance, if there is one							
	if (aura.spellVisualID and aura.spellVisualInstanceID) then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
	end							
								
	aura.spellVisualID = spellVisualID							
	if (aura.spellVisualID) then							
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	else							
		aura.spellVisualInstanceID = nil						
	end							
	aura.turnsRemaining = turnsRemaining							
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		if (aura.spellVisualID and aura.spellVisualInstanceID) then						
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)					
		end						
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	end							
								
			return					
		end						
								
		if (cancel == true) or (target.turnsRemaining < 1) then						
			RemoveAura(pet, auraInstanceID)					
		else						
			aura.turnsRemaining = target.turnsRemaining					
		end						
	end							
								
								
								
	RemoveAuraVisual(pet, pet.auras[auraInstanceID])							
	pet.auras[auraInstanceID] = nil							
								
								
								
	if aura and aura.spellVisualInstanceID then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
		aura.spellVisualInstanceID = nil						
	end							
								
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		RemoveAuraVisual(pet, aura)						
	end							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	mist:Fade( 0, 3 )							
								
								
	mist:Despawn()							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	"print(\""PetBattle: Start Custom Turn Template\"")"							
								
	for index, effectGroup in pairs(turn.effects) do							
								
		#NAAM?						
		for index, effectResult in pairs(effectGroup.results) do						
			StartEffectProcessing(effectResult)					
								
			ProcessRoundResult(effectResult)					
								
			SignalEffectProcessed()					
								
			if (effectResult.procGroup) then					
				ProcessRoundTurnGroup(effectResult.procGroup)				
			end					
		end						
								
	end							
								
	"print(\""PetBattle: End Custom Turn Template\"")"							
								
	"print(\""PetBattle: Start Custom Effect Template\"")"							
								
	for index, effectResult in pairs(effectGroup.results) do							
								
		StartEffectProcessing(effectResult)						
								
		ProcessRoundResult(effectResult)						
								
		SignalEffectProcessed()						
								
		if (effectResult.procGroup) then						
			ProcessRoundTurnGroup(effectResult.procGroup)					
		end						
								
	end							
								
	"print(\""PetBattle: End Custom Effect Template\"")"							
								
								
								
								
								
								
								
								
								
	createData.groundSnap = (snapToGround ~= false)							
	createData.interactible = false							
								
	local actor = scene:SpawnActor( createData )							
	return actor							
								
								
								
								
	local destPos = Vector:New(x, y, z)							
								
	local currPos = actor:GetPosition()							
	local offset = currPos - destPos							
	local distance = offset:Magnitude()							
								
	local travelTime = distance / speed							
								
	actor:WaitMoveToAbs( destPos, travelTime )							
								
	if facing then							
		actor:SetFacing( facing )						
	end							
								
								
								
								
	#NAAM?							
	if faceTarget and faceTarget == true then							
		caster:SetFacingToTarget( target, Vector:New() )						
		scene:WaitTimer( 0.75 )						
	end							
								
	caster:CastSpell( spellID, target )							
								
	if faceTarget and faceTarget == true then							
		caster:ClearFacing()						
	end							
								
								
								
	actor:PlayLoopingSplitBodyAnim( anim )							
								
								
								
	actor:PlayLoopingSplitBodyAnim( anim )							
								
								
								
	actor:PlayOneShotSplitBodyAnim( anim )							
								
								
								
	actor:StopAnimKit( AnimKits.LoopingSplitBody )							
								
								
								
	if not fadeTime then							
		fadeTime = 2						
	end							
								
	actor:Fade( 0, fadeTime )							
								
								
								
	if not fadeTime then							
		fadeTime = 0.5						
	end							
								
	actor:Fade( 1, fadeTime )							
								
								
	Triggers[triggerName] = true							
								
								
	local waitCondition = function()							
		return (Triggers[triggerName] == true)						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	useFreelookCamera = false							
								
	"intro = 336;"							
	"idle = 335;"							
								
	"Stand = 2267;"							
	"Death = 2268;"							
	"Dead  = 2269;"							
	padCreateData.interactible = false							
	local padActor = scene:SpawnActor(padCreateData)							
	padActor:Fade(padAlpha, 0)							
								
	#NAAM?							
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then							
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)						
		local npcCreateData = ActorCreateData:Default()						
		npcCreateData.creatureID = team.npcCreatureID						
		npcCreateData.creatureDisplayID = team.npcDisplayID						
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)						
		npcCreateData.interactible = false						
		team.npcActor = scene:SpawnActor(npcCreateData)						
		team.playerDisplay = team.npcActor						
	end							
								
	team.pets = { }							
	local numDescs = #team.petDescs							
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing							
	for id, petDesc in pairs(team.petDescs) do							
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }						
		pet.playerID = playerID						
		team.pets[id] = pet						
								
		if (id == PetBattlePetID.Pad) then						
			pet.isPad = true					
			pet.actor = padActor					
			team.pad = pet					
		else						
			pet.isPad = false					
			local radius = backlineRadius					
			local offset = 0					
			if id == team.activePet then					
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then				
					radius = backlineRadius			
				else				
					radius = idleRadius			
				end				
			else					
				offset = backLineOffset				
				backLineOffset = backLineOffset + backlineSpacing				
			end					
								
			local pos = BuildVector(team.teamFacing, -radius, offset)					
			local transform = Transform:New(pos, team.teamFacing)					
								
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)					
			petCreateData.creatureDisplayID = petDesc.displayID or 0					
								
			pet.actor = scene:SpawnActor(petCreateData)					
								
			SetXP(pet, petDesc.xp, petDesc.level, true)					
			SetHealth(pet, petDesc.health, true)					
								
			pet.status = petDesc.status					
								
			pet.currentRadius = radius					
			pet.currentOffset = offset					
								
			#NAAM?					
			LookAtOpposingTeam(pet)					
								
								
			#NAAM?					
			pet.actor:SetInteractible(false)					
			pet.actor:SetHidden(true)					
			pet.actor:Fade(0, 0)					
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)					
		end						
								
		#NAAM?						
		for auraIndex, auraData in pairs(petDesc.auras or { }) do						
			local auraVisual = petAbilityVisuals[auraData.auraVisualID]					
			if (auraVisual) then					
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)				
			end					
		end						
	end							
								
								
	local waitCondition = function()							
		#NAAM?						
		for playerID, player in pairs( allPlayers ) do						
			for slot, pet in pairs ( player.pets ) do					
				if not pet.actor:IsReadyToDisplay() then				
					return false			
				end				
			end					
		end						
		return true						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
	for playerID, player in pairs( allPlayers ) do							
		if (player.isWeather == false) then						
			for slot, pet in pairs ( player.pets ) do					
				if (pet.isPad == false) then				
					pet.actor:SetHidden(false)			
								
					local targetAlpha = backlineAlpha			
					if slot == player.activePet then			
						#NAAM?		
						targetAlpha = GetAlpha(pet)		
		"	0	551
333	PetBattle(fallback) - Event Processing"""	"
-- Helper Functions for processing effects
local currentEffectInstanceID = nil

function ProcessEvent(event)

	-- apply the different types of effects
	if not (event) then
		return true
	end

	local eventType = event.eventType

	StartEffectProcessing(event)

	if (eventType == PetBattleEvent.BattleOver) then

		return false, event.winnerID

	elseif (eventType == PetBattleEvent.BattleResults) then

		EventReward(event.rewards)

	elseif (eventType == PetBattleEvent.ObserverChange) then

		local newIsObserved = false
		local newObservingPlayerIndex = 0
		if (battleScene.GetUIObservingPlayer) then
			newObservingPlayerIndex = battleScene:GetUIObservingPlayer()
			if (observingPlayerIndex > 0) then
				newIsObserved = true
			end
		end

		if (newIsObserved ~= isObserved) or (newObservingPlayerIndex ~= newIsObserved) then
			isObserved = newIsObserved
			observingPlayerIndex = newObservingPlayerIndex
			if (observingPlayerIndex > 0) then
				SetCamera(3)
			else
				SetCamera(4)
			end
		end

	elseif (eventType == PetBattleEvent.MoveAbilitySelected) then
		EventMoveAbilitySelected(event.abilityVisualID)
	elseif (eventType == PetBattleEvent.MovePetSwapSelected) then
		EventMovePetSwapSelected(event.newFrontPet)
	elseif (eventType == PetBattleEvent.MoveTrapSelected) then
		EventMoveTrapSelected()
	elseif (eventType == PetBattleEvent.RoundEffect) then
		print(\WARNING: processing round result outside of RoundStart/End\"")"					
		ProcessRoundResult(event)						
	elseif (eventType == PetBattleEvent.RoundStart) then							
								
		#NAAM?						
		local allEffects = { }						
		local effectNum = 0						
		local done = false						
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do						
			event = battleScene:GetPendingEffect()					
			eventType = event.eventType					
			if (eventType == PetBattleEvent.RoundComplete) then					
				done = true				
			else					
				effectNum = effectNum + 1				
				allEffects[effectNum] = event				
			end					
		end						
								
		-- if we have at least one effect or we\'re done, make sure						
		#NAAM?						
		#NAAM?						
		if (done == true or #allEffects > 0) then						
			SignalEffectProcessed()					
			ProcessAllRoundResults(allEffects)					
								
			#NAAM?					
			StartEffectProcessing(event)					
		end						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	if (eventType == PetBattleEvent.RoundComplete) then							
		for playerID, player in pairs(teams) do						
			ClearTrapPrecast(playerID)					
		end						
		ResetActivePets()						
	end							
								
	return true							
								
	#NAAM?							
	currentEffectInstanceID = event.instanceID							
								
	if currentEffectInstanceID and battleScene then							
		battleScene:SignalEffectApplied(currentEffectInstanceID)						
		currentEffectInstanceID = nil						
	end							
								
								
	if (not abilityVisual) then							
		return						
	end							
								
	local customScriptString = abilityVisual.scriptFunctionString							
	if (customScriptString and #customScriptString > 0) then							
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)						
		local status, result = pcall(loadstring(createString))						
		if (status == true) then						
			setfenv(result, getfenv())					
			abilityVisual.scriptFunction = result					
		else						
			"print(\""ERROR: loading script on BattlePetVisual ID=\"" .. abilityVisual.ID .. \"" failed: \"" .. createString)"					
			"print(\""ERROR: \"" .. result)"					
		end						
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	local playersWithDeaths = { }							
	local playersWithKills = { }							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
								
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then						
			targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)					
		else						
			if (spellVisualID) then					
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)				
			end					
								
			local oldHealth = targetPet.currentHealth					
			local newHealth = targetData.newHealth					
			SetHealth(targetPet, newHealth, false)					
								
			if (newHealth <= 0) and (oldHealth > 0) then					
				playersWithDeaths[targetPet.playerID] = true				
				if (casterCastingPet) then				
					playersWithKills[casterCastingPet.playerID] = true			
				end				
			end					
		end						
	end							
								
	#NAAM?							
	for playerID, hasDeath in pairs(playersWithDeaths) do							
		if (hasDeath) then						
			playersWithKills[playerID] = nil					
			local player = GetTeamByIndex(playerID)					
			if (player and player.playerDisplay) then					
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)				
			end					
		end						
	end							
								
	#NAAM?							
	for playerID, hasKill in pairs(playersWithKills) do							
		if (hasKill) then						
			local player = GetTeamByIndex(playerID)					
			if (player and player.playerDisplay) then					
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)				
			end					
		end						
	end							
								
	#NAAM?							
	if (spellVisualID) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
								
	local auraVisualID = 0							
	local auraVisual = nil							
	local auraSpellVisualID = 0							
								
	if (effect.targets[1]) then							
		auraVisualID = effect.targets[1].auraVisualID						
		auraVisual = petAbilityVisuals[auraVisualID]						
		if (auraVisual) then						
			auraSpellVisualID = auraVisual.spellVisualID					
		end						
	end							
								
	local casterCastingPet							
	local spellVisualID							
	casterCastingPet, spellVisualID = EffectCastShared(effect, abilityVisualID)							
	if (not abilityVisualID) or (abilityVisualID == 0) then							
		"print(\""WARNING: no auraVisual for aura\"")"						
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	for targetIndex, targetData in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(targetData.playerID)						
		local targetPet = targetPlayer.pets[targetData.petSlot]						
		if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then						
			targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)					
		else						
			if (spellVisualID) then					
				targetPet.actor:PlaySpellImpactVisual(spellVisualID)				
			end					
								
			-- apply an aura, tracked by instance ID					
			ApplyAura(targetPet, targetData.auraInstanceID, targetData.turnsRemaining, auraSpellVisualID)					
		end						
	end							
								
	#NAAM?							
	if (spellVisualID) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
								
								
	local aura = pet.auras[auraInstanceID]							
	if (not aura) then							
		aura = { }						
		pet.auras[auraInstanceID] = aura						
	end							
								
	-- clear existing aura visual for this instance, if there is one							
	if (aura.spellVisualID and aura.spellVisualInstanceID) then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
	end							
								
	aura.spellVisualID = spellVisualID							
	if (aura.spellVisualID) then							
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	else							
		aura.spellVisualInstanceID = nil						
	end							
	aura.turnsRemaining = turnsRemaining							
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		if (aura.spellVisualID and aura.spellVisualInstanceID) then						
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)					
		end						
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	end							
								
			return					
		end						
								
		if (cancel == true) or (target.turnsRemaining < 1) then						
			RemoveAura(pet, auraInstanceID)					
		else						
			aura.turnsRemaining = target.turnsRemaining					
		end						
	end							
								
								
								
	RemoveAuraVisual(pet, pet.auras[auraInstanceID])							
	pet.auras[auraInstanceID] = nil							
								
								
								
	if aura and aura.spellVisualInstanceID then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
		aura.spellVisualInstanceID = nil						
	end							
								
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		RemoveAuraVisual(pet, aura)						
	end							
								
	cameraBunnyCreate.model = padModel							
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()							
	cameraBunnyCreate.transform.facing = player.teamFacing							
	cameraBunnyCreate.interactible = false							
								
	cameraBunny = scene:SpawnActor(cameraBunnyCreate)							
	cameraBunny:SetFacingToAbs(BuildVector(player.teamFacing, playerRadius, 0.0))							
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)							
								
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)							
								
	if ( not cameraBunny ) or ( not isObserved ) or ( not useFreelookCamera ) then							
		return						
	end							
								
	#NAAM?							
	local player = teams[observingPlayerIndex]							
	scene:ResetGameCameraZoom()							
								
	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)							
	scene:WaitTimer(transitionTime)							
	scene:SetGameCameraTarget(nil, 0.0, 0.0)							
								
	if ( not isObserved ) then							
		return						
	end							
								
	local observedTeam = teams[observingPlayerIndex]							
	local otherTeam = teams[3 - observingPlayerIndex]							
								
	if ( camera == 1 ) then 							
		scene:SetCamera(battleCameraIDs.intro, 2.0, observedTeam.pad.actor, otherTeam.pad.actor)						
	elseif ( camera == 2 ) then 							
		scene:SetCamera(battleCameraIDs.idle, 2.0, observedTeam.pad.actor, arenaRing)						
	elseif ( camera == 3 ) then 							
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad.actor, arenaRing)						
	elseif ( camera == 4 ) then							
		scene:SetCamera(0, 0.75, nil, nil)						
	end							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	local abilityVisual = petAbilityVisuals[abilityVisualID]							
	if (not abilityVisual) then							
		return						
	end							
								
	local player = nil							
	local pet = nil							
	if (observingPlayerIndex > 0) then							
		player = GetTeamByIndex(observingPlayerIndex)						
		if (player) then						
			pet = player.pets[player.activePet]					
		end						
	end							
								
	if (not pet) then							
		return						
	end							
								
	local radius = readyRadius --GetAttackRadius(abilityVisual.range)							
	WaitMoveToRadius(pet, radius)							
								
								
					createData.interactible = false			
					createData.floatingTooltip = false			
								
					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)			
					local transform = Transform:New(pos, player.teamFacing)			
					createData.transform = transform			
								
					placeHolderActor = scene:SpawnActor(createData)			
					placeHolderActors[playerID] = placeHolderActor			
				end				
								
				#NAAM?				
				player.playerDisplay = placeHolderActor				
			else					
				-- done with this placeholder, despawn it				
				local placeHolderActor = placeHolderActors[playerID]				
				if (placeHolderActor) then				
					placeHolderActor:Despawn()			
				end				
								
				placeHolderActors[playerID] = nil				
			end					
		end						
	end							
								
	StartTrapPrecast(observingPlayerIndex)							
								
								
								
	local player = nil							
	local playerDisplay = nil							
	if (playerID and (playerID > 0)) then							
		player = GetTeamByIndex(playerID)						
		if (player) then						
			playerDisplay = player.playerDisplay					
		end						
	end							
								
	if (not playerDisplay) then							
		return						
	end							
								
	if (not player.trapVisualID) then							
		return						
	end							
								
	local trapVisual = petAbilityVisuals[player.trapVisualID]							
	local trapSpellVisualID = nil							
	if (trapVisual) then							
		trapSpellVisualID = trapVisual.spellVisualID						
	end							
								
	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then							
		return						
	end							
								
	return player, playerDisplay, trapVisual, trapSpellVisualID							
								
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
	if (not player) then							
		return						
	end							
								
	if (playerDisplay) then							
		if (not player.trapPrecastID) then						
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID )					
		end						
	end							
								
								
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
	if (not player) then							
		return						
	end							
								
	if (player.trapPrecastID) then							
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)						
		player.trapPrecastID = nil						
	end							
								
								
								
	local playerID = effect.casterPlayerID							
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
								
	if (not player) then							
		return						
	end							
								
								
	StartTrapPrecast(playerID)							
	scene:WaitTimer(trapVisual.castTime)							
	ClearTrapPrecast()							
								
	for targetIndex, target in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(target.playerID)						
		local targetPet = targetPlayer.pets[target.petSlot]						
								
		if (targetPet) then						
			local trapSuccess = false					
			if (targetPet.status) then					
				trapSuccess = targetPet.status.isTrapped				
			end					
								
			castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})					
			scene:WaitTimer(trapVisual.impactTime)					
								
			local waitCondition = function()					
				return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)				
			end					
			scene:WaitCondition(waitCondition)					
								
			if (trapSuccess) then					
				"--print(\""Succesful Trap\"")"				
				targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)				
			else					
				"print(\""Failed Trap\"")"				
			end					
		end						
	end							
								
	end							
								
	-- group on (turnInstanceID, effectID, stackDepth)							
								
	-- build an effect tree, taking into account procs							
	local turnGroups = { }							
	local effectGroups = { }							
								
	#NAAM?							
	local topLevelTurnGroups = { }							
								
	-- generate groups, and a  mapping from effectIndex							
	local lastEffect = nil							
	for effectIndex, effect in pairs(allEffects) do							
		local turnKey						
		local effectKey						
		turnKey, effectKey = GenerateUniqueGroupKeys(effect)						
								
		#NAAM?						
		local turnGroup = turnGroups[turnKey]						
		if (not turnGroup) then						
			turnGroup =					
			{					
				"key = turnKey;"				
				"firstEffect = effect;"				
				"effects = { };"				
			}					
			turnGroups[turnKey] = turnGroup					
								
			if (effect.stackDepth <= 1) or (not lastEffect) then					
				if (not table) then				
					topLevelTurnGroups[#topLevelTurnGroups + 1] = turnGroup			
				else				
					table.insert(topLevelTurnGroups, turnGroup)			
				end				
			else					
				-- this is a proc off of the last effect, and should be attached as a child				
				lastEffect.procGroup = turnGroup				
			end					
								
			if (debugOn == true) then					
				"print(\""+ New Turn Group, turnID = \"" .. effect.turnInstanceID .. \"", depth = \"" .. effect.stackDepth)"				
			end					
		end						
								
		#NAAM?						
		local effectGroup = effectGroups[effectKey]						
		if (not effectGroup) then						
			effectGroup =					
			{					
				"key = efffectKey;"				
				"firstEffect = effect;"				
				"results = { };"				
			}					
			effectGroups[effectKey] = effectGroup					
								
			-- this is a new effect group, link it to the end of our parent turn group					
			if (not table) then					
				turnGroup.effects[#turnGroup.effects + 1] = effectGroup				
			else					
				table.insert(turnGroup.effects, effectGroup)				
			end					
								
			if (debugOn == true) then					
				"print(\""+   New Effect Group, effectID = \"" .. effect.abilityEffectID)"				
			end					
		end						
								
		#NAAM?						
		if (not table) then						
			effectGroup.results[#effectGroup.results + 1] = effect					
		else						
			table.insert(effectGroup.results, effect)					
		end						
								
		if (debugOn == true) then						
			"print(\""+     New Result, instanceID = \"" .. effect.instanceID)"					
		end						
								
		lastEffect = effect						
	end							
								
	if (debugOn == true) then							
		"print(\""  \"")"						
		"print(\""== Start Round Playback ==\"")"						
	end							
								
	#NAAM?							
	for index, turnGroup in pairs(topLevelTurnGroups) do							
		ProcessRoundTurnGroup(turnGroup)						
	end							
								
	if (debugOn == true) then							
		"print(\""== End Round Playback ==\"")"						
		"print(\""  \"")"						
	end							
								
								
	if (debugOn == true) then							
		"print(\""- Processing Turn \"" .. turnGroup.firstEffect.turnInstanceID)"						
	end							
								
	#NAAM?							
	local turnVisual = nil							
	if (turnGroup.firstEffect.turnVisualID) then							
		turnVisual = petAbilityVisuals[turnGroup.firstEffect.turnVisualID]						
	end							
	local processed = false							
	if (turnVisual and turnVisual.scriptFunction) then							
		if ( turnVisual.scriptFunction( turnGroup ) ) then						
			processed = true					
		end						
	end							
								
	#NAAM?							
	if (processed ~= true) then							
		for index, effectGroup in pairs(turnGroup.effects) do						
			ProcessRoundEffectGroup(effectGroup)					
		end						
	end							
								
	if (debugOn == true) then							
		"print(\""-   Processing Effect \"" .. effectGroup.firstEffect.abilityEffectID)"						
	end							
								
	#NAAM?							
	local effectVisual = nil							
	"if """	0	554					
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	end							
								
	#NAAM?							
	if (effectType == PetBattleEffect.SetHealth) then							
		EffectSetHealth(event)						
	elseif (effectType == PetBattleEffect.AuraApply) then							
		EffectAuraApply(event)						
	elseif (effectType == PetBattleEffect.AuraCancel) then							
		EffectAuraChange(event, true)						
	elseif (effectType == PetBattleEffect.AuraChange) then							
		EffectAuraChange(event, false)						
	elseif (effectType == PetBattleEffect.PetSwap) then							
		EffectSwap(event.casterPlayerID, event.newFrontPet)						
	elseif (effectType == PetBattleEffect.StatusChange) then							
		EffectStatusChange(event)						
	elseif (effectType == PetBattleEffect.SetState) then							
		EffectSetState(event)						
	end							
								
								
								
	local stackDepth = effect.stackDepth or 0							
	local turnInstanceID = effect.turnInstanceID or 0							
	local effectID = effect.abilityEffectID or 0							
	if (stackDepth > maxStackDepth) then							
		"print (\""WARNING: stack depth exceeded \"" .. maxStackDepth)"						
	end							
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then							
		"print (\""WARNING: max turn instanceIDs exceeded \"" .. maxTurnInstanceIDs)"						
	end							
								
	local turnKey = turnInstanceID*maxStackDepth + stackDepth							
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey							
	return turnKey, effectKey							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	useFreelookCamera = false							
								
	"intro = 336;"							
	"idle = 335;"							
								
	"Stand = 2267;"							
	"Death = 2268;"							
	"Dead  = 2269;"							
	padCreateData.interactible = false							
	local padActor = scene:SpawnActor(padCreateData)							
	padActor:Fade(padAlpha, 0)							
								
	#NAAM?							
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then							
		local npcPos = BuildVector(team.teamFacing, -playerRadius, 0)						
		local npcCreateData = ActorCreateData:Default()						
		npcCreateData.creatureID = team.npcCreatureID						
		npcCreateData.creatureDisplayID = team.npcDisplayID						
		npcCreateData.transform = Transform:New(npcPos, team.teamFacing)						
		npcCreateData.interactible = false						
		team.npcActor = scene:SpawnActor(npcCreateData)						
		team.playerDisplay = team.npcActor						
	end							
								
	team.pets = { }							
	local numDescs = #team.petDescs							
	local backLineOffset = (0.5 - math.floor((numDescs - 1) / 2)) * backlineSpacing							
	for id, petDesc in pairs(team.petDescs) do							
		local pet = { desc = petDesc, teamFacing = team.teamFacing, slot = id, auras = { } }						
		pet.playerID = playerID						
		team.pets[id] = pet						
								
		if (id == PetBattlePetID.Pad) then						
			pet.isPad = true					
			pet.actor = padActor					
			team.pad = pet					
		else						
			pet.isPad = false					
			local radius = backlineRadius					
			local offset = 0					
			if id == team.activePet then					
				if (numDescs > 1) and (initialBattleState.battleState == PetBattleState.WaitingPreBattle) then				
					radius = backlineRadius			
				else				
					radius = idleRadius			
				end				
			else					
				offset = backLineOffset				
				backLineOffset = backLineOffset + backlineSpacing				
			end					
								
			local pos = BuildVector(team.teamFacing, -radius, offset)					
			local transform = Transform:New(pos, team.teamFacing)					
								
			local petCreateData = ActorCreateData:New(petDesc.creatureID, transform, battleScale)					
			petCreateData.creatureDisplayID = petDesc.displayID or 0					
								
			pet.actor = scene:SpawnActor(petCreateData)					
								
			SetXP(pet, petDesc.xp, petDesc.level, true)					
			SetHealth(pet, petDesc.health, true)					
								
			pet.status = petDesc.status					
								
			pet.currentRadius = radius					
			pet.currentOffset = offset					
								
			#NAAM?					
			LookAtOpposingTeam(pet)					
								
								
			#NAAM?					
			pet.actor:SetInteractible(false)					
			pet.actor:SetHidden(true)					
			pet.actor:Fade(0, 0)					
			pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)					
		end						
								
		#NAAM?						
		for auraIndex, auraData in pairs(petDesc.auras or { }) do						
			local auraVisual = petAbilityVisuals[auraData.auraVisualID]					
			if (auraVisual) then					
				ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)				
			end					
		end						
	end							
								
								
	local waitCondition = function()							
		#NAAM?						
		for playerID, player in pairs( allPlayers ) do						
			if ( player.pets ) then 					
				for slot, pet in pairs ( player.pets ) do				
					if not pet.actor:IsReadyToDisplay() then			
						return false		
					end			
				end				
			end					
		end						
		return true						
	end							
	scene:WaitCondition(waitCondition)							
								
								
								
	for playerID, player in pairs( allPlayers ) do							
		if (player.isWeather == false) then						
			for slot, pet in pairs ( player.pets ) do					
				if (pet.isPad == false) then				
					pet.actor:SetHidden(false)			
								
					local targetAlpha = backlineAlpha			
					if slot == player.activePet then			
						"-- use the front alpha if it is the active """	0	561
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(spellVisualID)							
	scene:WaitTimer(abilityVisual.castTime)							
	casterCastingPet.actor:ClearSpellPreCastVisual(spellVisualID, preCastInstance)							
								
	#NAAM?							
	if (casterCastingPet.actor ~= targetPet.actor) then							
		casterCastingPet.actor:PlaySpellCastVisualAtTargets(						
			spellVisualID,					
			abilityVisual.impactTime,					
			true,					
			{targetPet.actor})					
	else							
		#NAAM?						
		casterCastingPet.actor:PlaySpellCastVisual(spellVisualID)						
	end							
								
	#NAAM?							
	local waitMissiles = false							
	if Actor.HasPendingMissiles then							
		waitMissiles = casterCastingPet.actor:HasPendingMissiles(0)						
	end							
								
	if (waitMissiles == true) then							
		casterCastingPet.actor:WaitMissilesImpacted(0)						
	else							
		scene:WaitTimer(abilityVisual.impactTime)						
	end							
								
	return casterCastingPet, spellVisualID							
								
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	local playersWithDeaths = { }							
	local playersWithKills = { }							
								
	"targetData = effect.target;"							
								
	local targetPlayer = GetTeamByIndex(targetData.playerID)							
	local targetPet = targetPlayer.pets[targetData.petSlot]							
								
	if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then							
		targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)						
	else							
		if (spellVisualID) then						
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)					
		end						
								
		local oldHealth = targetPet.currentHealth						
		local newHealth = targetData.newHealth						
		SetHealth(targetPet, newHealth, false)						
								
		if (newHealth <= 0) and (oldHealth > 0) then						
			playersWithDeaths[targetPet.playerID] = true					
			if (casterCastingPet) then					
				playersWithKills[casterCastingPet.playerID] = true				
			end					
		end						
	end							
								
	#NAAM?							
	for playerID, hasDeath in pairs(playersWithDeaths) do							
		if (hasDeath) then						
			playersWithKills[playerID] = nil					
			local player = GetTeamByIndex(playerID)					
			if (player and player.playerDisplay) then					
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCry)				
			end					
		end						
	end							
								
	#NAAM?							
	for playerID, hasKill in pairs(playersWithKills) do							
		if (hasKill) then						
			local player = GetTeamByIndex(playerID)					
			if (player and player.playerDisplay) then					
				player.playerDisplay:PlayAnimKit(AnimKits.OneShotUpperBody, true, Animations.EmoteCheer)				
			end					
		end						
	end							
								
	#NAAM?							
	if (spellVisualID and not dontWait) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
								
	local auraVisualID = 0							
	local auraVisual = nil							
	local auraSpellVisualID = 0							
								
	if (effect.target) then							
		auraVisualID = effect.target.auraVisualID						
		auraVisual = petAbilityVisuals[auraVisualID]						
		if (auraVisual) then						
			auraSpellVisualID = auraVisual.spellVisualID					
		end						
	end							
								
	local casterCastingPet							
	local spellVisualID							
	casterCastingPet, spellVisualID = SpellEffectPlayShared(effect, abilityVisualID)							
	if (not abilityVisualID) or (abilityVisualID == 0) then							
		"print(\""WARNING: no auraVisual for aura\"")"						
	elseif (not spellVisualID) then							
		"print(\""WARNING: no spellVisual found for BattlePetVisual ID=\"" .. abilityVisualID)"						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	#NAAM?							
	"targetData =  effect.target;"							
	local targetPlayer = GetTeamByIndex(targetData.playerID)							
	local targetPet = targetPlayer.pets[targetData.petSlot]							
	if (effect.failureReason and effect.failureReason == PetBattleMoveFailureReason.Miss) then							
		targetPet.actor:AddWorldText(casterCastingPet.actor, MissReasons.Physical, false, false)						
	else							
		if (spellVisualID) then						
			targetPet.actor:PlaySpellImpactVisual(spellVisualID)					
		end						
								
		-- apply an aura, tracked by instance ID						
		ApplyAura(targetPet, targetData.auraInstanceID, targetData.turnsRemaining, auraSpellVisualID)						
	end							
								
	#NAAM?							
	if (spellVisualID) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
								
								
	local aura = pet.auras[auraInstanceID]							
	if (not aura) then							
		aura = { }						
		pet.auras[auraInstanceID] = aura						
	end							
								
	-- clear existing aura visual for this instance, if there is one							
	if (aura.spellVisualID and aura.spellVisualInstanceID) then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
	end							
								
	aura.spellVisualID = spellVisualID							
	if (aura.spellVisualID) then							
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	else							
		aura.spellVisualInstanceID = nil						
	end							
	aura.turnsRemaining = turnsRemaining							
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		if (aura.spellVisualID and aura.spellVisualInstanceID) then						
			pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)					
		end						
		aura.spellVisualInstanceID = pet.actor:PlaySpellStateVisual(spellVisualID)						
	end							
								
		return						
	end							
								
	if (cancel == true) or (target.turnsRemaining < 1) then							
		RemoveAura(pet, auraInstanceID)						
	else							
		aura.turnsRemaining = target.turnsRemaining						
	end							
								
								
								
	RemoveAuraVisual(pet, pet.auras[auraInstanceID])							
	pet.auras[auraInstanceID] = nil							
								
								
								
	if aura and aura.spellVisualInstanceID then							
		pet.actor:ClearSpellStateVisual(aura.spellVisualID, aura.spellVisualInstanceID)						
		aura.spellVisualInstanceID = nil						
	end							
								
								
								
	for auraInstanceID, aura in pairs(pet.auras) do							
		RemoveAuraVisual(pet, aura)						
	end							
								
	end							
								
	-- group on (turnInstanceID, effectID, stackDepth)							
								
	-- build an effect tree, taking into account procs							
	local turnGroups = { }							
	local effectGroups = { }							
								
	#NAAM?							
	local topLevelTurnGroups = { }							
								
	-- generate groups, and a  mapping from effectIndex							
	local lastEffect = nil							
	for eventIndex, event in pairs(allEvents) do							
		local turnKey						
		local effectKey						
		turnKey, effectKey = GenerateUniqueGroupKeys(event)						
								
		#NAAM?						
		if ( not event.targets[1] ) then						
			"Print(\"" NO target! \""..effectKey)"					
		end						
		"event.target = event.targets[1];"						
								
		#NAAM?						
		"event.targets = nil;"						
								
								
		#NAAM?						
		local turnGroup = turnGroups[turnKey]						
		if (not turnGroup) then						
			turnGroup =					
			{					
				"key = turnKey;"				
				"firstEvent = event;"				
				"effects = { };"				
			}					
			turnGroups[turnKey] = turnGroup					
								
			if (event.stackDepth <= 1) or (not lastEffect) then					
				table.insert(topLevelTurnGroups, turnGroup)				
			else					
				-- this is a proc off of the last effect, and should be attached as a child				
				lastEffect.procGroup = turnGroup				
			end					
								
			if ( processDebug ) then 					
				"DebugPrint(\""+ New Turn Group, turnID = \"" .. event.turnInstanceID .. \"", depth = \"" .. event.stackDepth"				
					"..\"", ability: \""..event.abilityID..\"", turn = \""..event.abilityTurnID);"			
			end					
		end						
								
		#NAAM?						
		local effectGroup = effectGroups[effectKey]						
		if (not effectGroup) then						
			effectGroup =					
			{					
				"key = effectKey;"				
				"firstEvent = event;"				
				"results = { };"				
			}					
			effectGroups[effectKey] = effectGroup					
								
			-- this is a new effect group, link it to the end of our parent turn group					
			table.insert(turnGroup.effects, effectGroup)					
								
			if ( processDebug ) then					
				"local effectName = \""Unknown\"";"				
								
				for k,v in pairs(PetBattleEffect) do 				
					if ( v == effect.effectType ) then			
						"effectName = k;"		
					end			
				end				
								
				"DebugPrint(\""+   New Effect Group, effectID = \"" .. effect.abilityEffectID..\"" effectType: \""..effectName)"				
			end					
		end						
								
								
		#NAAM?						
		table.insert(effectGroup.results, event)						
								
		if ( processDebug ) then						
								
			"local effectName = \""Unknown\"";"					
								
			for k,v in pairs(PetBattleEffect) do 					
				if ( v == event.effectType ) then				
					"effectName = k;"			
				end				
			end					
								
			"local eventType = \""Unknown\"";"					
			for k,v in pairs(PetBattleEvent) do 					
				if ( v == event.eventType ) then				
					"eventType = k;"			
				end 				
			end					
								
			"DebugPrint(\""+     New Result, instanceID = \"" .. event.instanceID..\"" effectType: \""..effectName..\"" eventType: \""..eventType)"					
		end						
								
		lastEffect = event						
	end							
	if ( processDebug ) then							
		"DebugPrint(\""  \"")"						
	end							
								
	"PlaybackAllTurns(topLevelTurnGroups);"							
								
	if ( processDebug ) then							
		"DebugPrint(\""  \"")"						
	end							
								
								
								
	local stackDepth = effect.stackDepth or 0							
	local turnInstanceID = effect.turnInstanceID or 0							
	local effectID = effect.abilityEffectID or 0							
	if (stackDepth > maxStackDepth) then							
		"print (\""WARNING: stack depth exceeded \"" .. maxStackDepth)"						
	end							
	if (maxTurnInstanceIDs > maxTurnInstanceIDs) then							
		"print (\""WARNING: stack depth exceeded \"" .. """	0	614				
	local abilityVisual = petAbilityVisuals[abilityVisualID]							
	if (not abilityVisual) then							
		return						
	end							
								
	local player = nil							
	local pet = nil							
	if (observingPlayerIndex > 0) then							
		player = GetTeamByIndex(observingPlayerIndex)						
		if (player) then						
			pet = player.pets[player.activePet]					
		end						
	end							
								
	if (not pet) then							
		return						
	end							
								
	local casterPlayer = GetTeamByIndex(observingPlayerIndex)							
	local casterCastingPet = casterPlayer.pets[effect.casterPetSlot]							
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]							
	local opponentFrontPet = GetActivePetByIndex(3 - observingPlayerIndex)							
								
	"PetMoveToAttackPosition(pet, opponentFrontPet, \""ready\"" );"							
								
								
	StartTrapPrecast(observingPlayerIndex)							
								
								
								
	local player = nil							
	local playerDisplay = nil							
	if (playerID and (playerID > 0)) then							
		player = GetTeamByIndex(playerID)						
		if (player) then						
			playerDisplay = player.playerDisplay					
		end						
	end							
								
	if (not playerDisplay) then							
		return						
	end							
								
	if (not player.trapVisualID) then							
		return						
	end							
								
	local trapVisual = petAbilityVisuals[player.trapVisualID]							
	local trapSpellVisualID = nil							
	if (trapVisual) then							
		trapSpellVisualID = trapVisual.spellVisualID						
	end							
								
	if (not trapSpellVisualID) or (trapSpellVisualID == 0) then							
		return						
	end							
								
	return player, playerDisplay, trapVisual, trapSpellVisualID							
								
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
	if (not player) then							
		return						
	end							
								
	if (playerDisplay) then							
		if (not player.trapPrecastID) then						
			player.trapPrecastID = playerDisplay:PlaySpellPreCastVisual(trapSpellVisualID )					
		end						
	end							
								
								
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
	if (not player) then							
		return						
	end							
								
	if (player.trapPrecastID) then							
		playerDisplay:ClearSpellPreCastVisual(trapSpellVisualID, player.trapPrecastID)						
		player.trapPrecastID = nil						
	end							
								
								
								
	local playerID = effect.casterPlayerID							
								
	local player							
	local playerDisplay							
	local trapVisual							
	local trapSpellVisualID							
	player, playerDisplay, trapVisual, trapSpellVisualID = GetTrapVisuals(playerID)							
								
	if (not player) then							
		return						
	end							
								
								
	StartTrapPrecast(playerID)							
	scene:WaitTimer(trapVisual.castTime)							
	ClearTrapPrecast()							
								
	for targetIndex, target in pairs(effect.targets) do							
		local targetPlayer = GetTeamByIndex(target.playerID)						
		local targetPet = targetPlayer.pets[target.petSlot]						
								
		if (targetPet) then						
			local trapSuccess = false					
			if (targetPet.status) then					
				trapSuccess = targetPet.status.isTrapped				
			end					
								
			castInstanceID = playerDisplay:PlaySpellCastVisualAtTargets(trapSpellVisualID, trapVisual.impactTime, true, {targetPet.actor})					
			scene:WaitTimer(trapVisual.impactTime)					
								
			local waitCondition = function()					
				return not playerDisplay:HasPendingOrInFlightMissiles(castInstanceID)				
			end					
			scene:WaitCondition(waitCondition)					
								
			if (trapSuccess) then					
				"--print(\""Succesful Trap\"")"				
				targetPet.trappedVisualInstance = targetPet.actor:PlaySpellStateVisual(trapSpellVisualID)				
			else					
				"print(\""Failed Trap\"")"				
			end					
		end						
	end							
								
		ProcessRoundResult(event)						
	elseif (eventType == PetBattleEvent.RoundStart) then							
								
		#NAAM?						
		local allEffects = { }						
		local effectNum = 0						
		local done = false						
		while ((done ~= true) and (battleScene:HasPendingEffects() == true)) do						
			event = battleScene:GetPendingEffect()					
			eventType = event.eventType					
			if (eventType == PetBattleEvent.RoundComplete) then					
				done = true				
			else					
				effectNum = effectNum + 1				
				allEffects[effectNum] = event				
			end					
		end						
								
		-- if we have at least one effect or we\'re done, make sure						
		#NAAM?						
		#NAAM?						
		if (done == true or #allEffects > 0) then						
			SignalEffectProcessed()					
			ProcessAllRoundResults(allEffects)					
								
			#NAAM?					
			StartEffectProcessing(event)					
		end						
	end							
								
	#NAAM?							
	SignalEffectProcessed()							
								
	if (eventType == PetBattleEvent.RoundComplete) then							
		for playerID, player in pairs(teams) do						
			ClearTrapPrecast(playerID)					
		end						
		#NAAM?						
	end							
								
	return true							
								
	#NAAM?							
	currentEffectInstanceID = event.instanceID							
								
	if currentEffectInstanceID and battleScene then							
		battleScene:SignalEffectApplied(currentEffectInstanceID)						
		currentEffectInstanceID = nil						
	end							
								
								
	if (not abilityVisual) then							
		return						
	end							
								
	local customScriptString = abilityVisual.scriptFunctionString							
								
	if (customScriptString and #customScriptString > 0) then							
		local createString = string.format(createFormatString, customScriptString, abilityVisual.ID, customScriptString)						
		local status, result = pcall(loadstring(createString))						
		if (status == true) then						
			setfenv(result, getfenv())					
			abilityVisual.scriptFunction = result					
		else						
			"print(\""ERROR: loading script on BattlePetVisual ID=\"" .. abilityVisual.ID .. \"" failed: \"" .. createString)"					
			"print(\""ERROR: \"" .. result)"					
		end						
	end							
								
	cameraBunnyCreate.model = padModel							
	cameraBunnyCreate.transform.position = player.playerDisplay:GetPosition()							
	cameraBunnyCreate.interactible = false							
								
	cameraBunny = scene:SpawnActor(cameraBunnyCreate)							
	scene:SetGameCameraTarget(cameraBunny, freelookZoomMin, freelookZoomMax)							
								
	cameraBunny:MoveToAbs(Vector:New(), transitionTime)							
								
	if ( not isObserved ) or ( not useFreelookCamera ) then							
		return						
	end							
								
	#NAAM?							
	local player = teams[observingPlayerIndex]							
	cameraBunny:MoveToAbs(player.playerDisplay:GetPosition(), transitionTime)							
	if (Scene.ResetGameCameraZoom) then							
		scene:ResetGameCameraZoom()						
	end							
	scene:WaitTimer(transitionTime)							
	scene:SetGameCameraTarget(nil, 0.0, 0.0)							
								
	if ( not isObserved ) then							
		return						
	end							
								
	local observedTeam = teams[observingPlayerIndex]							
	local otherTeam = teams[3 - observingPlayerIndex]							
								
	if ( camera == 1 ) then 							
		scene:SetCamera(battleCameraIDs.intro, 3.0, observedTeam.pad.actor, otherTeam.pad.actor)						
	elseif ( camera == 2 ) then 							
		scene:SetCamera(battleCameraIDs.idle, 3.0, observedTeam.pad.actor, arenaRing)						
	elseif ( camera == 3 ) then 							
		scene:SetCamera(battleCameraIDs.idle, 0.0, observedTeam.pad.actor, arenaRing)						
	elseif ( camera == 4 ) then							
		scene:SetCamera(0, 0.75, nil, nil)						
	end							
								
								
								
	local scaleCreateData = ActorCreateData:Default()							
	"scaleCreateData.name = \""scaleAxis\"""							
	"scaleCreateData.model = \""SPELLS\\AxisTestObject.m2\"""							
	scaleCreateData.scale = 2.0							
	scaleCreateData.interactible = false							
	axis = scene:SpawnActor(scaleCreateData)							
					createData.interactible = false			
					createData.floatingTooltip = false			
								
					local pos = BuildVector(player.teamFacing, -playerRadius, 0.0)			
					local transform = Transform:New(pos, player.teamFacing)			
					createData.transform = transform			
								
					placeHolderActor = scene:SpawnActor(createData)			
					placeHolderActors[playerID] = placeHolderActor			
				end				
								
				#NAAM?				
				player.playerDisplay = placeHolderActor				
			else					
				-- done with this placeholder, despawn it				
				local placeHolderActor = placeHolderActors[playerID]				
				if (placeHolderActor) then				
					placeHolderActor:Despawn()			
				end				
								
				placeHolderActors[playerID] = nil				
			end					
		end						
	end							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	#NAAM?							
	"local padCreateData = ActorCreateData:Default();"							
	"padCreateData.name = \""pad\"";"							
	"padCreateData.model = padModel;"							
	"padCreateData.transform = transform;"							
	"padCreateData.scale = padScale*battleScale;"							
								
	pad = scene:SpawnActor(padCreateData)							
	pad:Fade(padAlpha, 0.5)							
	"pad:SetInteractible(false);"							
								
	"return pad;"							
								
		local padPet = { 						
			"isPad = true;"					
			"actor = team.pad;"					
			"auras = {}; "					
			"slot = petIndex; "					
			"team = team.playerID; "					
		"};"						
		"team.pets = {};"						
		"team.pets[PetBattlePetID.Weather] = padPet;"						
		"team.pets[PetBattlePetID.Weather].actor = team.pad;"						
								
		"return;"						
	else							
		team.isWeather = false						
	end							
								
	#NAAM?							
	"local masterTransform = MASTER_SPOTS[playerID];"							
	"local masterLoc = masterTransform.position;"							
	local master							
								
	#NAAM?							
	if (team.npcCreatureID and team.npcCreatureID > 0 and team.npcDisplayID) then							
		"local npcCreateData = ActorCreateData:Default();"						
		"npcCreateData.creatureID = team.npcCreatureID;"						
		"npcCreateData.creatureDisplayID = team.npcDisplayID;"						
		"npcCreateData.interactible = false;"						
		"npcCreateData.transform = masterTransform;"						
		"npcCreateData.scale = battleScale;"						
								
		"master = scene:SpawnActor( npcCreateData );"						
								
		"master:SetFacingToAbs(Vector:New());"						
								
		#NAAM?						
								
		-- Darren\'s scripts required these two						
		"team.npcActor = master;"						
		"team.playerDisplay = master;"						
								
		#NAAM?						
		"team.master = master;"						
	end							
								
								
	#NAAM?							
	"team.pets = {};"							
								
	"mainPetLoc = homeTransform;"							
								
	"local backLineCount = 0;"							
								
	for id,v in pairs( team.petDescs ) do 							
		#NAAM?						
		if (id == PetBattlePetID.Pad) then						
			local padPet = { 					
				"isPad = true;"				
				"actor = team.pad;"				
				"auras = {}; "				
				"slot = petIndex; "				
				"team = team.playerID; "				
			"};"					
			"team.pets[id] =  padPet;"					
								
		#NAAM?						
		elseif ( id == team.activePet and initialBattleState.battleState ~= PetBattleState.WaitingPreBattle ) then 						
			"team.pets[id] = InitPet(team, id, mainPetLoc);"					
		else						
			"backLineCount = backLineCount + 1;"					
								
			#NAAM?					
			"local offset = FastLocalFacingCoordinates ( masterTransform.position, Vector:New(), BACKROW_PET_OFFSETS[backLineCount] );"					
			"team.pets[id] =  InitPet(team, id, Transform:New( offset, masterTransform.yaw ) );"					
		end						
	end							
								
								
	#NAAM?							
	#NAAM?							
	if ( initialBattleState.battleState ~= PetBattleState.WaitingPreBattle ) then 							
		for k,v in pairs(team.pets) do						
			if ( k ~= team.activePet ) then 					
				"v.actor:SetFacingToTarget(team.pets[team.activePet].actor, Vector:New());"				
			end					
		end						
	else							
		for k,v in pairs(team.pets) do						
			if ( k ~= team.activePet ) then 					
				"v.actor:SetFacingToAbs(Vector:New());"				
			end					
		end						
	end							
								
								
	"local petData = team.petDescs[petIndex];"							
	local petActor = scene:SpawnActor(ActorCreateData:New(petData.creatureID, transform, battleScale))							
								
	local pet = { 							
		"actor = petActor; "						
		"moveSpeed = 5; "						
		"auras = {}; "						
		"slot = petIndex; "						
		"playerID = team.playerID; "						
		"team = team.playerID;"						
		"creatureID = petData.creatureID;"						
		"teamFacing = team.teamFacing; -- Needed for Darren compat only"						
		"health = petData.health;"						
	"};"							
								
	#NAAM?							
	pet.currentRadius = backlineRadius							
	pet.currentOffset = 0							
								
	#NAAM?							
	SetXP(pet, petData.xp, petData.level, true)							
	SetHealth(pet, petData.health, true)							
								
	pet.status = petData.status							
								
	#NAAM?							
	"petActor:SetInteractible(false);"							
	"--petActor:SetHidden(true);"							
	"--petActor:Fade(0, 0);"							
	"	0	594
594	[1] Brazie\'s PetBattle - Init Player"""	"pet.standAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Stand, false, Animations.None)


	-- apply initial auras
	for auraIndex, auraData in pairs(petData.auras or { }) do
		local auraVisual = petAbilityVisuals[auraData.auraVisualID]
		if (auraVisual) then
			ApplyAura(pet, auraData.instanceID, auraData.turnsRemaining, auraVisual.spellVisualID)
		end
	end

	return pet;
end"	593	0				
		"print(\""== Start Round Playback ==\"")"						
	end 							
								
	#NAAM?							
	for index, turn in pairs(topLevelTurnGroups) do							
		ProcessRoundTurnGroup( turn )						
	end							
								
	if (debugOn == true) then							
		"print(\""== End Round Playback ==\"")"						
		"print(\""  \"")"						
	end							
								
								
								
	if (debugOn == true) then							
		"print(\""- Processing Turn \"" .. turnGroup.firstEffect.turnInstanceID)"						
	end							
								
	#NAAM?							
	local turnVisual = nil							
	if (turnGroup.firstEffect.turnVisualID) then							
		turnVisual = petAbilityVisuals[turnGroup.firstEffect.turnVisualID]						
	end							
	local processed = false							
	if (turnVisual and turnVisual.scriptFunction) then							
		if ( turnVisual.scriptFunction( turnGroup ) ) then						
			processed = true					
		end						
	end							
								
	#NAAM?							
	if (processed ~= true) then							
		for index, effectGroup in pairs(turnGroup.effects) do						
			ProcessRoundEffectGroup(effectGroup)					
		end						
	end							
								
	if (debugOn == true) then							
		"print(\""-   Processing Effect \"" .. effectGroup.firstEffect.abilityEffectID)"						
	end							
								
	#NAAM?							
	local effectVisual = nil							
	if (effectGroup.firstEffect.abilityVisualID) then							
		effectVisual = petAbilityVisuals[effectGroup.firstEffect.abilityVisualID]						
	end							
	local processed = false							
	if (effectVisual and effectVisual.scriptFunction) then							
		if ( effectVisual.scriptFunction( effectGroup ) ) then						
			processed = true					
		end						
	end							
								
	#NAAM?							
	if (processed ~= true) then							
		for index, effectResult in pairs(effectGroup.results) do						
			StartEffectProcessing(effectResult)					
								
			ProcessRoundResult(effectResult)					
								
			SignalEffectProcessed()					
								
			if (effectResult.procGroup) then					
				ProcessRoundTurnGroup(effectResult.procGroup)				
			end					
		end						
	end							
								
								
	local eventType = event.eventType							
	local effectType = event.effectType							
								
	if not (eventType == PetBattleEvent.RoundEffect) then							
		return						
	end							
								
	if (debugOn == true) then							
		"print(\""-     Processing Result \"" .. event.instanceID)"						
	end							
								
	#NAAM?							
	if (effectType == PetBattleEffect.SetHealth) then							
		EffectSetHealth(event)						
	elseif (effectType == PetBattleEffect.AuraApply) then							
		EffectAuraApply(event)						
	elseif (effectType == PetBattleEffect.AuraCancel) then							
		EffectAuraChange(event, true)						
	elseif (effectType == PetBattleEffect.AuraChange) then							
		EffectAuraChange(event, false)						
	elseif (effectType == PetBattleEffect.PetSwap) then							
		EffectSwap(event.casterPlayerID, event.newFrontPet)						
	elseif (effectType == PetBattleEffect.StatusChange) then							
		EffectStatusChange(event)						
	end							
								
								
								
	local stackDepth = effect.stackDepth or 0							
	local turnInstanceID = effect.turnInstanceID or 0							
	local effectID = effect.abilityEffectID or 0							
	if (stackDepth > maxStackDepth) then							
		"print (\""WARNING: stack depth exceeded \"" .. """	0	643				
		table.insert(list, 						
			petStartPosition + Vector:New(x,y,u) 					
			");"					
	end							
	"table.insert(list, petFinalPoint);"							
	"table.remove(list, 1);"							
								
	"return list;"							
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
								
	for i=1,depth do							
		"prefix = prefix..\""    \"";"						
	end							
								
	"if ( type(table) == \""table\"" ) then "							
		for k,v in pairs(table) do						
			"local label;"					
			if ( lookup ) then 					
				"label = GetStateLabel(k);"				
			end					
								
			"if ( type(v) == \""table\"" ) then "					
				if ( label ) then 				
					"Print(prefix..\"" K: \""..label..\"" V: { \"");"			
				else				
					"Print(prefix..\"" K: \""..k..\"" V: { \"");"			
				end				
				"DEBUG_TABLE(v, depth+1, lookup); "				
				"Print(prefix..\""  }\"");"				
			else					
				if ( label ) then 				
					"Print(prefix..\"" K: \""..label..\"" V: \""..tostring(v));"			
				else				
					"Print(prefix..\"" K: \""..k..\"" V: \""..tostring(v));"			
				end				
			end					
		end						
	else							
		"Print(prefix..\"" \""..tostring(table) );"						
	end							
								
	for k,v in pairs (STATE_LOOKUP) do							
		if ( v == zub ) then						
			"return k;"					
		end						
	end							
								
	"return zub;"							
								
								
	local abilityVisual = petAbilityVisuals[abilityVisualID]							
	if (not abilityVisual) then							
		return						
	end							
								
	local player = nil							
	local pet = nil							
	if (observingPlayerIndex > 0) then							
		player = GetTeamByIndex(observingPlayerIndex)						
		if (player) then						
			pet = player.pets[player.activePet]					
		end						
	end							
								
	if (not pet) then							
		return						
	end							
								
	local casterPlayer = GetTeamByIndex(observingPlayerIndex)							
	local casterFrontPet = casterPlayer.pets[casterPlayer.activePet]							
	local opponentFrontPet = GetActivePetByIndex(3 - observingPlayerIndex)							
								
	ReturnOrResetCheck (casterFrontPet, opponentFrontPet)							
	"return;"							
								
	"local petLoc = returnPoint;"							
	"local petHome = HOME_LIST[pet.playerID].position;"							
	"local newDist = petLoc:Dist ( petHome );"							
								
	local returnDistance = pet.actor:GetPosition():Dist(petLoc)							
								
	if ( newDist > 1.75 * battleScale ) then 							
		"petLoc = HOME_LIST[pet.playerID].position;"						
		"returnDistance = petHome:Dist(pet.actor:GetPosition());"						
		"DebugPrint ( \""reset\""..pet.playerID );"						
	end							
								
	"local opponentHome = HOME_LIST[opponent.playerID].position;"							
								
	local opponentReturnDistance = opponent.actor:GetPosition():Dist(opponentHome)							
								
	if ( opponentReturnDistance > 1.75 * battleScale ) then 							
		"local distance = opponentHome:Dist(pet.actor:GetPosition());"						
		"DebugPrint ( \""opponent reset\""..opponent.playerID );"						
		"opponent.actor:MoveToAbs( opponentHome, distance/ ( opponent.moveSpeed*backwardSpeedMulti) );"						
								
	end							
								
	"--pet.actor:WaitMoveToAbs( pet.home, returnDistance/ ( pet.speed*backwardSpeedMulti) );"							
								
	"pet.actor:MoveToAbs( petLoc, returnDistance/ ( pet.moveSpeed*backwardSpeedMulti) );"							
	pet.actor:WaitMovementComplete()							
	opponent.actor:WaitMovementComplete()							
	pet.actor:SetFacingToAbs(opponent.actor:GetPosition())							
								
	opponent.actor:AddWorldText(opponent.actor, MissReasons.Dodged, false, false)							
								
	"PerformRelativeSlide( opponent, pet, front, left, up );"							
								
	"local front = howHard or 0.75;"							
	local left = 0							
	"local up = 0;"							
								
	"front = front * -1;"							
								
	--scene:WaitTimer(0.3)							
								
	"DebugPrint(\""knock\"")"							
	--opponent.actor:AddDamageText(nil, damage, false, false)							
	local opponentFinalPoint 	"= CalculateUnitFacingRelativeOffset(opponent, pet, front, left, up );"						
	local driftDistance = 3							
								
	"local time = duration or 0.3 --driftDistance/battleScale/opponent.moveSpeed;"							
								
	"--opponent.actor:MoveToAbs(opponentFinalPoint,  Vector:New() );"							
	opponent.actor:SetSnapToGround(false)							
	local kit = opponent.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.Stand)							
								
	opponent.actor:MoveSplineAbs( 							
			BuildKnockbackSpline(opponent.actor:GetPosition(), opponentFinalPoint, time), time )					
	opponent.actor:WaitMovementComplete()							
	opponent.actor:SetSnapToGround(true)							
	"kit:Stop();"							
								
								
	local moveTime = duration or 0.5							
	local anim = animation or Animations.JumpLoop							
								
	"local kit;"							
	if ( anim ) then 							
		#NAAM?						
		"kit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, anim );"						
	end							
								
	pet.actor:SetSnapToGround(false)							
	pet.actor:MoveSplineAbs( 							
			BuildKnockbackSpline(pet.actor:GetPosition(), dest, moveTime), moveTime )					
	pet.actor:WaitMovementComplete()							
	pet.actor:SetSnapToGround(true)							
								
	if ( kit ) then 							
		"kit:Stop();"						
	end							
								
								
	"local front = -math.random(15,15)*.025;"							
	"local left = math.random(-15,15)*.025;"							
	"local up = 0;"							
								
	--scene:WaitTimer(0.3)							
								
	"DebugPrint(\""tinyknock\"")"							
								
	opponent.actor:PlayOneShotSplitBodyAnim(Animations.CombatWound)							
								
	--opponent.actor:AddDamageText(nil, damage, false, false)							
								
								
	"PerformRelativeSlide( opponent, pet, front, left, up );"							
								
	"local front = -math.random(10,20)*.1;"							
	"local left = math.random(-10,10)/10;"							
	"local up = 0;"							
								
	scene:WaitTimer(0.3)							
								
	"DebugPrint(\""knock\"")"							
	--opponent.actor:AddDamageText(nil, damage, false, false)							
	"PerformRelativeSlide( opponent, pet, front, left, up );"							
								
	opponent.actor:SetSnapToGround(false)							
	--opponent.actor:AddDamageText(nil, damage, false, false)							
								
	opponent.actor:MoveSplineAbs(BuildKnockbackSpline(opponent.actor:GetPosition(), opponent.actor:GetPosition(), 0.5), 0.5)							
								
	opponent.actor:WaitMovementComplete()							
	opponent.actor:SetSnapToGround(true)							
								
		return result						
	else							
		"print(\""ERROR: Function Dispatched to \"" .. responsibleObjectID.. \"" failed.\"")"						
		"print(\""ERROR: \"" .. result)"						
	end							
	]]							
								
								
	"print(\""- Processing Turn \"" .. turn.firstEvent.turnInstanceID.. \"" Ability: \""..turn.firstEvent.abilityID)"							
								
	#NAAM?							
								
	"local effect = turn.firstEvent;"							
	#NAAM?							
	local casterPlayerID = effect.casterPlayerID							
	local casterPetSlot = effect.casterPetSlot							
								
	"local ROID = GETROIDFROMPLAYERIDANDSLOT (casterPlayerID, casterPetSlot);"							
								
	#NAAM?							
	"local processed = Dispatcher_HandleSpellVisualPackage(ROID, turn.firstEvent.turnVisualID, \""turn\"", turn)"							
								
	#NAAM?							
	if ( not processed ) then 							
		Dispatcher_DefaultTurnBehaviour(ROID, turn )						
	end							
								
								
								
	#NAAM?							
	local turnVisual = nil							
	if (turnVisualID) then							
		turnVisual = petAbilityVisuals[turnVisualID]						
	end							
	local processed = false							
	if (turnVisual and turnVisual.scriptFunction) then							
		Dispatcher_AddCommandToQueue( ROID, turnVisual.scriptFunction, ...)						
		"processed = true;"						
	end							
								
	return processed							
	if (pet.currentHealth <= 0) and (not pet.dead) then							
		#NAAM?						
		local lookAtPos = BuildVector( (pet.teamFacing or 0.0), idleRadius*1000, 0)						
		pet.actor:SetFacingToAbs(lookAtPos)						
		RemoveAllAuraVisuals(pet)						
								
		#NAAM?						
		local deathKitID = 62						
		if (fullUpdate == true) then						
			#NAAM?					
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Dead, false, Animations.None)					
			"pet.dead = true;"					
		else						
			#NAAM?					
			pet.deathAnimKit = pet.actor:PlayAnimKit(petBattleAnimKits.Death, false, Animations.None)					
			scene:WaitTimer(1.5)					
			"pet.dead = true;"					
		end						
								
		"return \""died\"""						
	elseif (pet.currentHealth <= 0) and (pet.dead) then							
		"return \""dead\"""						
	elseif (pet.currentHealth > 0) and (pet.dead) then							
		#NAAM?						
		pet.deathAnimKit:Stop()						
		pet.deathAnimKit = nil						
		"pet.dead = nil;"						
								
		local lookAtPos = BuildVector(pet.teamFacing, idleRadius, 0)						
		#NAAM?						
		pet.actor:Fade(1, 0.5)						
		#NAAM?						
								
		"return \""respawn\"""						
	end							
			"failureEffect(targetPet, casterCastingPet, result);"					
		end						
	else							
		#NAAM?						
		"if ( type(successEffect) == \""function\"" ) then"						
			"successEffect (targetPet, casterCastingPet, result);"					
		end						
								
		#NAAM?						
		"func(targetPet, casterCastingPet, ...);"						
								
		#NAAM?						
		SignalEffectProcessed()						
								
	end							
								
	#NAAM?							
	if (not dontWait) then							
		casterCastingPet.actor:WaitCastingComplete(true)						
	end							
		"local castingPetSlotName = \""Unknown\"";"						
								
								
		for k,v in pairs(PetBattlePlayerID) do 						
			if ( v == result.casterPlayerID ) then					
				"castingTeamName = k;"				
			end					
		end						
		for k,v in pairs(PetBattlePetID) do 						
			if ( v == result.casterPetSlot ) then					
				"castingPetSlotName = k;"				
			end					
		end						
								
		"print(\""Requesting standard data for \"",castingTeamName,\"" slot \"",castingPetSlotName);"						
	end							
								
	#NAAM?							
	if  ( not result.target ) then							
		return casterCastingPet, nil						
	end							
								
	if ( effectDebug == true ) then 							
		"local targetTeamName = \""Unknown\"";"						
		for k,v in pairs(PetBattlePlayerID) do 						
			if ( v == result.target.playerID ) then					
				"targetTeamName = k;"				
			end					
		end						
		"local targetPetSlotName = \""Unknown\"";"						
		for k,v in pairs(PetBattlePetID) do 						
			if ( v == result.target.petSlot ) then					
				"targetPetSlotName = k;"				
			end					
		end						
								
		"print(\""Requesting standard target data for \"",targetTeamName,\"" slot \"",targetPetSlotName);"						
	end							
								
	local targetData = result.target							
	"local targetPlayerID = targetData.playerID;"							
								
	if ( targetPlayerID > 2 ) then							
		return casterCastingPet, nil						
	end							
								
	local targetPlayer = GetTeamByIndex(targetPlayerID)							
	if ( not targetPlayer ) then 							
		"print(\""ERROR: Invalid targetPlayerID (\"",targetPlayerID,\"")\"");"						
		return casterCastingPet, nil						
	end							
	local targetPet = targetPlayer.pets[targetData.petSlot]							
								
	return casterCastingPet, targetPet							
		"local targetMaster = GETROIDFROMPLAYERID(targetPet.playerID) + ROID_TYPE_PLAYER_MASTER;"						
		"local casterMaster = GETROIDFROMPLAYERID(casterPlayerID) + ROID_TYPE_PLAYER_MASTER;"						
								
		Dispatcher_AddCommandToQueue( targetMaster, Dispatcher_OwnerEmote, Animations.EmoteCry )						
		Dispatcher_AddCommandToQueue( casterMaster, Dispatcher_OwnerEmote, Animations.EmoteCheer )						
	"elseif ( result == \""respawn\"" ) then"							
		"local casterMaster = GETROIDFROMPLAYERID(casterPlayerID) + ROID_TYPE_PLAYER_MASTER;"						
		Dispatcher_AddCommandToQueue( casterMaster, Dispatcher_OwnerEmote, Animations.EmoteCheer )						
	end							
								
		return						
	end							
								
	if (cancel == true) or (turnsRemaining < 1) then							
		RemoveAura(targetPet, auraInstanceID)						
	else							
		aura.turnsRemaining = turnsRemaining						
	end							
	if ( not spellVisualID and not turnVisualSpellID) then 							
		"print( \""No Spell Visual ID provided to successEffect_visual\"" );"						
		"return;"						
	elseif ( not spellVisualID and turnVisualSpellID ) then 							
		"useID = turnVisualSpellID;"						
	end							
	targetPet.actor:PlaySpellImpactVisual(useID)							
								
	-- If its not a proc, knock!							
	local team = GetTeamByIndex(casterPet.playerID)							
	if ( casterPet.slot == team.activePet ) then 							
		PerformTinySlide( targetPet, casterPet ) 						
		--PerformHardKnockback( targetPet, casterPet ) 						
	end							
								
	PerformDodge( targetPet, casterPet ) 							
	"ApplyAura(targetPet, auraInstanceID, turnsRemaining, auraVisualID);"							
								
								
	"-- Only handle \""effect\"" objects"							
	"if ( isEffect ~= \""effect\"" ) then"							
		"print (\""ERROR: Object of type \""..isEffect..\"" passed to DefaultDoEffect\"");"						
		"return SignalEffectProcessed();"						
	end							
								
	-- Check for player ID in the correct bounds:							
	if ( effect.results[1].target.playerID > 2 ) then							
		"print (\""ERROR: Player ID is out of range! \""..effect.results[1].target.playerID)"						
		SignalEffectProcessed()						
		"return;"						
	end							
								
	--PerformMove(pet, opponent, range)							
	local casterCastingPet, targetPet, abilityVisualID = GetStandardData(effect.results[1])							
								
	if ( not skipCast ) then 							
		preEffect_visual(targetPet, casterCastingPet, effect.results[1])						
	end							
								
	for index, result in pairs(effect.results) do							
		StartEffectProcessing(result)						
								
		"local handlerTable = GetDefaultHandlerTable(result, index);"						
								
		#NAAM?						
		if ( handlerOverrides ) then						
			for eventType,overrides in pairs(handlerOverrides) do 					
								
				for k,v in pairs(overrides) do 				
					if ( not handlerTable[eventType] ) then			
						"handlerTable[eventType] = {};"		
					end			
					"handlerTable[eventType][k] = v;"			
				end				
			end					
		end						
								
		local eventType = result.eventType						
		local effectType = result.effectType						
								
		if not (eventType == PetBattleEvent.RoundEffect) then						
			return					
		end						
								
		if (debugOn == true) then						
			"local effectName = \""Unknown\"";"					
								
			for k,v in pairs(PetBattleEffect) do 					
				if ( v == effectType ) then				
					"effectName = k;"			
				end				
			end					
								
			"local eventTypeName = \""Unknown\"";"					
			for k,v in pairs(PetBattleEvent) do 					
				if ( v == eventType ) then				
					"eventTypeName = k;"			
				end				
			end					
								
			"DebugPrint(\""-     Processing Result \"" .. result.instanceID..\"" effectType: \""..effectName..\"" eventType: \""..eventTypeName)"					
		end						
								
								
		Dispatcher_DoFunction(result, 						
			handlerTable[effectType].dontWait, 					
			handlerTable[effectType].successEffect, 					
			handlerTable[effectType].failureEffect, 					
			handlerTable[effectType].func, 					
			unpack( handlerTable[effectType].args) )					
								
								
		SignalEffectProcessed()						
								
		if (result.procGroup) then						
			ProcessRoundTurnGroup(result.procGroup)					
		end						
	end							
								
	"-- Only handle \""effect\"" objects"							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	#NAAM?							
	if ( turn.firstEvent.effectType == PetBattleEffect.PetSwap ) then							
		"print(\""DEBUG: Swap occuring. No combat movement required.\"");"						
								
		#NAAM?						
		"swap_func(nil, nil, turn.firstEvent.casterPlayerID, turn.firstEvent.newFrontPet );"						
	else							
		local abilityVisualID = turn.firstEvent.abilityVisualID						
		local abilityVisual = petAbilityVisuals[abilityVisualID]						
								
		if ( not abilityVisual ) then 						
			"Print(\""ERROR: No ability visual!\"")"					
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, PerformMove, PetBattleRange.InPlace ); "					
		else						
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, PerformMove, abilityVisual.range ); "					
		end						
								
		#NAAM?						
		for index, effect in pairs(turn.effects) do						
			if (debugOn == true) then					
				"local effectName = \""Unknown\"";"				
								
				for k,v in pairs(PetBattleEffect) do 				
					if ( v == effect.firstEvent.effectType ) then			
						"effectName = k;"		
					end			
				end				
								
				"DebugPrint(\""-   Processing Effect \"" .. effect.firstEvent.abilityEffectID..\"" effectType: \""..effectName)"				
			end					
								
			#NAAM?					
			"local processed = Dispatcher_HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effectGroup)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect ); "				
				#NAAM?				
			end					
		end						
								
		#NAAM?						
		"--Dispatcher_AddCommandToQueue(casterPlayerID, casterPetSlot, Dispatcher_PerformTurnEffects, turn ); "						
								
								
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"						
	end							
	scene:WaitTimer(0)							
	"local player = ROIDTOPLAYER( ROID );"							
								
	if ( player ) then							
		"local slot = nil;"						
								
		if ( bitand(ROID, 0x0007) == ROID_TYPE_PLAYER_PET_SLOT_1 ) then						
			slot = 1					
		elseif ( bitand(ROID, 0x0007) == ROID_TYPE_PLAYER_PET_SLOT_2 ) then						
			slot = 2					
		elseif ( bitand(ROID, 0x0007) == ROID_TYPE_PLAYER_PET_SLOT_3 ) then						
			slot = 3					
		end						
								
		if ( slot ) then						
			return player.pets[slot]					
		end						
	end							
								
	"return nil;"							
								
	"local roid = 0;"							
	if ( playerID == 0 ) then							
		roid = roid + ROID_TYPE_WEATHER						
	elseif ( playerID == 1 ) then							
		roid = roid + ROID_TYPE_PLAYER_1						
	elseif ( playerID == 2 ) then							
		roid = roid + ROID_TYPE_PLAYER_2						
	end							
	"return roid;"							
								
								
	"local roid = GETROIDFROMPLAYERID( playerID );"							
								
	if ( slot == 1 ) then							
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_1						
	elseif ( slot == 2 ) then							
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_2						
	elseif ( slot == 3 ) then							
		roid = roid + ROID_TYPE_PLAYER_PET_SLOT_3						
	end							
								
	return roid							
	end							
								
	local turnKey = turnInstanceID*maxStackDepth + stackDepth							
	local effectKey = effectID*maxTurnInstanceIDs*maxStackDepth + turnKey							
	return turnKey, effectKey							
								
								
								
	#NAAM?							
	local turnVisual = nil							
	if (turnVisualID) then							
		turnVisual = petAbilityVisuals[turnVisualID]						
	end							
	local processed = false							
	if (turnVisual and turnVisual.scriptFunction) then							
		Dispatcher_AddCommandToQueue(casterPlayerID, casterPetSlot, turnVisual.scriptFunction, ...)						
		"processed = true;"						
	end							
								
	return processed							
								
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
								
	local abilityVisualID = turn.firstEvent.abilityVisualID							
	local abilityVisual = petAbilityVisuals[abilityVisualID]							
	if ( abilityVisual ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, abilityVisual.range ); "						
	end							
								
								
	#NAAM?							
	local points = {							
	}							
								
	"local numPoints = #turn.effects;"							
								
	local offset=270							
	"local step= 720/numPoints;"							
								
	for i=offset+step,offset+720,step do 							
		local sin = math.sin(i/180*math.pi)						
		local cos = math.cos(i/180*math.pi)						
		"table.insert(points, Vector:New(sin, cos, 0));"						
								
	end							
								
	"local pet = ROIDTOPET(ROID);"							
	local opponent = GetActivePetByIndex(3 - pet.playerID)							
								
	pet.actor:SetFacingToTarget(opponent.actor, Vector:New())							
								
	"local originalOpponentLoc = VectorCopy(opponent.actor:GetPosition());"							
	"local originalPetLoc = VectorCopy(pet.actor:GetPosition());"							
								
	"local i=0;"							
								
	#NAAM?							
	for index, effect in pairs(turn.effects) do							
		if (debugOn == true) then						
			"local effectName = \""Unknown\"";"					
								
			for k,v in pairs(PetBattleEffect) do 					
				if ( v == effect.firstEvent.effectType ) then				
					"effectName = k;"			
				end				
			end					
								
			"DebugPrint(\""-   Processing Effect \"" .. effect.firstEvent.abilityEffectID..\"" effectType: \""..effectName)"					
		end						
								
		#NAAM?						
		"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effectGroup)"						
								
		#NAAM?						
		if (processed ~= true) then						
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect ); "					
			#NAAM?					
		end						
								
								
		-- ## Unique Stuff Start 						
		"i = i + 1;"						
		"local v = points[i];"						
		if ( v ) then 						
			"local newDrift = FastLocalFacingCoordinates(originalOpponentLoc, originalPetLoc , v * -battleScale );"					
								
			local opponentDriftPoint 	"= opponent.actor:GetPosition() + (newDrift-originalOpponentLoc);"				
			local driftDistance = opponentDriftPoint:Dist( pet.actor:GetPosition() )					
			"pet.actor:WaitMoveToAbs(opponentDriftPoint,driftDistance/pet.moveSpeed );"					
		end						
		-- ## Unique Stuff End						
								
	end							
								
	#NAAM?							
	"--Dispatcher_AddCommandToQueue(casterPlayerID, casterPetSlot, Dispatcher_PerformTurnEffects, turn ); "							
								
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
								
		if (debugOn == true) then						
			"local effectName = \""Unknown\"";"					
								
			for k,v in pairs(PetBattleEffect) do 					
				if ( v == effect.firstEvent.effectType ) then				
					"effectName = k;"			
				end				
			end					
								
			"DebugPrint(\""-   Processing Effect \"" .. effect.firstEvent.abilityEffectID..\"" effectType: \""..effectName)"					
		end						
								
								
	for k,v in pairs(STATE_LOOKUP) do							
		if ( v == result.target.stateID ) then						
			"label = k;"					
			"break;"					
		end						
	end							
								
	"DebugPrint(\""*** State Update: \"",label,\"" = \"",result.target.stateValue) "							
								
	#NAAM?							
	if ( result.target.stateID == 84 ) then							
								
		if ( result.target.stateValue > 0 ) then						
			"target.stealthed = true;"					
		else						
			"target.stealthed = false;"					
		end						
		local ROID = GETROIDFROMPLAYERIDANDSLOT( target.playerID, target.slot )						
		target.actor:Fade( GetNaturalAlpha(ROID) , 0.5)						
	end							
			end					
		end						
	end							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	if ( #turn.effects == 1 ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, PetBattleRange.Melee); "						
								
		#NAAM?						
		"local processed = HandleSpellVisualPackage( ROID, turn.effects[1].firstEvent.abilityVisualID, \""effect\"", turn.effects[1])"						
								
		#NAAM?						
		if (processed ~= true) then						
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, turn.effects[1] ); "					
			#NAAM?					
		end						
								
								
	else							
		-- ## Unique Stuff Start 						
		"local pet = ROIDTOPET(ROID);"						
		local opponent = GetActivePetByIndex(3 - pet.playerID)						
		"local alpha = 0;"						
		"local delay = 0.5; -- sec"						
		"pet.actor:PlaySpellCastVisual(255);"						
		pet.actor:Fade(alpha, delay)						
		scene:WaitTimer(delay)						
		pet.actor:SetFacingToTarget(opponent.actor, Vector:New())						
								
		local opponentLocation = opponent.actor:GetPosition()						
		"local behindSpot = FastLocalFacingCoordinates(opponentLocation, pet.actor:GetPosition() , Vector:New(-0.5,0,0) );"						
								
		local distance = opponentLocation:Dist( behindSpot )						
								
		"pet.actor:WaitMoveToAbs(behindSpot,0); --driftDistance/pet.moveSpeed "						
								
		"pet.actor:PlaySpellCastVisual(255);"						
		pet.actor:Fade( GetNaturalAlpha(ROID) , delay)						
		scene:WaitTimer(delay)						
								
		-- ## Unique Stuff End						
								
		#NAAM?						
		--for index, effect in pairs(turn.effects) do						
								
		"local effect = turn.effects[2];"						
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect ); "				
				#NAAM?				
			end					
								
		#NAAM?						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
								
			"table.remove(myList.commands,1);"					
		end						
								
		"UNIT_ACTION_QUEUE[myROID].isProcessing = false;"						
		"myROID = nil;"						
		"myList = nil;"						
	end							
								
	scene:WaitTimer(0)							
								
			"table.remove(myList.commands,1);"					
		end						
								
		"UNIT_ACTION_QUEUE[myROID].isProcessing = false;"						
		"myROID = nil;"						
		"myList = nil;"						
	end							
								
	scene:WaitTimer(0)							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])							
	local turnVisual = petAbilityVisuals[turnVisualID]							
	if ( turnVisual ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); "						
	end							
								
	for index, effect in pairs(turn.effects) do							
		if ( index <= n ) then 						
			local abilityVisualID = effect.firstEvent.abilityVisualID					
			local abilityVisual = petAbilityVisuals[abilityVisualID]					
			if ( abilityVisual ) then 					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, PerformMove, abilityVisual.range ); "				
			end					
								
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect ); "				
				#NAAM?				
			end					
		else						
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect, nil, true)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, nil, true ); "				
				#NAAM?				
			end					
			for index, result in pairs(effect.results) do					
				StartEffectProcessing(result)				
				SignalEffectProcessed()				
			end					
		end						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
	for index, effect in pairs(turn.effects) do							
		if ( index <= n ) then 						
			local abilityVisualID = effect.firstEvent.abilityVisualID					
			local abilityVisual = petAbilityVisuals[abilityVisualID]					
			if ( abilityVisual ) then 					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, PerformLeap, abilityVisual.range, Animations.Jump ); "				
			end					
								
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect ); "				
				#NAAM?				
			end					
		else						
			for index, result in pairs(effect.results) do					
				StartEffectProcessing(result)				
				SignalEffectProcessed()				
			end					
		end						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
	end							
								
	if ( finalDestination ) then 							
		"local distance = finalDestination:Dist( pet.actor:GetPosition() );"						
								
		if ( distance > 0.02 ) then 						
			"moveTime = distance/battleScale/(pet.moveSpeed);"					
			pet.actor:WaitMoveToAbs(finalDestination, moveTime)					
		end						
	else							
		"-- \""You didnt need to go anywhere"						
	end							
								
	end							
								
	if ( finalDestination ) then 							
		"local distance = finalDestination:Dist( pet.actor:GetPosition() );"						
								
		if ( distance > 0.02 ) then 						
								
			PerformJump( pet, finalDestination, 0.5, animation )					
								
		end						
	else							
		"-- \""You didnt need to go anywhere"						
	end							
								
								
	target = effect.target							
	local targetPlayer = GetTeamByIndex(target.playerID)							
	local targetPet = targetPlayer.pets[target.petSlot]							
								
	if (target and target.newStatus) then							
		targetPet.status = target.newStatus						
	end							
								
	#NAAM?							
	local player = nil							
	if (effect.casterPlayerID > 0) then							
		player = GetTeamByIndex(effect.casterPlayerID)						
	end							
								
	if (player) then							
		if (effect.abilityVisualID == player.trapVisualID) then						
			TrapCast(effect)					
		end						
	end							
	"setfenv(1, env);"							
	]]---							
								
	"-- Only handle \""effect\"" objects"							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	"local radius = 3; "							
	"local cloneSpeed = 10;"							
	"local effectTime = 2;"							
								
	"local chargeWithClones = true;"							
								
	local cols = clonesPerRow							
	local rows = #turn.effects							
								
	if ( chargeWithClones ) then 							
		"rows = rows - 1;"						
	end							
								
	"local frontSpread = radius*2 / rows; "							
	"local leftSpread = radius*2 / cols; "							
								
	"local objectTable = {};"							
								
	for i=1,rows do							
		for j=1,cols do						
			local col = j					
			"local row = i;"					
								
			table.insert(objectTable, {					
					"index = (i-1)*rows+(j);"			
					f = -radius + row*frontSpread + math.random( -frontSpread*0.75,frontSpread*0.75 ), 			
					l = -radius + col*leftSpread + math.random( -leftSpread*0.75,leftSpread*0.75 )			
			"});"					
		end						
	end							
								
	"local pet = ROIDTOPET(ROID);"							
	local opponent = GetActivePetByIndex(3 - pet.playerID)							
								
	"local name = \""Clone\"";"							
	"local creatureID = pet.creatureID; "							
	"local scale = 1;"							
								
	"local createData = ActorCreateData:Default();"							
	"createData.creatureID = creatureID;"							
	"createData.scale = scale;"							
	"createData.interactible = false;"							
								
	"local petStartingPoint = VectorCopy(pet.actor:GetPosition());"							
	"local centerStartingPoint = FastLocalFacingCoordinates( petStartingPoint, opponent.actor:GetPosition(), Vector:New(-8,0,0) );"							
	"local centerEndingPoint   = FastLocalFacingCoordinates( opponent.actor:GetPosition(), petStartingPoint, Vector:New(-8,0,0) );"							
								
	local cleanUpCheck=function(remove)							
		for i=#objectTable,1,-1 do 						
			local v = objectTable[i]					
			if ( v.actor ) then					
				"local remainder = v.actor:GetPosition():Dist( v.destination );"				
				if ( remainder < 4 or not v.actor:IsMoving() ) then 				
					"v.actor:Despawn();"			
					if ( remove ) then			
						"table.remove(objectTable,i);"		
					end			
				end				
			elseif (remove) then					
								
				"table.remove(objectTable,i);"				
			end					
		end						
	end							
								
	"local timeSpent = 0;"							
	"local waveDelay = effectTime/rows;"							
	"local effectDelay = (opponent.actor:GetPosition():Dist(petStartingPoint) / cloneSpeed ) + waveDelay;"							
	"local petDelay = 0;"							
								
	local nextWave = 0							
								
	"local waveIndex = 1;"							
	"local effectIndex = 1;"							
								
	"local delay = 0.05;"							
								
	"local petStarted = false;"							
	"local petFirstHit = false;"							
	"local petArrived = false;"							
	"local petTeleport = false;"							
	"local petReturned = false;"							
	"local petDone = false;"							
								
	local doEffect = function(updateDelay)							
		"local effect = turn.effects[effectIndex];"						
		#NAAM?						
		if ( effectIndex <= 99 ) then 						
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, nil, true ); "				
				#NAAM?				
			end					
		else						
			for index, result in pairs(effect.results) do					
				StartEffectProcessing(result)				
				SignalEffectProcessed()				
			end					
		end						
								
		"effectIndex = effectIndex + 1;"						
								
		if ( updateDelay ) then 						
			effectDelay = timeSpent + waveDelay	/ 2				
		end						
	end							
								
	while effectIndex <= #turn.effects do							
								
		if ( timeSpent >= petDelay and not pet.actor:IsCasting()) then 						
			if ( not petStarted ) then 					
				"petStarted = true;"				
				"pet.actor:ClearFacing(); "				
				"pet.actor:MoveToAbs( centerEndingPoint,  petStartingPoint:Dist( centerEndingPoint ) / cloneSpeed );"				
				petDelay = 0.1				
			elseif ( not petFirstHit ) then  					
				"local remainder = pet.actor:GetPosition():Dist( """	0	685		
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	local abilityVisualID = turn.firstEvent.abilityVisualID							
	local abilityVisual = petAbilityVisuals[abilityVisualID]							
	if ( abilityVisual ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, abilityVisual.range ); "						
	end							
								
	if ( #turn.effects == 1 ) then 							
		#NAAM?						
		"local processed = HandleSpellVisualPackage( ROID, turn.effects[1].firstEvent.abilityVisualID, \""effect\"", turn.effects[1])"						
								
		#NAAM?						
		if (processed ~= true) then						
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, turn.effects[1] ); "					
			#NAAM?					
		end						
								
								
	else							
		-- Handle 2nd effect						
		"local effect = turn.effects[2];"						
								
		local overrides = {						
			[PetBattleEffect.SetHealth] = {					
				"successEffect = huge_knockback_successEffect_visual;"				
			"};"					
		"};"						
								
		#NAAM?						
		"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect, overrides)"						
								
		#NAAM?						
		if (processed ~= true) then						
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, overrides ); "					
			#NAAM?					
		end						
								
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
								
	--[[							
	local abilityVisualID, spellVisualID = GetVisualData(result)							
								
	if ( not spellVisualID ) then 							
		"print( \""No Spell Visual ID provided to successEffect_visual\"" );"						
		"return;"						
	end							
	]]							
								
	#NAAM?							
	targetPet.actor:PlaySpellImpactVisual( 6587 ) 							
								
	-- If its not a proc, knock!							
	local team = GetTeamByIndex(casterPet.playerID)							
	if ( casterPet.slot == team.activePet ) then 							
		--PerformTinySlide( targetPet, casterPet ) 						
		PerformKnockback( targetPet, casterPet, 3 ) 						
	end							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return; "						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, PerformMove, PetBattleRange.Ranged); "							
								
	if ( #turn.effects == 1 ) then 							
								
		#NAAM?						
		"local processed = HandleSpellVisualPackage( ROID, turn.firstEvent.turnVisualID, \""effect\"", turn.effects[1], nil, true)"						
								
		#NAAM?						
		if (processed ~= true) then						
			local casterCastingPet, targetPet = GetStandardData(turn.effects[1].results[1])					
			local abilityVisualID, spellVisualID, turnVisualID, turnVisualID = GetVisualData(turn.effects[1].results[1])					
								
			PerformSpellVisual(casterCastingPet, turnVisualID, targetPet )					
								
			-- Handle 2nd effect					
			local overrides = {					
				[PetBattleEffect.SetHealth] = {				
					"successEffect = function(...) secondary_successEffect_visual( turnVisualID, ...) end;"			
				"};"				
			"}; "					
								
			#NAAM?					
			"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, turn.effects[1], overrides, true ); "					
			#NAAM?					
		end						
	elseif ( #turn.effects > 1 ) then 							
		for i=2, #turn.effects do						
			-- Handle 2nd effect					
			"local effect = turn.effects[i];"					
								
			local overrides = {					
				[PetBattleEffect.SetHealth] = {				
					"successEffect = function(...) secondary_successEffect_visual(secondaryVisualID, ...) end;"			
				"};"				
			"}; "					
								
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect, overrides, true)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, overrides, true ); "				
				#NAAM?				
			end					
		end						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
								
	--[[							
	local abilityVisualID, spellVisualID = GetVisualData(result)							
								
	if ( not spellVisualID ) then 							
		"print( \""No Spell Visual ID provided to successEffect_visual\"" );"						
		"return;"						
	end							
	]]							
	#NAAM?							
	targetPet.actor:PlaySpellImpactVisual( secondaryVisual ) 							
	-- If its not a proc, knock!							
	local team = GetTeamByIndex(casterPet.playerID)							
	if ( casterPet.slot == team.activePet ) then 							
		--PerformTinySlide( targetPet, casterPet ) 						
		PerformKnockback( targetPet, casterPet, 3 ) 						
	end							
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
	local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])							
	local turnVisual = petAbilityVisuals[turnVisualID]							
	if ( turnVisual ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); "						
	end							
								
	for index, effect in pairs(turn.effects) do							
		if ( index <= n ) then 						
								
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, turn.firstEvent.turnVisualID, \""effect\"", turn.effects[1], nil, true)"					
								
			#NAAM?					
			if (processed ~= true) then					
				local casterCastingPet, targetPet = GetStandardData(turn.effects[1].results[1])				
				local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])				
								
				PerformSpellVisual(casterCastingPet, turnVisualID, targetPet )				
								
				-- Handle 2nd effect				
				local overrides = {				
					[PetBattleEffect.SetHealth] = {			
						"successEffect = function(...) secondary_successEffect_visual( turnVisualID, ...) end;"		
					"};"			
				"}; "				
								
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, turn.effects[1], overrides, true ); "				
				#NAAM?				
			end					
		else						
								
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect, nil, true)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, nil, true ); "				
				#NAAM?				
			end					
			for index, result in pairs(effect.results) do					
				StartEffectProcessing(result)				
				SignalEffectProcessed()				
			end					
		end						
	end							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
	"if ( isTurn ~= \""turn\"" ) then"							
		"print (\""ERROR: Object of type \""..isTurn..\"" passed to DefaultDoEffect\"");"						
								
		"return;"						
	end							
								
								
	"local n = #turn.effects;"							
								
	local abilityVisualID, spellVisualID, turnVisualID, turnSpellVisualID = GetVisualData(turn.effects[1].results[1])							
	local turnVisual = petAbilityVisuals[turnVisualID]							
	if ( turnVisual ) then 							
		#NAAM?						
		"Dispatcher_AddCommandToQueue(ROID, PerformMove, turnVisual.range ); "						
	end							
								
	"local casterCastingPet = ROIDTOPET( ROID );"							
								
								
	local preCastInstance = casterCastingPet.actor:PlaySpellPreCastVisual(25866)							
	scene:WaitTimer(1)							
	casterCastingPet.actor:ClearSpellPreCastVisual(25866, preCastInstance)							
	casterCastingPet.actor:PlaySpellCastVisual(25866)							
								
	local newPosition = casterCastingPet.actor:GetPosition()+Vector:New(8,0,0.5)							
	"local transform = Transform:New( newPosition, 0, -90, 0 );"							
	local create = ActorCreateData:NewModel(							
		"\""Moonfire\"","						
		"\""SPELLS\\MOONFIRE_IMPACT_BASE.m2\"","						
		transform,						
		"0.5);"						
	"create.groundSnap = false;"							
	"local newActor = scene:SpawnActor(create);"							
								
	#NAAM?							
								
	scene:WaitTimer(0.5)							
								
								
	local overrides = {							
		[PetBattleEffect.SetHealth] = {						
			"successEffect = ion_cannon_knockback_successEffect_visual;"					
		"};"						
	"};"							
								
	for index, effect in pairs(turn.effects) do							
		if ( index <= n ) then 						
			#NAAM?					
			"local processed = HandleSpellVisualPackage( ROID, effect.firstEvent.abilityVisualID, \""effect\"", effect, overrides, true)"					
								
			#NAAM?					
			if (processed ~= true) then					
				#NAAM?				
				"Dispatcher_AddCommandToQueue(ROID, Dispatcher_DefaultDoEffect, effect, overrides, true ); "				
				#NAAM?				
			end					
		else						
			for index, result in pairs(effect.results) do					
				StartEffectProcessing(result)				
				SignalEffectProcessed()				
			end					
		end						
	end							
								
	scene:WaitTimer(0.5)							
	"newActor:Despawn();"							
								
	#NAAM?							
	"Dispatcher_AddCommandToQueue(ROID, Dispatcher_PerformPostAttackCleanup );"							
								
								
	--[[							
	local abilityVisualID, spellVisualID = GetVisualData(result)							
								
	if ( not spellVisualID ) then 							
		"print( \""No Spell Visual ID provided to successEffect_visual\"" );"						
		"return;"						
	end							
	]]							
								
	#NAAM?							
	targetPet.actor:PlaySpellImpactVisual( 6587 ) 							
								
	-- If its not a proc, knock!							
	local team = GetTeamByIndex(casterPet.playerID)							
	if ( casterPet.slot == team.activePet ) then 							
		--PerformTinySlide( targetPet, casterPet ) 						
		PerformKnockback( targetPet, casterPet, 5 ) 						
	end							
